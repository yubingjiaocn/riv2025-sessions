# AWS re:Invent 2025 SAS 412 会话总结：成本高效的多租户知识库

## 会话概述

本次会话由AWS解决方案架构师Mike Leby和Stephen Warick主讲,主题为如何构建成本高效的多租户知识库系统。两位讲师分别拥有9年和5.5年的AWS工作经验,专注于为软件公司提供SaaS架构解决方案。

会话采用互动式代码演示(Code Talk)形式,旨在向客户展示AWS如何思考和解决多租户知识库架构中的实际问题。讲师强调这不是唯一的解决方案,而是一种经过验证的有效方法,鼓励参会者根据自身业务需求进行调整。核心理念是通过Amazon Bedrock知识库提供抽象层,使开发者能够使用统一的代码接口访问不同的向量存储后端(如OpenSearch、PostgreSQL PG Vector、S3 Vector),从而在不重写应用程序的情况下,为不同层级的租户提供差异化的性能和成本配置。

会话重点展示了如何通过自定义数据源、元数据过滤和TTL(生存时间)机制实现租户级别的数据隔离、灵活的数据生命周期管理,以及如何通过CDK(Cloud Development Kit)自动化部署整个基础设施。这种架构特别适合需要为不同客户提供分层服务(如免费层、标准层、企业层)的SaaS应用场景。

## 详细时间线与关键要点

### 开场与背景介绍 (00:00 - 03:30)
- **00:00** - 会话开始,确认会场为SAS 412,主题为成本高效的多租户知识库
- **00:30** - Mike Leby自我介绍:AWS工作9年以上,专注于与客户合作解决实际问题
- **01:15** - Stephen Warick自我介绍:AWS解决方案架构师5.5年,之前有30年工程师经验,专注于SaaS架构
- **02:00** - 强调会话为互动式代码演示,需要观众积极参与提问
- **02:45** - 说明会话起源:客户向Stephen咨询如何构建支持多租户的知识库系统

### 核心设计挑战 (03:30 - 08:00)
- **03:30** - 介绍多租户知识库的主要设计决策点
- **04:00** - 数据隔离(Data Segmentation):确保租户数据不会泄露到其他租户,这是多租户应用的核心要求
- **04:45** - 租户特定搜索:用户上传文档后需要能够针对自己的文档进行语义搜索和聊天
- **05:15** - 混合搜索:不仅支持语义搜索,还需要支持关键词搜索
- **05:45** - AI集成:如何将知识库连接到聊天机器人或AI查询系统
- **06:30** - 跨不同向量存储的统一接口:客户A可能需要超低延迟,客户B可能更关注成本,如何用统一方式支持不同需求

### 向量存储性能分层 (08:00 - 11:30)
- **08:00** - 介绍三种向量存储选项的对比
- **08:30** - OpenSearch:非常低延迟,支持混合搜索,但需要预配置成本
- **09:15** - PG Vector(PostgreSQL):低延迟,优势在于可以与结构化数据集成,适合混合查询场景
- **10:00** - S3 Vector Bucket(2024 re:Invent发布):按使用付费模型,无需预配置成本,但查询延迟较高
- **10:45** - 使用场景建议:免费层用户可使用S3 Vector降低成本,付费客户使用OpenSearch或PG Vector获得更好性能
- **11:15** - 强调不希望为每种向量存储编写不同的应用程序代码

### 数据生命周期管理 (11:30 - 13:00)
- **11:30** - 讨论数据生命周期管理的重要性
- **12:00** - 两个原因:成本控制和数据时效性(非结构化数据容易过时)
- **12:30** - 行业案例:房地产行业数据更新快速,医疗记录可能需要定期清理以符合监管要求
- **12:50** - 如何为不同租户配置不同的数据保留规则

### 架构概览 (13:00 - 15:30)
- **13:00** - 展示整体架构图
- **13:20** - 用户界面:通过Amazon Cognito进行身份验证,JWT令牌中包含租户信息
- **14:00** - Lambda函数:接收请求,使用Bedrock进行LLM推理
- **14:30** - Bedrock知识库:作为抽象层,与后端向量存储(OpenSearch、S3等)交互
- **15:00** - 强调使用自定义存储和自定义数据类型,支持更灵活的文件管理和元数据处理
- **15:20** - 与批量导入模式的区别:这是一种更精细化的按需导入模式

### 实时演示 (15:30 - 21:00)
- **15:30** - 开始实时演示,登录租户A账户
- **16:00** - 展示租户A的文件列表,使用S3 Vector存储,部分文件已设置过期时间
- **16:45** - 演示文件索引过程,显示容量限制(不同租户层级有不同配额)
- **17:30** - 切换到租户C账户,使用OpenSearch,拥有更高的文件配额和查询速率
- **18:15** - 展示聊天界面,用户只能看到和查询自己索引的文件
- **19:00** - 尝试实时查询(因网络问题使用预先准备的结果)
- **19:45** - 强调可以按租户、按用户进行文件隔离
- **20:30** - 说明即使文件已索引,也可以选择只查询特定文件子集

### CDK代码演示 - 主栈 (21:00 - 24:00)
- **21:00** - 切换到代码编辑器,展示CDK应用程序
- **21:30** - 解释主栈(Main Stack):使用CDK构建AWS基础设施的入口点
- **22:00** - 展示创建多个知识库的代码:OpenSearch知识库和PostgreSQL知识库
- **22:45** - 说明S3 Vector的CDK构造仍在开发中,目前使用自定义资源通过API直接构建
- **23:30** - 强调最终查询时都通过统一的知识库接口,无论后端使用哪种向量存储

### 知识库配置代码 (24:00 - 28:30)
- **24:00** - 进入知识库栈(Knowledge Base Stack)代码
- **24:30** - 展示知识库基本配置:名称、描述等
- **25:00** - 知识库配置(Knowledge Base Configuration):设置向量类型、嵌入模型等参数
- **25:45** - 强调这些参数可以作为变量传入,为不同知识库定制配置
- **26:15** - 存储配置(Storage Configuration):传入OpenSearch或Aurora配置
- **26:45** - 展示RDS配置:设置嵌入和分块参数
- **27:15** - 展示Aurora和OpenSearch Serverless的不同配置方式
- **27:50** - 关键点:虽然每个向量存储的设置不同,但查询时使用统一接口

### 观众问答 - 向量存储选择 (28:30 - 31:00)
- **28:30** - 观众提问:不同向量存储的优缺点是什么?
- **29:00** - 回答:主要考虑价格与延迟的平衡
- **29:30** - 免费层用户:使用S3 Vector,延迟稍高但成本低
- **30:00** - 付费用户:根据熟悉程度选择PostgreSQL或OpenSearch
- **30:30** - 其他因素:现有技术栈、运维经验、特定需求(如Pine Cone等第三方服务)
- **30:50** - 强调没有一刀切的方案,需要根据不同维度选择

### 观众问答 - 表格数据与准确性 (31:00 - 33:00)
- **31:00** - 观众提问:小型表格数据从OpenSearch迁移到PG Vector是否值得?对准确性有何影响?
- **31:45** - 回答:很难给出确定答案,取决于数据类型、大小、列数等
- **32:15** - 建议使用AWS Samples GitHub中的性能测试工具进行评估
- **32:40** - 强调嵌入模型和分块策略对搜索质量的影响比向量存储引擎本身更大

### 数据源配置代码 (33:00 - 36:00)
- **33:00** - 展示数据源(Data Source)配置代码
- **33:30** - 关键点:将数据源配置设置为"自定义(Custom)"
- **34:00** - 解释:不是从S3批量拉取所有文件,而是精确控制哪些文件被索引
- **34:30** - 这种方式支持更精细化的按需导入模式
- **35:00** - 展示完整的数据源配置代码
- **35:30** - 说明接下来将展示数据摄取(Ingest)、查询(Query)和数据过期清理的代码

### 观众问答 - 缓存层 (36:00 - 37:00)
- **36:00** - 观众提问:如何在架构中添加缓存层?
- **36:30** - 回答:可以考虑使用CloudFront进行结果缓存,或使用ElastiCache
- **36:50** - 说明当前演示架构中未包含缓存层

### 观众问答 - 知识库抽象层的优势 (37:00 - 37:30)
- **37:00** - 观众提问:使用知识库抽象层相比直接访问向量存储有什么优势?
- **37:15** - 回答:将在接下来的摄取和查询代码演示中详细说明

### 数据摄取代码演示 (37:30 - 43:00)
- **37:30** - 打开Python摄取文件
- **38:00** - 说明这是用户点击"索引文件"按钮时触发的代码
- **38:30** - 遍历用户选择的文件,为每个文件创建文档结构
- **39:00** - 关键代码:设置内容类型(Content Type)和数据源类型为"自定义(Custom)"
- **39:30** - 提供文件标识符和S3位置信息
- **40:00** - 最重要部分:添加元数据(Metadata)
- **40:30** - 强调如果直接使用向量存储,需要为OpenSearch、PG Vector、S3 Vector分别编写不同的过滤逻辑
- **41:00** - 展示元数据代码:包含用户ID和租户ID
- **41:30** - 解释:摄取时添加元数据,查询时使用相同元数据进行过滤
- **42:00** - DynamoDB TTL机制:同时在DynamoDB中创建记录,设置生存时间(TTL)
- **42:30** - 称赞TTL为"最被低估的功能之一",成本效益高
- **42:50** - TTL实现了演示中显示的文件过期日期功能

### 元数据的关键作用 (43:00 - 44:00)
- **43:00** - Mike补充:关键在于无论使用哪种向量存储,都使用相同的元数据结构
- **43:30** - 不需要知道OpenSearch中的具体索引名称
- **43:45** - 一套代码、一套查询逻辑适用于所有Bedrock知识库支持的向量存储

### 抽象层的价值总结 (44:00 - 44:30)
- **44:00** - 回答之前的问题:为什么不直接访问向量存储?
- **44:15** - 抽象层允许在元数据级别工作,然后自动推送到相应的向量存储
- **44:30** - 无需关心底层存储的具体实现细节

### 观众问答 - 嵌套元数据 (44:30 - 47:00)
- **44:30** - 观众提问:系统如何处理嵌套元数据?例如书籍有多个作者,作者名字有日文和英文版本
- **45:15** - 回答:Unicode字符支持取决于嵌入模型,而非元数据结构
- **45:45** - 当前演示中元数据用于租户ID和用户ID过滤,不涉及内容本身
- **46:00** - 观众追问:元数据模式中是否支持列表或对象类型?
- **46:30** - 回答:需要进一步研究,不确定是否支持数组字段
- **46:50** - 建议:可以使用author1、author2、author3等有限字段作为替代方案

### 查询代码演示 - 过滤表达式 (47:00 - 51:00)
- **47:00** - 进入查询代码部分
- **47:30** - 展示设置过滤表达式(Filter Expression)的代码
- **48:00** - 从JWT令牌中提取租户ID和用户ID
- **48:30** - 过滤表达式:设置租户和用户ID过滤条件
- **49:00** - 还可以传入文件ID列表,即使文件已索引,也可以选择只查询特定文件
- **49:30** - 使用场景:Wiki过期但TTL未到期时,可以手动排除某些文件
- **50:00** - 演示中传入所有已索引文件ID,确保只查询用户自己的文件
- **50:30** - 多层过滤:不留任何机会给数据泄露
- **50:45** - 即使有人在提示词中注入"发送租户2的所有数据",也无法绕过过滤

### 查询代码演示 - 检索参数 (51:00 - 52:30)
- **51:00** - 设置检索参数(Retrieval Parameters)
- **51:30** - 配置查询文本和嵌入模型
- **52:00** - 传入之前创建的过滤表达式
- **52:15** - 控制返回结果数量
- **52:30** - 准备调用retrieve_and_generate方法

### 会话结束标记 (52:30+)
- **52:30** - 代码演示继续,讲师在查找知识库查询文件时会话字幕结束

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━


注:本总结基于提供的字幕文本,由于字幕在52:30左右中断,完整会话可能还包含更多关于查询执行、结果处理和问答环节的内容。