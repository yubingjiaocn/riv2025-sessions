# AWS re:Invent 2025 分会场总结：Scopely 使用 DynamoDB 和 ElastiCache 扩展 Monopoly Go

## 会议概述

本次技术分享由 AWS 产品管理总监 Joseph Exoric 和 Scopely 的 Brandon 共同呈现,重点介绍了移动游戏 Monopoly Go 如何利用 AWS 的 DynamoDB 和 ElastiCache Serverless (Valkey) 实现大规模扩展。Monopoly Go 在发布两年内成为现象级游戏,规模超出预期 10 倍,在流量高峰期拥有超过 100 万并发用户。Scopely 作为 DynamoDB 的早期采用者(自 2016 年起),在游戏行业这一最具挑战性的工作负载场景中,展示了如何应对从 10 万到数百万用户的快速增长。

Brandon 分享了 Scopely 在三个关键领域的实践经验:大规模可靠性、成本管理和运维简化。团队采用了经典的单体架构,使用 Unity 和 C# 构建客户端和服务器,并遵循简单的数据库选择原则:随用户数量扩展的数据存储在 DynamoDB 中,随员工数量扩展的配置数据存储在 MySQL 中,特殊用例(如排行榜和临时作业状态)使用 Redis/Valkey。这种架构设计使团队能够专注于游戏开发,而非数据库维护。

## 详细时间线与关键要点

### 开场介绍 (00:00 - 02:30)
- **00:00** - Joseph Exoric 介绍自己是 AWS 产品管理总监,负责 DynamoDB 和 ElastiCache 等数据库服务
- **00:45** - 介绍 Scopely 的 Brandon,强调其自 2016 年起就是 DynamoDB 的早期采用者和倡导者
- **01:30** - 说明游戏工作负载的特殊挑战:用户数可能在极短时间内从 10 万增长到数百万
- **02:15** - Brandon 开始介绍 Monopoly Go:发布两年,规模超预期 10 倍,高峰期超过 100 万并发用户

### 架构概述 (02:30 - 04:45)
- **02:45** - 展示基础架构:采用传统单体架构,Unity 客户端和 .NET 服务器均使用 C#
- **03:30** - 数据库选择策略:
  - 随用户数扩展的数据 → DynamoDB
  - 随员工数扩展的配置数据 → MySQL
  - 特殊用例(排行榜、临时状态)→ Redis/Valkey
- **04:15** - 介绍演讲三大主题:大规模可靠性、成本管理、运维简化

### 为什么选择 DynamoDB (04:45 - 08:30)
- **05:00** - MySQL 的局限性:
  - Aurora MySQL 只有单个写入节点,存在吞吐量瓶颈
  - 连接数限制问题:2000+ 服务器实例,每个需要 10+ 连接,容易达到上限
- **06:15** - MySQL 的其他问题:
  - 即使使用代理和读副本扩展,仍有扩展上限
  - 未加限制的查询(如 SELECT  无 LIMIT)可能导致数据库瘫痪
- *07:00** - DynamoDB 的优势:
  - 几乎不可能意外造成性能问题
  - 无需集群升级,避免停机和风险
- **07:45** - 强调 MySQL 主版本升级通常需要停机,而 DynamoDB 完全避免了这个问题

### 应对突发负载 (08:30 - 12:00)
- **08:45** - 解释游戏机制:玩家掷骰子移动棋子收集奖励,通过限时小游戏(mini-games)增加趣味性
- **09:30** - 突发负载场景:小游戏开始时(如周六上午 9 点),流量在 5 分钟内增长 3 倍
- **10:15** - 极端情况:某些 DynamoDB 表从零负载瞬间增长到每秒 10 万读/写单位
- **10:45** - 应对策略:
  - DynamoDB 表使用按需模式,事件前调用预热 API
  - ElastiCache Serverless 设置最低 eCPU 阈值
  - EC2 自动扩展组设置最低实例数
  - 负载均衡器设置容量预留
- **11:30** - 最终构建自动化系统处理所有预热和扩展活动

### DynamoDB 策略详解 (12:00 - 14:30)
- **12:15** - 新功能表创建流程:
  - 以按需模式启动
  - 调用预热 API 确保有足够分区和底层容量
  - 观察 2-4 周流量模式
- **13:00** - 如果流量稳定,切换到预置模式以节省成本;如果流量波动大,保持按需模式
- **13:30** - 可以每天在预置和按需模式间切换最多 4 次,以应对突发负载
- **14:00** - 节流缓解措施:
  - 服务器端 DynamoDB 客户端重试几次
  - 快速失败但向客户端提示可重试
  - 客户端再次重试,用户可能感觉延迟但不会崩溃或报错

### 成本优化 (14:30 - 18:45)
- **14:45** - 关键发现:DynamoDB 读写成本与文档大小成正比
- **15:15** - 100KB 文档的单次小修改需要消耗 100 个写入单位
- **15:45** - 最大成本节省来自减小文档大小,而非减少 API 调用
- **16:15** - 自建监控工具:
  - DynamoDB 不提供文档大小指标
  - 在客户端插桩记录每次读写的文档大小
  - 设置告警监控平均值、P95 和最大值
  - 注意 400KB 硬限制
- **17:00** - 案例:好友邀请表优化
  - 旧设计:每个用户一个文档,邀请存储在 JSON 数组中,某些用户收到数千邀请导致文档巨大
  - 新设计:每个邀请一个文档,使用查询获取多个项目,添加本地二级索引按日期排序
- **18:00** - 优化结果:
  - 写入成本从 1-200 单位降至固定 2 单位
  - 读取成本从 1-50 单位降至 1-2 单位
  - 额外节省来自只查询首页(最近邀请)

### 运维简化:迁移到 ElastiCache Serverless (18:45 - 23:00)
- **19:00** - Scopely 的理念:专注游戏开发,不想花时间做数据库维护和手动扩展
- **19:30** - 旧 Redis 集群的问题:
  - 非 AWS 托管,难以无中断扩展
  - 达到一定规模后添加分片会导致超时、连接断开等用户影响
  - 团队害怕触碰集群
- **20:15** - 内存告警问题:
  - 达到 80% 容量时必须添加节点
  - 周六被叫醒处理内存告警
  - 扩容导致用户体验下降
- **21:00** - 选择 ElastiCache Serverless 的原因:
  - 后台自动扩展
  - 透明地增长和收缩
  - 虽然名字有"Cache",但完全适用于非缓存工作负载
  - 持久性保证不如 DynamoDB/MySQL,但与旧 Redis 相当,满足需求
- **21:45** - 选择 Valkey 而非 Redis:开源且便宜 20%
- **22:15** - 迁移结果:
  - 实现自动扩展,不再周六被叫醒
  - 意外获得 61% 成本节省(原本只为节省时间)
  - 成本节省源于旧集群因害怕扩展而持续过度配置
- **22:45** - 早期采用者的挑战:遇到几次 1-3 分钟的小故障,与 AWS 合作解决,数月未再出现

### 总结 (23:00 - 23:30)
- **23:00** - Brandon 总结:团队现在处于更好的状态,不再浪费时间调整数据库
- **23:15** - 演讲结束,观众鼓掌

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━


核心收获:
- 游戏工作负载需要应对极端的流量波动,DynamoDB 按需模式 + 预热 API 是理想解决方案
- 成本优化的关键在于文档大小而非 API 调用次数
- ElastiCache Serverless 显著减少运维负担,同时带来意外的成本节省
- 自动化和托管服务让团队专注于核心业务而非基础设施维护