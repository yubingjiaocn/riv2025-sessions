1
00:00:00,207 --> 00:00:01,500
- All right. Hey everyone.

2
00:00:01,500 --> 00:00:02,880
Welcome to this session.

3
00:00:02,880 --> 00:00:05,250
We're gonna be talking today
about security best practices

4
00:00:05,250 --> 00:00:07,230
for our serverless applications.

5
00:00:07,230 --> 00:00:09,330
Just as a quick introduction,
my name is Heeki Park.

6
00:00:09,330 --> 00:00:11,250
I am a Solutions Architect here at AWS.

7
00:00:11,250 --> 00:00:13,440
I've been here about nine plus years.

8
00:00:13,440 --> 00:00:16,620
I spent a lot of my time here
at AWS focusing on serverless,

9
00:00:16,620 --> 00:00:18,330
and more lately spending a lot of time

10
00:00:18,330 --> 00:00:19,833
with agentic applications.

11
00:00:20,820 --> 00:00:23,310
- Thanks Heeki. My name's Chris McPeak.

12
00:00:23,310 --> 00:00:25,590
I'm also a Solutions
Architect here at AWS.

13
00:00:25,590 --> 00:00:28,170
Been here about seven and a half years,

14
00:00:28,170 --> 00:00:30,870
really focused on serverless
application development

15
00:00:30,870 --> 00:00:33,870
and working a lot with
our serverless teams.

16
00:00:33,870 --> 00:00:35,700
So we're gonna be diving
into this topic today

17
00:00:35,700 --> 00:00:39,090
around security best
practices for serverless apps.

18
00:00:39,090 --> 00:00:41,700
Now, if you've never been
in a silent session before,

19
00:00:41,700 --> 00:00:43,620
these can get a little bit weird, right?

20
00:00:43,620 --> 00:00:46,630
It's hard for you to hear
me through headphones

21
00:00:47,820 --> 00:00:49,380
versus over a speaker.

22
00:00:49,380 --> 00:00:52,080
We like to get feedback, so head nods

23
00:00:52,080 --> 00:00:55,530
and you know, thumbs up
if something's resonating.

24
00:00:55,530 --> 00:00:56,400
Definitely appreciate.

25
00:00:56,400 --> 00:00:58,740
But I wanna do something a
little bit different this morning

26
00:00:58,740 --> 00:01:00,450
or this afternoon.

27
00:01:00,450 --> 00:01:01,350
On the count of three,

28
00:01:01,350 --> 00:01:04,110
I would love everybody just to cheer.

29
00:01:04,110 --> 00:01:04,943
That helps me.

30
00:01:04,943 --> 00:01:06,600
That also tells everybody
else you all chose

31
00:01:06,600 --> 00:01:08,670
the right session, okay. Ready?

32
00:01:08,670 --> 00:01:10,110
So we're gonna do this together. Ready?

33
00:01:10,110 --> 00:01:12,330
One, two, three.

34
00:01:12,330 --> 00:01:15,240
(participants cheering)
Thank you. Awesome.

35
00:01:15,240 --> 00:01:19,350
Okay, so as we dive into this,

36
00:01:19,350 --> 00:01:23,640
I'm gonna start off and go
into a little bit of a survey

37
00:01:23,640 --> 00:01:27,450
of some different security practices

38
00:01:27,450 --> 00:01:30,540
for serverless applications,
some foundation items

39
00:01:30,540 --> 00:01:32,940
that we need to really kind of
talk through to get started.

40
00:01:32,940 --> 00:01:34,620
And then I'm gonna have
Heeki come back up,

41
00:01:34,620 --> 00:01:38,190
and he's gonna dive deeper
into some specific use cases,

42
00:01:38,190 --> 00:01:41,460
especially around some of
the more modern application

43
00:01:41,460 --> 00:01:44,400
development that we've been working on,

44
00:01:44,400 --> 00:01:45,900
especially with agentic AI,

45
00:01:45,900 --> 00:01:48,240
and some of the identity awareness

46
00:01:48,240 --> 00:01:52,050
that we need to think about
with serverless security.

47
00:01:52,050 --> 00:01:54,317
Now to help us out, what we're gonna do

48
00:01:54,317 --> 00:01:58,920
is kind of frame this in the
idea of a fitness tracker

49
00:01:58,920 --> 00:02:00,540
'cause I think sometimes
it's a little bit hard

50
00:02:00,540 --> 00:02:03,060
to get our head around security

51
00:02:03,060 --> 00:02:05,910
without having an actual
application to talk through,

52
00:02:05,910 --> 00:02:07,860
or an architecture to talk through.

53
00:02:07,860 --> 00:02:10,980
So we're gonna use this idea
of having a fitness tracker.

54
00:02:10,980 --> 00:02:13,140
And the basic architecture
that we're gonna work with

55
00:02:13,140 --> 00:02:17,700
is we're gonna have our athlete.

56
00:02:17,700 --> 00:02:18,870
I love cycling.

57
00:02:18,870 --> 00:02:21,330
I've done a lot of cycling in the past,

58
00:02:21,330 --> 00:02:22,440
as you can tell though,

59
00:02:22,440 --> 00:02:24,180
I haven't been cycling a lot recently.

60
00:02:24,180 --> 00:02:26,463
So instead we're gonna use Heeki.

61
00:02:27,358 --> 00:02:30,540
Heeki is training for
a marathon right now.

62
00:02:30,540 --> 00:02:32,610
Actually ran a marathon last week,

63
00:02:32,610 --> 00:02:35,940
and loves using fitness trackers,

64
00:02:35,940 --> 00:02:38,670
and collecting all of
his data and figuring out

65
00:02:38,670 --> 00:02:41,190
how he's doing with running.

66
00:02:41,190 --> 00:02:43,290
So we're gonna have
this basic architecture.

67
00:02:43,290 --> 00:02:48,290
So an API that's gonna collect
that data from our tracker,

68
00:02:48,300 --> 00:02:50,970
that's gonna feed into an API gateway.

69
00:02:50,970 --> 00:02:53,820
From that API gateway will
trigger a lambda function.

70
00:02:53,820 --> 00:02:55,140
That's just gonna take that data

71
00:02:55,140 --> 00:02:57,720
and write it to a DynamoDB table.

72
00:02:57,720 --> 00:03:00,240
So as we go through and
talk about security,

73
00:03:00,240 --> 00:03:02,640
we'll be talking about
some of the security

74
00:03:02,640 --> 00:03:05,100
that you need to consider on
each of the different layers

75
00:03:05,100 --> 00:03:06,243
of this application.

76
00:03:07,200 --> 00:03:10,620
Okay, so the first thing that
we need to talk about actually

77
00:03:10,620 --> 00:03:12,840
is account boundaries.

78
00:03:12,840 --> 00:03:16,740
Now, I realize this isn't
necessarily a serverless concept,

79
00:03:16,740 --> 00:03:19,140
but it is something important to consider

80
00:03:19,140 --> 00:03:21,393
as we're developing applications.

81
00:03:22,590 --> 00:03:26,370
How many of you in the audience
are developers? Awesome.

82
00:03:26,370 --> 00:03:30,660
How many are security engineers
or focused on compliance?

83
00:03:30,660 --> 00:03:35,370
Great. So as developers,
we love to move fast.

84
00:03:35,370 --> 00:03:37,410
We love to build very quickly.

85
00:03:37,410 --> 00:03:42,390
Oftentimes we'll have access
to a sandbox environment

86
00:03:42,390 --> 00:03:47,220
where we can develop quickly,
run our tests and move fast.

87
00:03:47,220 --> 00:03:51,330
But this can pose some risks
to a production environment

88
00:03:51,330 --> 00:03:53,940
when we're deploying
directly into that account.

89
00:03:53,940 --> 00:03:56,790
So by creating these account boundaries,

90
00:03:56,790 --> 00:03:59,340
that actually allows us
then to separate those areas

91
00:03:59,340 --> 00:04:02,760
of control so that you as
a developer can move fast,

92
00:04:02,760 --> 00:04:05,550
and test and develop.

93
00:04:05,550 --> 00:04:08,340
And then as you're
deploying out to production,

94
00:04:08,340 --> 00:04:12,180
then you can have a
structured deployment pipeline

95
00:04:12,180 --> 00:04:15,210
where as a developer,
you can commit your code

96
00:04:15,210 --> 00:04:16,710
and it will run those automated tests

97
00:04:16,710 --> 00:04:19,590
and deploy that out to production for you.

98
00:04:19,590 --> 00:04:21,900
So that's a really important
sort of distinction

99
00:04:21,900 --> 00:04:25,020
between accounts that just helps provide

100
00:04:25,020 --> 00:04:26,973
a good separation of concerns.

101
00:04:27,990 --> 00:04:30,660
Encryption, we all love
to talk about encryption

102
00:04:30,660 --> 00:04:34,290
and it's very important
for us to consider.

103
00:04:34,290 --> 00:04:36,660
With AWS serverless services,

104
00:04:36,660 --> 00:04:40,140
a lot of security is
already built in for you,

105
00:04:40,140 --> 00:04:41,970
but there are some things to consider

106
00:04:41,970 --> 00:04:43,950
as you're using some of
the different services.

107
00:04:43,950 --> 00:04:48,300
So for example, if you're
using Lambda functions,

108
00:04:48,300 --> 00:04:50,040
one thing that you'll want to think about

109
00:04:50,040 --> 00:04:52,080
is your environment variables

110
00:04:52,080 --> 00:04:54,900
and whether or not you're storing data

111
00:04:54,900 --> 00:04:57,990
in environment variables
that needs to be encrypted.

112
00:04:57,990 --> 00:05:00,120
And you can use a KMS key

113
00:05:00,120 --> 00:05:02,220
to actually encrypt those
environment variables

114
00:05:02,220 --> 00:05:03,303
and keep them safe.

115
00:05:04,410 --> 00:05:07,260
If you're using API gateway
and using a caching feature

116
00:05:07,260 --> 00:05:10,200
with API gateway, again,
you wanna make sure

117
00:05:10,200 --> 00:05:13,170
that, that cache is actually encrypted.

118
00:05:13,170 --> 00:05:16,530
And API gateway gives you
the ability to turn that on.

119
00:05:16,530 --> 00:05:19,350
So for each of the different
serverless services,

120
00:05:19,350 --> 00:05:20,370
those are available.

121
00:05:20,370 --> 00:05:24,753
Some have the option to
use just an AWS KMS key,

122
00:05:25,680 --> 00:05:29,040
and in some cases you can also
use a customer managed key

123
00:05:29,040 --> 00:05:31,050
to encrypt that as well.

124
00:05:31,050 --> 00:05:34,860
Now all of the serverless
services do have encryption

125
00:05:34,860 --> 00:05:37,650
in transit by default.

126
00:05:37,650 --> 00:05:39,660
So we manage that for you.

127
00:05:39,660 --> 00:05:44,430
API gateway only accepts HTPS requests,

128
00:05:44,430 --> 00:05:48,930
so you can't even accidentally
create an HTTP endpoint

129
00:05:48,930 --> 00:05:51,183
that doesn't run
encryption on API gateway.

130
00:05:52,830 --> 00:05:57,830
Okay, the next area that we
need to think through is IAM,

131
00:05:57,960 --> 00:06:01,950
so identity and access
management, very important.

132
00:06:01,950 --> 00:06:04,560
As you're building
serverless applications,

133
00:06:04,560 --> 00:06:09,043
that control plane where
you're making API calls to AWS

134
00:06:09,930 --> 00:06:11,790
to make changes to Lambda functions

135
00:06:11,790 --> 00:06:14,310
or access different services

136
00:06:14,310 --> 00:06:18,270
is one plane to think about
making sure it is secure.

137
00:06:18,270 --> 00:06:21,000
And the other is the data plane.

138
00:06:21,000 --> 00:06:22,590
So this is where your application

139
00:06:22,590 --> 00:06:25,740
is calling different services,

140
00:06:25,740 --> 00:06:28,257
and your application is running.

141
00:06:28,257 --> 00:06:30,900
And so there are a couple
of different tools in IAM

142
00:06:30,900 --> 00:06:33,634
that we'll go through to consider

143
00:06:33,634 --> 00:06:36,900
as you're building out your applications.

144
00:06:36,900 --> 00:06:39,000
The first is at an organization level,

145
00:06:39,000 --> 00:06:42,540
and I'll dive into this a
little bit deeper in a moment.

146
00:06:42,540 --> 00:06:47,540
AWS organizations policies
or SEPs are gonna be scoped

147
00:06:48,660 --> 00:06:51,120
at an organization level
that can be applied

148
00:06:51,120 --> 00:06:56,120
across multiple accounts,
versus resource policies

149
00:06:56,280 --> 00:06:58,350
are going to be policies
that you're gonna apply

150
00:06:58,350 --> 00:07:00,750
to a specific service.

151
00:07:00,750 --> 00:07:04,560
And so that will control access
to that specific service.

152
00:07:04,560 --> 00:07:08,820
So as you start digging into IAM policies

153
00:07:08,820 --> 00:07:11,190
at different layers,
there are different areas

154
00:07:11,190 --> 00:07:12,573
that you can protect.

155
00:07:14,430 --> 00:07:16,590
So when we think about our architecture

156
00:07:16,590 --> 00:07:21,590
for our activity API, controlling
what APIs are being called

157
00:07:22,590 --> 00:07:26,940
and how API gateway is
invoking our Lambda function,

158
00:07:26,940 --> 00:07:28,410
we'll wanna make sure that we bound

159
00:07:28,410 --> 00:07:31,743
those permissions very closely.

160
00:07:35,040 --> 00:07:38,940
Okay, so with Lambda
functions specifically,

161
00:07:38,940 --> 00:07:41,970
I wanna talk a little bit
about resource based policies

162
00:07:41,970 --> 00:07:45,180
versus the execution role of that service.

163
00:07:45,180 --> 00:07:46,350
So this is a little bit different

164
00:07:46,350 --> 00:07:48,390
than how you might consider security

165
00:07:48,390 --> 00:07:52,830
for maybe an application
running on an EC2 instance.

166
00:07:52,830 --> 00:07:55,800
So with Lambda functions, you
have two different policies

167
00:07:55,800 --> 00:07:57,240
that you're gonna work with.

168
00:07:57,240 --> 00:08:00,820
That resource-based policy
is what gets applied

169
00:08:01,770 --> 00:08:03,720
for any service that's triggering,

170
00:08:03,720 --> 00:08:05,673
or invoking your Lambda function.

171
00:08:06,900 --> 00:08:08,250
There's a couple of other services

172
00:08:08,250 --> 00:08:11,610
that also follow this
pattern such as EventBridge,

173
00:08:11,610 --> 00:08:13,830
and so you'll wanna make
sure that you think through

174
00:08:13,830 --> 00:08:16,110
that resource-based policy

175
00:08:16,110 --> 00:08:19,290
for what services can
invoke that Lambda function.

176
00:08:19,290 --> 00:08:22,050
Now, the execution role
is on the other side

177
00:08:22,050 --> 00:08:23,010
of the Lambda function.

178
00:08:23,010 --> 00:08:26,040
That's the policy that's controlling

179
00:08:26,040 --> 00:08:29,520
what that Lambda function has
access to as it's executing.

180
00:08:29,520 --> 00:08:31,713
So maybe it's a DynamoDB table,

181
00:08:32,760 --> 00:08:35,730
as we mentioned before
in our architecture.

182
00:08:35,730 --> 00:08:40,680
So that gives you a
different policy to control

183
00:08:40,680 --> 00:08:42,633
what that Lambda function is accessing.

184
00:08:43,560 --> 00:08:45,840
So for example, based on our application

185
00:08:45,840 --> 00:08:48,600
that we're working with,
maybe that API gateway,

186
00:08:48,600 --> 00:08:50,910
we wanna give it access to
invoke our Lambda function

187
00:08:50,910 --> 00:08:54,210
as those activities are coming
in and need to be processed.

188
00:08:54,210 --> 00:08:57,180
So we'll create a resource-based
policy to do that,

189
00:08:57,180 --> 00:08:59,550
but we'll also give it that execution role

190
00:08:59,550 --> 00:09:01,800
so the Lambda function
can write those activities

191
00:09:01,800 --> 00:09:03,123
out to DynamoDB.

192
00:09:06,030 --> 00:09:08,280
Okay, another concept
that's really important

193
00:09:09,180 --> 00:09:12,060
that maybe as developers
we don't always think about

194
00:09:12,060 --> 00:09:16,290
but is a really foundational ideas

195
00:09:16,290 --> 00:09:18,750
is around least privileges.

196
00:09:18,750 --> 00:09:19,860
Now, I don't know about you all,

197
00:09:19,860 --> 00:09:22,440
but this was a little bit hard
for me to get my head around

198
00:09:22,440 --> 00:09:25,290
as a developer because
I like to move fast,

199
00:09:25,290 --> 00:09:28,050
I like to try things and
sometimes it's just easy

200
00:09:28,050 --> 00:09:30,780
to scope something very wide open.

201
00:09:30,780 --> 00:09:33,420
But for those that are
security folks in the room,

202
00:09:33,420 --> 00:09:35,430
I can already see the cringing, right.

203
00:09:35,430 --> 00:09:37,890
With having wide open policies.

204
00:09:37,890 --> 00:09:40,830
So least privilege is very important

205
00:09:40,830 --> 00:09:44,280
as you're developing in the
cloud, you wanna make sure

206
00:09:44,280 --> 00:09:48,720
that you're scoping those
policies down to only the actions

207
00:09:48,720 --> 00:09:51,750
that, that service is allowed to take.

208
00:09:51,750 --> 00:09:53,640
So if you think about
your resource policies

209
00:09:53,640 --> 00:09:55,890
or your execution policies,

210
00:09:55,890 --> 00:09:59,010
you want to not give it a wild card star,

211
00:09:59,010 --> 00:10:02,610
but instead give it only the API actions

212
00:10:02,610 --> 00:10:04,680
that it's allowed to take.

213
00:10:04,680 --> 00:10:05,640
Now we can think about this

214
00:10:05,640 --> 00:10:07,020
in a little bit of an iterative way

215
00:10:07,020 --> 00:10:08,790
as we're developing as well,

216
00:10:08,790 --> 00:10:11,460
where we're setting
permissions, running tests,

217
00:10:11,460 --> 00:10:15,660
verifying actions, and we can
all do this in our pipelines

218
00:10:15,660 --> 00:10:19,420
as well to verify that we
have permissions set well

219
00:10:20,520 --> 00:10:22,923
to meet the compliance
for our organization.

220
00:10:25,380 --> 00:10:29,313
Now, the other side of
that is, as a developer,

221
00:10:30,390 --> 00:10:33,750
you know, I might wanna set the policies

222
00:10:33,750 --> 00:10:36,600
for my services wide open, right?

223
00:10:36,600 --> 00:10:38,670
We already talked about
least privilege there.

224
00:10:38,670 --> 00:10:42,060
Least privilege also matters
for me as a developer.

225
00:10:42,060 --> 00:10:44,190
So making sure that I don't have access

226
00:10:44,190 --> 00:10:46,920
to things I shouldn't
or I can't take actions

227
00:10:46,920 --> 00:10:50,490
that might cause problems down the road,

228
00:10:50,490 --> 00:10:52,680
or open up issues down the road.

229
00:10:52,680 --> 00:10:55,200
And so one way that you can handle this

230
00:10:55,200 --> 00:10:57,990
is by actually empowering your developers

231
00:10:57,990 --> 00:11:00,390
to create the policies they need,

232
00:11:00,390 --> 00:11:05,130
but also use permission boundaries
applied to that developer

233
00:11:05,130 --> 00:11:09,000
that actually limits the scope
of what they can open up.

234
00:11:09,000 --> 00:11:13,230
And so you can actually set
specific actions to deny,

235
00:11:13,230 --> 00:11:16,530
or allow on those permission boundaries.

236
00:11:16,530 --> 00:11:20,880
Sorry, no allow, just deny
so that you're limiting

237
00:11:20,880 --> 00:11:25,110
what a developer actually
can do in their account.

238
00:11:25,110 --> 00:11:27,000
Now this is gonna be
a little bit different

239
00:11:27,000 --> 00:11:31,320
than the SEP roles, SEP policies
that I mentioned before,

240
00:11:31,320 --> 00:11:34,440
where SEPs are organizational wide,

241
00:11:34,440 --> 00:11:37,290
a permission boundary
is gonna be just scoped

242
00:11:37,290 --> 00:11:39,600
for that role specifically.

243
00:11:39,600 --> 00:11:41,880
So let's take a little
bit of an example here.

244
00:11:41,880 --> 00:11:46,500
So for our activities, API
that I talked about before,

245
00:11:46,500 --> 00:11:50,790
maybe I want, you know, full
access to all the Lambda APIs,

246
00:11:50,790 --> 00:11:54,900
full access to Dynamo and API gateway,

247
00:11:54,900 --> 00:11:57,690
I set a policy for any get actions,

248
00:11:57,690 --> 00:11:59,523
so I can see what my API gateway is,

249
00:12:00,510 --> 00:12:02,880
but my security team
really doesn't like that.

250
00:12:02,880 --> 00:12:05,820
They want me to scope that
down a little bit further.

251
00:12:05,820 --> 00:12:10,140
They can actually put in a
permission boundary in place

252
00:12:10,140 --> 00:12:13,740
that only gives me access
to Lambda Invoke function

253
00:12:13,740 --> 00:12:17,973
and DynamoDB UpdateItem,
and apigateway Get method.

254
00:12:18,810 --> 00:12:20,370
So you can see effectively

255
00:12:20,370 --> 00:12:24,540
when I bring these two
permission boundaries

256
00:12:24,540 --> 00:12:28,230
and the policy that I
put in place together,

257
00:12:28,230 --> 00:12:30,510
the actual effective permissions

258
00:12:30,510 --> 00:12:34,500
is just Lambda Invoke Function
and DynamoDB update table.

259
00:12:34,500 --> 00:12:38,180
So even though I've given myself
some wild card permissions

260
00:12:40,890 --> 00:12:45,570
to move fast, using that
permission boundary actually scoops

261
00:12:45,570 --> 00:12:48,513
what I have access to down very tightly.

262
00:12:50,670 --> 00:12:53,010
Okay, so let's go back to SCP again,

263
00:12:53,010 --> 00:12:55,473
and talk about this a little bit more.

264
00:12:57,090 --> 00:13:00,600
Usually when you get to an
enterprise level organization

265
00:13:00,600 --> 00:13:05,130
that's doing a lot of serverless
application development,

266
00:13:05,130 --> 00:13:08,760
a lot of times we don't want
to have to apply specific

267
00:13:08,760 --> 00:13:11,400
controls at every single role.

268
00:13:11,400 --> 00:13:13,470
Maybe there are some
policies for compliance

269
00:13:13,470 --> 00:13:17,700
that we wanna apply
across our organization,

270
00:13:17,700 --> 00:13:20,850
across all of the accounts
that we actually have.

271
00:13:20,850 --> 00:13:25,740
And so using SCPs, you can
actually apply these policies

272
00:13:25,740 --> 00:13:28,440
across the entire organization.

273
00:13:28,440 --> 00:13:31,290
So this just limits the scope

274
00:13:31,290 --> 00:13:33,783
that any of those policies
might have access to.

275
00:13:34,890 --> 00:13:37,170
Now to help, let's talk
through maybe an example

276
00:13:37,170 --> 00:13:39,630
of something that could be helpful.

277
00:13:39,630 --> 00:13:44,100
In our case, we have that API
gateway sitting out front.

278
00:13:44,100 --> 00:13:47,790
And maybe what we wanna do
is we wanna limit access

279
00:13:47,790 --> 00:13:51,450
to that API gateway from the public side.

280
00:13:51,450 --> 00:13:54,330
We don't wanna create
a public API endpoint.

281
00:13:54,330 --> 00:13:55,200
So what we can do

282
00:13:55,200 --> 00:14:00,150
is we can actually just allow
private endpoints using SCP.

283
00:14:00,150 --> 00:14:03,600
So as any of our developers
create an API gateway,

284
00:14:03,600 --> 00:14:06,090
they can only create it
as a private endpoint,

285
00:14:06,090 --> 00:14:07,293
not a public endpoint.

286
00:14:08,430 --> 00:14:10,620
Now, maybe to make this
a little bit more real,

287
00:14:10,620 --> 00:14:12,840
let's talk a little bit
about a different scenario.

288
00:14:12,840 --> 00:14:16,710
So in this case, we want
any of the traffic coming

289
00:14:16,710 --> 00:14:21,570
from those trackers to actually
flow through a different VPC

290
00:14:21,570 --> 00:14:23,220
because in this case maybe we wanna run

291
00:14:23,220 --> 00:14:26,670
some security validation,

292
00:14:26,670 --> 00:14:29,790
or we want to route
traffic a certain direction

293
00:14:29,790 --> 00:14:32,640
within our AWS network.

294
00:14:32,640 --> 00:14:36,870
And so what we can do is lock
down that public API access,

295
00:14:36,870 --> 00:14:40,770
so that we can then just
create a private API endpoint

296
00:14:40,770 --> 00:14:43,653
and stick it in its own VPC.

297
00:14:44,550 --> 00:14:45,900
Then as traffic is coming in,

298
00:14:45,900 --> 00:14:48,780
it's gonna flow through that broader VPC,

299
00:14:48,780 --> 00:14:51,660
maybe we do some, again,
some security analysis

300
00:14:51,660 --> 00:14:53,460
on that traffic.

301
00:14:53,460 --> 00:14:58,080
We'll create ENIs in
that account, in that VPC

302
00:14:58,080 --> 00:15:02,100
that then allow traffic to
flow into our API gateway VPC

303
00:15:02,100 --> 00:15:03,450
on the back end.

304
00:15:03,450 --> 00:15:06,420
So that just provides a
little bit more security

305
00:15:06,420 --> 00:15:10,020
for our API endpoints if we have a need

306
00:15:10,020 --> 00:15:12,813
to actually flow traffic through VPCs.

307
00:15:14,730 --> 00:15:18,090
Okay, last sort of
foundational area to remember,

308
00:15:18,090 --> 00:15:21,990
think about API integrations.

309
00:15:21,990 --> 00:15:25,350
So I'm not gonna talk too
much about API Integrations

310
00:15:25,350 --> 00:15:27,090
because Heeki's gonna
talk through some of that

311
00:15:27,090 --> 00:15:28,620
in a few minutes.

312
00:15:28,620 --> 00:15:32,670
But databases is also an important area.

313
00:15:32,670 --> 00:15:35,583
Now in our case, DynamoDB table,

314
00:15:36,510 --> 00:15:39,890
and DynamoDB supports
IAM so I can give access

315
00:15:39,890 --> 00:15:44,130
to that Lambda function
using an IAM policy

316
00:15:44,130 --> 00:15:47,760
to access that DynamoDB table.

317
00:15:47,760 --> 00:15:52,170
But what if my database doesn't
necessarily support IAM?

318
00:15:52,170 --> 00:15:54,120
Maybe it's a database

319
00:15:54,120 --> 00:15:56,470
that I'm just running
maybe on an EC2 instance.

320
00:15:57,600 --> 00:15:58,860
So in that case,

321
00:15:58,860 --> 00:16:02,280
you might think about using
something like Managed Secrets,

322
00:16:02,280 --> 00:16:04,440
but the last thing you want
to do is take those secrets

323
00:16:04,440 --> 00:16:06,840
and actually apply them in...

324
00:16:06,840 --> 00:16:09,030
Hard code them in your code, right?

325
00:16:09,030 --> 00:16:11,790
So that's where Secrets
Manager is a good place

326
00:16:11,790 --> 00:16:15,930
to store those and have your
Lambda function actually access

327
00:16:15,930 --> 00:16:19,203
that Secrets manager to be
able to access your database.

328
00:16:21,900 --> 00:16:24,600
Okay, a couple of other
areas just to think about

329
00:16:24,600 --> 00:16:26,880
as an organization,

330
00:16:26,880 --> 00:16:29,070
if we think about the
development lifecycle

331
00:16:29,070 --> 00:16:30,900
and all the different stages that we have

332
00:16:30,900 --> 00:16:33,390
in the development lifecycle,

333
00:16:33,390 --> 00:16:36,960
there's a number of
different security things

334
00:16:36,960 --> 00:16:41,960
to just keep in mind, whether
it's how you're authoring

335
00:16:42,120 --> 00:16:45,990
your applications and where
you're storing that code,

336
00:16:45,990 --> 00:16:49,710
making sure you have least
privileged permissions there,

337
00:16:49,710 --> 00:16:52,290
or even pushing code into repositories

338
00:16:52,290 --> 00:16:54,090
to trigger your pipelines.

339
00:16:54,090 --> 00:16:56,880
Making sure you have IAM scoped down,

340
00:16:56,880 --> 00:17:01,880
so that your pipelines
are only deploying code

341
00:17:01,890 --> 00:17:03,003
from the right people.

342
00:17:05,460 --> 00:17:08,100
Another area that's really
important to think about

343
00:17:08,100 --> 00:17:10,680
is just analyzing that source code,

344
00:17:10,680 --> 00:17:14,790
looking for maybe
dependencies that have come in

345
00:17:14,790 --> 00:17:19,050
that were applied that
maybe have issues in them.

346
00:17:19,050 --> 00:17:22,320
Amazon Inspector is a good way to do that,

347
00:17:22,320 --> 00:17:25,440
to have Amazon Inspector look at your code

348
00:17:25,440 --> 00:17:29,850
and provide any of those dependency issues

349
00:17:29,850 --> 00:17:31,980
that maybe have crept in.

350
00:17:31,980 --> 00:17:34,920
But I will say if (indistinct)
Matt Garmin's keynote

351
00:17:34,920 --> 00:17:39,063
this morning, he actually
(indistinct) agent,

352
00:17:41,940 --> 00:17:45,960
we didn't know that,
that was available then.

353
00:17:45,960 --> 00:17:48,686
Did everybody (indistinct) still?

354
00:17:48,686 --> 00:17:49,945
- [Participant] Mic is
cutting out sometimes.

355
00:17:49,945 --> 00:17:51,630
- My mic is cutting out sometimes.

356
00:17:51,630 --> 00:17:54,303
Okay, we'll have our
folks in the background.

357
00:17:56,190 --> 00:17:57,840
I'll keep talking and they'll check on it.

358
00:17:57,840 --> 00:18:02,190
Okay, so Matt Garmin this morning talked

359
00:18:02,190 --> 00:18:06,990
about a security agent
that we recently released.

360
00:18:06,990 --> 00:18:10,770
This is also a really
good tool to make use of

361
00:18:10,770 --> 00:18:12,303
to analyze your source code.

362
00:18:14,070 --> 00:18:18,900
Okay, so another type
of possible scenario is,

363
00:18:18,900 --> 00:18:22,050
let's say you weren't inspecting your code

364
00:18:22,050 --> 00:18:23,430
and you allowed a dependency

365
00:18:23,430 --> 00:18:26,640
to be applied in your application

366
00:18:26,640 --> 00:18:29,040
that got through some of your testing.

367
00:18:29,040 --> 00:18:32,670
So in this case, you might want to look

368
00:18:32,670 --> 00:18:36,000
for application anomalies to detect

369
00:18:36,000 --> 00:18:38,520
that maybe that dependency got through.

370
00:18:38,520 --> 00:18:41,140
And so at a runtime, Amazon GuardDuty

371
00:18:42,030 --> 00:18:45,150
can look at your VPC flow logs as a way

372
00:18:45,150 --> 00:18:48,750
to detect any anomalies
that are maybe happening

373
00:18:48,750 --> 00:18:51,750
in your application because
something was missed earlier on.

374
00:18:54,360 --> 00:18:57,570
Okay, event payloads.

375
00:18:57,570 --> 00:19:00,720
Another important area to consider

376
00:19:00,720 --> 00:19:03,270
as you're thinking about security.

377
00:19:03,270 --> 00:19:05,430
So with event payloads in Lambda,

378
00:19:05,430 --> 00:19:07,290
there's actually a really
good tool out there

379
00:19:07,290 --> 00:19:11,220
called Power Tools that
makes it really easy for you

380
00:19:11,220 --> 00:19:16,220
to add things like strict
typing to validate that input

381
00:19:17,460 --> 00:19:19,410
as it's coming through.

382
00:19:19,410 --> 00:19:22,890
So you can see here this
is just a brief example

383
00:19:22,890 --> 00:19:26,820
where we're importing that
Power Tools dependency

384
00:19:26,820 --> 00:19:28,350
and that's gonna actually help us

385
00:19:28,350 --> 00:19:31,800
to validate very easily in Lambda.

386
00:19:31,800 --> 00:19:33,990
There's some really good
power tools sessions going on

387
00:19:33,990 --> 00:19:36,420
this week that's...

388
00:19:36,420 --> 00:19:39,270
There's a team at AWS now
that's actually developing that

389
00:19:39,270 --> 00:19:41,490
and owns that for us.

390
00:19:41,490 --> 00:19:44,033
So I definitely encourage
you to take a look at that.

391
00:19:46,050 --> 00:19:48,930
But what if we could also
look at those payloads

392
00:19:48,930 --> 00:19:50,550
before they come to Lambda,

393
00:19:50,550 --> 00:19:54,190
and look for maybe differences in schema

394
00:19:55,050 --> 00:19:58,050
before a request actually comes in.

395
00:19:58,050 --> 00:20:02,280
And so within API gateway,
we can validate that input,

396
00:20:02,280 --> 00:20:04,230
do input validation,

397
00:20:04,230 --> 00:20:05,940
make sure we're getting what we expect

398
00:20:05,940 --> 00:20:09,210
to get from a schema
perspective before we pass it on

399
00:20:09,210 --> 00:20:11,283
to that Lambda function to actually run.

400
00:20:12,780 --> 00:20:15,240
So three available configurations.

401
00:20:15,240 --> 00:20:16,650
So you can look at the body,

402
00:20:16,650 --> 00:20:19,380
you can look at query string parameters,

403
00:20:19,380 --> 00:20:22,020
make sure they're what you expect,

404
00:20:22,020 --> 00:20:25,860
or you can look at all the
above to validate that event

405
00:20:25,860 --> 00:20:26,960
that's coming through.

406
00:20:28,140 --> 00:20:31,140
Okay, last couple sort
of foundational items,

407
00:20:31,140 --> 00:20:33,630
protecting your API endpoints.

408
00:20:33,630 --> 00:20:34,980
So before we talked a little bit

409
00:20:34,980 --> 00:20:39,510
about taking our endpoints
and making them private.

410
00:20:39,510 --> 00:20:43,830
Another tool that you
have access to is AWS WAF.

411
00:20:43,830 --> 00:20:47,250
This gives you the ability
to protect those endpoints

412
00:20:47,250 --> 00:20:51,990
based on IP addresses, based on, you know,

413
00:20:51,990 --> 00:20:56,520
geographic regions that you
might want to limit access

414
00:20:56,520 --> 00:20:57,843
to that API gateway.

415
00:20:59,114 --> 00:21:02,820
AWS WAF also has the
ability to take in rule sets

416
00:21:02,820 --> 00:21:04,890
from third parties.

417
00:21:04,890 --> 00:21:08,187
So this is a really
helpful way to, you know,

418
00:21:09,490 --> 00:21:11,910
have a subscription applied

419
00:21:11,910 --> 00:21:13,650
that will actually protect those endpoints

420
00:21:13,650 --> 00:21:15,933
based on what's being
seen out in the wild.

421
00:21:17,340 --> 00:21:19,440
If you go on the AWS marketplace,

422
00:21:19,440 --> 00:21:20,670
there's a number of providers

423
00:21:20,670 --> 00:21:24,660
that will provide that
subscription for you into AWS WAF.

424
00:21:24,660 --> 00:21:25,860
So those are some really good ways

425
00:21:25,860 --> 00:21:30,860
of protecting your endpoints
using an outside tool like WAF.

426
00:21:32,610 --> 00:21:34,140
But now I'm gonna hand it over to Heeki

427
00:21:34,140 --> 00:21:38,373
who's gonna dive into some
identity aware applications.

428
00:21:39,750 --> 00:21:41,070
- Cool, thank you Chris.

429
00:21:41,070 --> 00:21:42,420
Can you guys hear me?

430
00:21:42,420 --> 00:21:43,980
All right, sweet.

431
00:21:43,980 --> 00:21:46,290
So Chris gave us a really
good broad spectrum

432
00:21:46,290 --> 00:21:47,700
of a lot of different things

433
00:21:47,700 --> 00:21:49,140
that we need to be thinking about

434
00:21:49,140 --> 00:21:51,630
as we are building our
serverless applications.

435
00:21:51,630 --> 00:21:55,020
What I'm gonna do is over the
next maybe 15, 20 minutes,

436
00:21:55,020 --> 00:21:56,280
we're gonna actually dive really deep

437
00:21:56,280 --> 00:21:59,640
on one particular kind
of application stack

438
00:21:59,640 --> 00:22:01,740
security consideration, which I'm seeing

439
00:22:01,740 --> 00:22:04,410
as a very common use case,
especially as we start to think

440
00:22:04,410 --> 00:22:06,540
about both serverless applications,

441
00:22:06,540 --> 00:22:09,660
but also agentic applications,
which is a common thing

442
00:22:09,660 --> 00:22:11,520
that I see a lot of my customers
starting to think about.

443
00:22:11,520 --> 00:22:16,290
So we're gonna go back to the application

444
00:22:16,290 --> 00:22:18,390
that Chris presented before,

445
00:22:18,390 --> 00:22:20,130
again, we have our
fitness web application.

446
00:22:20,130 --> 00:22:21,300
So this is the first component

447
00:22:21,300 --> 00:22:23,160
that the user is gonna
be interacting with.

448
00:22:23,160 --> 00:22:25,350
Of course, that web application
is gonna then interact

449
00:22:25,350 --> 00:22:27,390
with our serverless API gateway,

450
00:22:27,390 --> 00:22:28,920
this is gonna be the activities, routes,

451
00:22:28,920 --> 00:22:30,360
et cetera, those APIs.

452
00:22:30,360 --> 00:22:32,730
And then of course the
business logic will reside

453
00:22:32,730 --> 00:22:34,170
within our Lambda function.

454
00:22:34,170 --> 00:22:36,720
So a bunch of what Chris
talked about already

455
00:22:36,720 --> 00:22:39,540
is going to be these resource
policies, execution roles,

456
00:22:39,540 --> 00:22:42,330
perhaps even those SEPs
for doing deployments.

457
00:22:42,330 --> 00:22:44,190
The part that I'm gonna
spend a bunch of my time on

458
00:22:44,190 --> 00:22:47,130
is going to actually be
here on the left side,

459
00:22:47,130 --> 00:22:50,100
thinking about user
authentication, authorization.

460
00:22:50,100 --> 00:22:51,810
How do we make sure that the user,

461
00:22:51,810 --> 00:22:53,430
so let's say Heeki is interacting

462
00:22:53,430 --> 00:22:55,260
with this fitness application,

463
00:22:55,260 --> 00:22:58,410
is doing things that he is allowed to do

464
00:22:58,410 --> 00:23:02,760
and is accessing resources that
I'm allowed to access, okay.

465
00:23:02,760 --> 00:23:05,793
So before we get into that,

466
00:23:07,080 --> 00:23:10,260
let's take a quick look at
our serverless application.

467
00:23:10,260 --> 00:23:13,950
So this is the one that
Chris had introduced before.

468
00:23:13,950 --> 00:23:16,350
And again, we have these
different API endpoints

469
00:23:16,350 --> 00:23:17,913
that he had introduced before.

470
00:23:18,750 --> 00:23:20,910
The thing to notice that,
again Chris had talked about

471
00:23:20,910 --> 00:23:23,850
was we have a number of different
of these APIs that again,

472
00:23:23,850 --> 00:23:25,920
you can think about as
the architects in the room

473
00:23:25,920 --> 00:23:28,290
we're using like domain driven design,

474
00:23:28,290 --> 00:23:29,670
and these are some bounded contexts.

475
00:23:29,670 --> 00:23:31,140
These are the domains of logic.

476
00:23:31,140 --> 00:23:33,000
So you can imagine different teams

477
00:23:33,000 --> 00:23:35,820
are provisioning these different APIs,

478
00:23:35,820 --> 00:23:37,500
and maybe they have different off schemes

479
00:23:37,500 --> 00:23:39,480
and we're gonna get into that momentarily.

480
00:23:39,480 --> 00:23:41,610
The key thing that a lot
of organizations will do

481
00:23:41,610 --> 00:23:44,100
when they're protecting
these type of API endpoints

482
00:23:44,100 --> 00:23:47,910
is going to be using a
standard called OAuth2.

483
00:23:47,910 --> 00:23:49,980
And we're gonna dive
pretty deep into OAuth2.

484
00:23:49,980 --> 00:23:52,290
But before we do, why don't we go over

485
00:23:52,290 --> 00:23:54,810
a couple of the terminology
that we're gonna be using

486
00:23:54,810 --> 00:23:55,950
throughout the rest of this talk.

487
00:23:55,950 --> 00:23:59,700
So when we think about OAuth2,

488
00:23:59,700 --> 00:24:01,470
there are a number of different entities

489
00:24:01,470 --> 00:24:02,580
that we want to be aware of.

490
00:24:02,580 --> 00:24:05,490
So the first is the
owner of that resource.

491
00:24:05,490 --> 00:24:07,710
So you could imagine maybe
there's some amount of data

492
00:24:07,710 --> 00:24:10,890
we are trying to protect
and let's say Heeki again,

493
00:24:10,890 --> 00:24:13,440
maybe I'm a Strava user,
I really like to run,

494
00:24:13,440 --> 00:24:16,140
so I have some of my data in this service

495
00:24:16,140 --> 00:24:17,160
and I own...

496
00:24:17,160 --> 00:24:18,450
In theory, I own the data,

497
00:24:18,450 --> 00:24:22,020
or I should be the one that
grants access to that data.

498
00:24:22,020 --> 00:24:24,530
I then use maybe a web
browser, maybe a mobile client.

499
00:24:24,530 --> 00:24:26,880
In this example, we'll
just use a web browser

500
00:24:26,880 --> 00:24:28,560
that is going to be the user agent.

501
00:24:28,560 --> 00:24:31,650
So that is the mechanism by
which I'm gonna be interacting

502
00:24:31,650 --> 00:24:34,050
with these protected resources.

503
00:24:34,050 --> 00:24:35,220
Then you have the web application.

504
00:24:35,220 --> 00:24:37,050
So my web browser of course connects

505
00:24:37,050 --> 00:24:38,790
to a particular web application.

506
00:24:38,790 --> 00:24:40,803
Maybe I have it deployed in Fargate.

507
00:24:42,210 --> 00:24:46,350
That web application or client
then interacts with the API

508
00:24:46,350 --> 00:24:47,400
that we are trying to protect.

509
00:24:47,400 --> 00:24:48,840
So this is that serverless API

510
00:24:48,840 --> 00:24:51,180
that Chris was talking about before.

511
00:24:51,180 --> 00:24:52,140
And last but not least,

512
00:24:52,140 --> 00:24:54,030
of course there is the
authorization server, right?

513
00:24:54,030 --> 00:24:57,060
So we need some entity,
some identity provider

514
00:24:57,060 --> 00:24:59,010
to be able to determine who is allowed

515
00:24:59,010 --> 00:25:00,270
to access these resources,

516
00:25:00,270 --> 00:25:03,180
and what resources are they
allowed to access, okay.

517
00:25:03,180 --> 00:25:05,340
So these are the five key kind of entities

518
00:25:05,340 --> 00:25:07,110
that we're gonna be thinking about

519
00:25:07,110 --> 00:25:08,733
throughout this entire flow.

520
00:25:10,020 --> 00:25:11,280
Another thing that we wanna think through

521
00:25:11,280 --> 00:25:14,850
is how do we actually get
access to the resources?

522
00:25:14,850 --> 00:25:18,450
So there's some process
by which this access

523
00:25:18,450 --> 00:25:19,350
is going to be granted.

524
00:25:19,350 --> 00:25:21,210
So there are actually a number of 'em,

525
00:25:21,210 --> 00:25:23,250
in this talk we're just
gonna talk about two.

526
00:25:23,250 --> 00:25:24,840
Really, we're gonna talk about one

527
00:25:24,840 --> 00:25:26,910
and then we'll see how
when you learn about one,

528
00:25:26,910 --> 00:25:28,500
you've already learned
about the second one.

529
00:25:28,500 --> 00:25:30,840
So the first one is authorization code,

530
00:25:30,840 --> 00:25:32,700
or code authorization flow.

531
00:25:32,700 --> 00:25:34,380
And this is the most common one

532
00:25:34,380 --> 00:25:35,700
that probably you're familiar with.

533
00:25:35,700 --> 00:25:40,080
So you may be familiar with
like when you click on a webpage

534
00:25:40,080 --> 00:25:41,640
and it says, do you wanna allow access

535
00:25:41,640 --> 00:25:44,490
to this particular application
for these resources?

536
00:25:44,490 --> 00:25:46,953
That is an example of
code authorization flow.

537
00:25:47,880 --> 00:25:49,830
The second one is client credentials flow.

538
00:25:49,830 --> 00:25:52,530
So where the first one is end user facing,

539
00:25:52,530 --> 00:25:55,050
so I'm logging into a webpage

540
00:25:55,050 --> 00:25:56,940
and then I'm gonna allow access,

541
00:25:56,940 --> 00:25:58,680
client credentials is typically used

542
00:25:58,680 --> 00:26:00,660
in machine to machine communication.

543
00:26:00,660 --> 00:26:04,710
In the former, you have this
user interactive experience

544
00:26:04,710 --> 00:26:07,800
where someone is gonna be
clicking, essentially allow.

545
00:26:07,800 --> 00:26:09,120
In a client credential scenario,

546
00:26:09,120 --> 00:26:10,620
you want a machine to be able to do that.

547
00:26:10,620 --> 00:26:13,230
So there is no user that's
gonna be clicking that approve

548
00:26:13,230 --> 00:26:15,120
or allow button.

549
00:26:15,120 --> 00:26:17,730
Okay, so these are two flows
we're gonna talk about.

550
00:26:17,730 --> 00:26:20,040
We're gonna dive really
deep in code authorization

551
00:26:20,040 --> 00:26:21,840
and then you'll see how
you've already learned

552
00:26:21,840 --> 00:26:23,090
about client credentials.

553
00:26:24,330 --> 00:26:25,710
Some other things that
we wanna think about.

554
00:26:25,710 --> 00:26:29,220
So the relevant credentials
that you wanna be aware of.

555
00:26:29,220 --> 00:26:31,560
So when you are creating an application,

556
00:26:31,560 --> 00:26:32,880
or maybe when a developer,

557
00:26:32,880 --> 00:26:35,310
you as a developer are
building an application,

558
00:26:35,310 --> 00:26:37,590
you actually need to
register that application

559
00:26:37,590 --> 00:26:38,910
with your identity provider.

560
00:26:38,910 --> 00:26:41,100
So the first thing that
you end up creating

561
00:26:41,100 --> 00:26:43,380
is what we call the client ID.

562
00:26:43,380 --> 00:26:45,660
And perhaps the simplest
way to think about it,

563
00:26:45,660 --> 00:26:47,190
it's not exactly like this,

564
00:26:47,190 --> 00:26:49,260
but you can almost think
of this like a username.

565
00:26:49,260 --> 00:26:53,130
So me as an entity
interacting within the system,

566
00:26:53,130 --> 00:26:56,970
maybe Heeki has a username
that is associated with me.

567
00:26:56,970 --> 00:26:59,700
Well, for an application,
you would have a client ID

568
00:26:59,700 --> 00:27:00,990
associated with that application.

569
00:27:00,990 --> 00:27:03,360
So when you register it
with the identity provider,

570
00:27:03,360 --> 00:27:05,283
it will vend you a client ID.

571
00:27:06,690 --> 00:27:08,400
Next then is the client secret.

572
00:27:08,400 --> 00:27:09,660
And again, as you can imagine,

573
00:27:09,660 --> 00:27:12,840
this is somewhat similar
to having a password,

574
00:27:12,840 --> 00:27:15,120
so a username password,

575
00:27:15,120 --> 00:27:17,400
but this would be
essentially the client ID

576
00:27:17,400 --> 00:27:20,250
and client secret for the
particular application.

577
00:27:20,250 --> 00:27:21,780
And these two together are used

578
00:27:21,780 --> 00:27:23,460
to then essentially authenticate

579
00:27:23,460 --> 00:27:26,040
that this is the application interacting

580
00:27:26,040 --> 00:27:29,430
with the identity provider, okay?

581
00:27:29,430 --> 00:27:30,960
All right, one more set of tokens,

582
00:27:30,960 --> 00:27:32,640
and then we're gonna kind
of dive pretty deep into it.

583
00:27:32,640 --> 00:27:33,690
And then we're gonna apply this

584
00:27:33,690 --> 00:27:35,580
to our serverless application, right?

585
00:27:35,580 --> 00:27:38,460
So these are a number of
different tokens that you then get

586
00:27:38,460 --> 00:27:41,190
when you exchange your
client ID and client secret,

587
00:27:41,190 --> 00:27:42,750
and my user identity, right?

588
00:27:42,750 --> 00:27:45,150
So the first is an ID token.

589
00:27:45,150 --> 00:27:46,830
This is a short lived token.

590
00:27:46,830 --> 00:27:48,810
The really simple way to think about this

591
00:27:48,810 --> 00:27:52,350
is this ID token identifies
who is interacting

592
00:27:52,350 --> 00:27:53,183
with this service.

593
00:27:53,183 --> 00:27:55,770
So it might have information
like my username,

594
00:27:55,770 --> 00:27:56,700
maybe my email.

595
00:27:56,700 --> 00:27:59,490
Again, this is all dependent
on what you want to include

596
00:27:59,490 --> 00:28:00,900
in your application.

597
00:28:00,900 --> 00:28:02,220
The next is the access token,

598
00:28:02,220 --> 00:28:04,770
and this is perhaps the
one that is most important.

599
00:28:04,770 --> 00:28:07,410
This is the one that defines,
you've authenticated,

600
00:28:07,410 --> 00:28:09,570
now this defines what are the actions

601
00:28:09,570 --> 00:28:10,530
that you are allowed to take.

602
00:28:10,530 --> 00:28:11,850
So we call these scopes.

603
00:28:11,850 --> 00:28:14,340
This will say, I'm allowed
to, you know, have read access

604
00:28:14,340 --> 00:28:15,810
to this particular endpoint.

605
00:28:15,810 --> 00:28:18,690
Maybe I have write access
to this particular endpoint.

606
00:28:18,690 --> 00:28:19,680
And then last but not least

607
00:28:19,680 --> 00:28:21,330
is what we call the refresh token.

608
00:28:21,330 --> 00:28:25,110
So you can imagine in the
code authorization flow

609
00:28:25,110 --> 00:28:27,600
as a user interacting with
it, it might be painful

610
00:28:27,600 --> 00:28:30,690
to every 15 minutes or every 60 minutes

611
00:28:30,690 --> 00:28:34,290
to ask that user to
re-approve that request.

612
00:28:34,290 --> 00:28:35,820
While the refresh token is then used

613
00:28:35,820 --> 00:28:37,080
to actually do that automatically.

614
00:28:37,080 --> 00:28:38,010
So you may...

615
00:28:38,010 --> 00:28:39,600
This might be a longer lived credential,

616
00:28:39,600 --> 00:28:43,200
maybe we're gonna allow this
credential to live for 24 hours

617
00:28:43,200 --> 00:28:46,740
and we'll refresh the user's tokens

618
00:28:46,740 --> 00:28:49,230
by using this refresh token, okay.

619
00:28:49,230 --> 00:28:51,690
So these are the credentials tokens,

620
00:28:51,690 --> 00:28:53,610
and some of the identities within it.

621
00:28:53,610 --> 00:28:56,040
So these are all the components necessary

622
00:28:56,040 --> 00:28:58,170
when you're building
serverless applications

623
00:28:58,170 --> 00:28:59,400
or as we show in a little bit,

624
00:28:59,400 --> 00:29:01,230
we're going to see how
this is gonna be used

625
00:29:01,230 --> 00:29:03,783
for your agentic applications as well.

626
00:29:03,783 --> 00:29:04,800
(participants clapping)

627
00:29:04,800 --> 00:29:06,570
Thank you. Thank you.

628
00:29:06,570 --> 00:29:08,370
Alright, so the first phase,

629
00:29:08,370 --> 00:29:09,630
I'm gonna talk about two phases.

630
00:29:09,630 --> 00:29:11,400
So for the code authorization flow,

631
00:29:11,400 --> 00:29:13,020
there's really two phases

632
00:29:13,020 --> 00:29:15,720
and in this first phase really
what you wanna think about it

633
00:29:15,720 --> 00:29:18,450
is the user is essentially logging in

634
00:29:18,450 --> 00:29:20,610
and getting an authorization code, right?

635
00:29:20,610 --> 00:29:22,530
And so you have this user, so Heeki,

636
00:29:22,530 --> 00:29:25,350
I'm gonna log into the web browser.

637
00:29:25,350 --> 00:29:27,060
You can imagine I'm gonna get redirected

638
00:29:27,060 --> 00:29:28,920
to a login page, right?

639
00:29:28,920 --> 00:29:31,650
And so again, this is probably
familiar with all of you.

640
00:29:31,650 --> 00:29:34,530
After I log in, then
you get that little...

641
00:29:34,530 --> 00:29:36,900
That popup that says, do
you wanna allow Heeki access

642
00:29:36,900 --> 00:29:38,130
to this particular resource?

643
00:29:38,130 --> 00:29:39,720
And it'll have a bunch of check boxes.

644
00:29:39,720 --> 00:29:42,330
We're gonna go ahead and approve.

645
00:29:42,330 --> 00:29:44,730
Once you hit approve,
things on the backend

646
00:29:44,730 --> 00:29:48,690
is the identity provider
will generate an off code.

647
00:29:48,690 --> 00:29:50,550
And so this is just
basically a long string,

648
00:29:50,550 --> 00:29:52,320
it's a one-time use string.

649
00:29:52,320 --> 00:29:54,990
It then sends that back to the front end.

650
00:29:54,990 --> 00:29:58,260
So the front end application
receives this off code.

651
00:29:58,260 --> 00:30:00,450
It already had the client
ID and client secret,

652
00:30:00,450 --> 00:30:03,150
so again, this is something
that you registered

653
00:30:03,150 --> 00:30:04,680
with your identity provider

654
00:30:04,680 --> 00:30:06,390
when you created the application.

655
00:30:06,390 --> 00:30:07,950
When you now deploy the application,

656
00:30:07,950 --> 00:30:10,680
that gets deployed alongside
with the application.

657
00:30:10,680 --> 00:30:13,170
So now the application
has the client's ID,

658
00:30:13,170 --> 00:30:15,510
client secret that it uses to authenticate

659
00:30:15,510 --> 00:30:16,920
with the identity provider.

660
00:30:16,920 --> 00:30:20,280
It now has the off code,
which is now user specific

661
00:30:20,280 --> 00:30:22,770
and it uses that to then
exchange for a set of tokens.

662
00:30:22,770 --> 00:30:26,133
So this is the first phase
that is user interactive.

663
00:30:27,120 --> 00:30:28,500
Now the second phase is, okay,

664
00:30:28,500 --> 00:30:30,990
so we had this front end application,

665
00:30:30,990 --> 00:30:33,480
it was deployed with
that client ID in secret,

666
00:30:33,480 --> 00:30:35,400
it just received that off code,

667
00:30:35,400 --> 00:30:36,950
that exchange that we just did,

668
00:30:37,920 --> 00:30:39,890
it is now gonna go to
my authorization server.

669
00:30:39,890 --> 00:30:42,360
In this case I'm gonna use Amazon Cognito

670
00:30:42,360 --> 00:30:44,190
and it sends the client ID,

671
00:30:44,190 --> 00:30:46,680
the client secret and that off code.

672
00:30:46,680 --> 00:30:51,210
And Cognito will then
validate these strings

673
00:30:51,210 --> 00:30:53,880
and credentials, it will then provide back

674
00:30:53,880 --> 00:30:58,410
the ID token, access
token, and refresh token

675
00:30:58,410 --> 00:31:00,090
to the front end application.

676
00:31:00,090 --> 00:31:01,350
The one thing that I wanna stress here

677
00:31:01,350 --> 00:31:04,080
is as you're building your
serverless applications,

678
00:31:04,080 --> 00:31:07,770
you are not going to
expose these ID tokens,

679
00:31:07,770 --> 00:31:11,580
access tokens and refresh
tokens to the web browser.

680
00:31:11,580 --> 00:31:13,290
You wanna make sure these
stay within the bounds

681
00:31:13,290 --> 00:31:14,190
of the front end application.

682
00:31:14,190 --> 00:31:15,023
These are not things

683
00:31:15,023 --> 00:31:17,100
that your end users should
actually end up seeing.

684
00:31:17,100 --> 00:31:18,950
This is all happening in the backend.

685
00:31:19,830 --> 00:31:22,800
So what happens is you'll
send, let's say the ID token

686
00:31:22,800 --> 00:31:25,617
with API gateway, that
goes to the authorizer.

687
00:31:25,617 --> 00:31:27,630
API gateway will then take that ID token,

688
00:31:27,630 --> 00:31:30,330
go back to the authorization server,

689
00:31:30,330 --> 00:31:33,243
and go and validate is
this a valid ID token?

690
00:31:34,110 --> 00:31:36,030
So again, it'll go in and say, okay,

691
00:31:36,030 --> 00:31:37,800
I see this is an ID token from Heeki.

692
00:31:37,800 --> 00:31:40,200
He wants to then go and access, you know,

693
00:31:40,200 --> 00:31:41,970
the backend API.

694
00:31:41,970 --> 00:31:44,400
API gateway once it
receives that validation,

695
00:31:44,400 --> 00:31:47,790
it sees, okay, this is an
allowed request, it will then...

696
00:31:47,790 --> 00:31:49,320
Oops, I guess I didn't have it in there.

697
00:31:49,320 --> 00:31:50,940
It will then allow it to, let's say,

698
00:31:50,940 --> 00:31:52,710
invoke the Lambda function on the backend.

699
00:31:52,710 --> 00:31:54,540
And as Chris had talked about before,

700
00:31:54,540 --> 00:31:57,000
this assumes then you
had already configured,

701
00:31:57,000 --> 00:31:59,430
let's say a resource-based
policy with your Lambda function

702
00:31:59,430 --> 00:32:02,820
so that API gateway is
allowed to actually invoke it.

703
00:32:02,820 --> 00:32:04,860
Okay, so we talked about phase one

704
00:32:04,860 --> 00:32:07,470
is with that the end user interaction.

705
00:32:07,470 --> 00:32:08,790
Phase two is on the backend

706
00:32:08,790 --> 00:32:11,280
where you have the, again,
the client application,

707
00:32:11,280 --> 00:32:12,660
the front end application

708
00:32:12,660 --> 00:32:14,760
doing a bunch of these token exchanges.

709
00:32:14,760 --> 00:32:16,820
The reason we break this up into...

710
00:32:17,790 --> 00:32:19,260
Actually I think I'm skipping ahead here.

711
00:32:19,260 --> 00:32:22,500
So this is actually a quick
a refresh of the whole flow.

712
00:32:22,500 --> 00:32:26,430
So user comes in, connects
to the front end application,

713
00:32:26,430 --> 00:32:28,590
logs in, gets the off code,

714
00:32:28,590 --> 00:32:31,440
sends it back to the
front end application.

715
00:32:31,440 --> 00:32:34,593
It then validates that, invokes the API,

716
00:32:35,580 --> 00:32:37,950
the API gateway will check
with the authorization server.

717
00:32:37,950 --> 00:32:39,900
And then here's where we
have that Lambda function

718
00:32:39,900 --> 00:32:42,840
that then gets invoked
with that resource server.

719
00:32:42,840 --> 00:32:46,170
So what's nice here then is within Lambda,

720
00:32:46,170 --> 00:32:47,400
again, for those folks that have built

721
00:32:47,400 --> 00:32:48,233
with Lambda functions,

722
00:32:48,233 --> 00:32:49,350
how many of you guys have deployed

723
00:32:49,350 --> 00:32:51,660
a production application using Lambda?

724
00:32:51,660 --> 00:32:52,560
Okay, a lot of you folks,

725
00:32:52,560 --> 00:32:55,230
so you know with your Lambda
functions, with your handler,

726
00:32:55,230 --> 00:32:56,460
you have two parameters there.

727
00:32:56,460 --> 00:32:57,900
One is your event payload,

728
00:32:57,900 --> 00:32:59,790
and then one is your context payload.

729
00:32:59,790 --> 00:33:03,030
So you can actually see
within the context payload

730
00:33:03,030 --> 00:33:04,890
a bunch of identity information.

731
00:33:04,890 --> 00:33:05,880
So this could be something

732
00:33:05,880 --> 00:33:07,950
where maybe as a developer you know

733
00:33:07,950 --> 00:33:09,720
that this was an authorized request,

734
00:33:09,720 --> 00:33:11,490
but maybe there's some additional things

735
00:33:11,490 --> 00:33:13,800
that you may want to do
within your business logic.

736
00:33:13,800 --> 00:33:18,030
Maybe you have like a grouping of users,

737
00:33:18,030 --> 00:33:20,490
and based on certain
entitlements you wanna allow them

738
00:33:20,490 --> 00:33:22,080
to do certain custom actions.

739
00:33:22,080 --> 00:33:23,670
This is something you
could then custom code

740
00:33:23,670 --> 00:33:25,290
into your Lambda functions.

741
00:33:25,290 --> 00:33:27,000
So this is a lot of additional information

742
00:33:27,000 --> 00:33:30,630
you have available to you
even after you've already done

743
00:33:30,630 --> 00:33:31,593
the OAuth flow.

744
00:33:32,490 --> 00:33:36,270
So what I was getting at before
is we talked about phase one

745
00:33:36,270 --> 00:33:37,103
and phase two.

746
00:33:37,103 --> 00:33:38,490
Phase one is the user interaction,

747
00:33:38,490 --> 00:33:40,470
phase two is that machine to machine.

748
00:33:40,470 --> 00:33:43,080
Well, with client credential
flow you can essentially strip

749
00:33:43,080 --> 00:33:46,440
off phase one, that login piece

750
00:33:46,440 --> 00:33:48,540
and the exchange for that off token.

751
00:33:48,540 --> 00:33:51,690
And now for client credentials
it's just phase two.

752
00:33:51,690 --> 00:33:53,850
So you've now basically learned both.

753
00:33:53,850 --> 00:33:56,190
So here you see that web application,

754
00:33:56,190 --> 00:33:59,400
it gets deployed with the
client ID and client secret.

755
00:33:59,400 --> 00:34:01,110
Now it just exchanges the client ID,

756
00:34:01,110 --> 00:34:03,210
and client secret for that set of tokens,

757
00:34:03,210 --> 00:34:05,190
that ID access and refresh token.

758
00:34:05,190 --> 00:34:07,710
In this scenario we no
longer need the off code

759
00:34:07,710 --> 00:34:10,920
because this is not interacting
with any particular user.

760
00:34:10,920 --> 00:34:12,570
So again now we just do that same flow.

761
00:34:12,570 --> 00:34:15,510
We send maybe that barer
token along to API gateway,

762
00:34:15,510 --> 00:34:18,720
it then goes and validates
with your identity provider

763
00:34:18,720 --> 00:34:20,940
and then invokes your Lambda function.

764
00:34:20,940 --> 00:34:22,860
So you're kind of asking like, okay,

765
00:34:22,860 --> 00:34:25,500
that was a lot to try
to understand OAuth2,

766
00:34:25,500 --> 00:34:28,830
well with a lot of both serverless APIs

767
00:34:28,830 --> 00:34:31,110
and also with a lot of
agentic applications,

768
00:34:31,110 --> 00:34:35,100
OAuth2 is the foundation
security mechanism for ensuring

769
00:34:35,100 --> 00:34:36,420
that users have access

770
00:34:36,420 --> 00:34:38,010
to the appropriate downstream resources.

771
00:34:38,010 --> 00:34:40,740
So for folks that are
building serverless APIs,

772
00:34:40,740 --> 00:34:41,730
or if you're thinking

773
00:34:41,730 --> 00:34:44,340
about even building agentic applications,

774
00:34:44,340 --> 00:34:46,050
this is going to be a core flow

775
00:34:46,050 --> 00:34:47,310
that you're gonna wanna understand.

776
00:34:47,310 --> 00:34:48,270
And we're gonna talk about

777
00:34:48,270 --> 00:34:50,340
how we make this a
little bit easier for you

778
00:34:50,340 --> 00:34:51,640
in the next couple slides.

779
00:34:52,530 --> 00:34:55,800
So we covered OAuth, but what
about, are there other ways

780
00:34:55,800 --> 00:34:58,590
for your serverless APIs
to think about doing

781
00:34:58,590 --> 00:35:01,260
the same type of mechanisms
for fine grain permissions?

782
00:35:01,260 --> 00:35:02,160
Well there is.

783
00:35:02,160 --> 00:35:04,380
So you can also do something

784
00:35:04,380 --> 00:35:06,480
with Amazon Verified Permissions.

785
00:35:06,480 --> 00:35:09,600
So similar flow, you have
an end user coming in,

786
00:35:09,600 --> 00:35:12,300
they're gonna authenticate
with the identity provider.

787
00:35:13,410 --> 00:35:14,820
You will then try to access...

788
00:35:14,820 --> 00:35:16,080
So I cut out the client,

789
00:35:16,080 --> 00:35:17,640
'cause you can just
assume it goes through.

790
00:35:17,640 --> 00:35:20,640
You're gonna then try to access
your API gateway endpoint.

791
00:35:20,640 --> 00:35:23,160
And here you're gonna include that token

792
00:35:23,160 --> 00:35:25,290
as a bar token within the header.

793
00:35:25,290 --> 00:35:27,060
And in this case with API gateway,

794
00:35:27,060 --> 00:35:29,130
you can actually use
now a Lambda Authorizer.

795
00:35:29,130 --> 00:35:32,250
So you can configure an
authorizer to then interact

796
00:35:32,250 --> 00:35:34,827
with our verified
permission service, right?

797
00:35:34,827 --> 00:35:36,780
And so you can actually take the header,

798
00:35:36,780 --> 00:35:38,280
whatever that token might be,

799
00:35:38,280 --> 00:35:40,860
and then it will then go
and do a verification.

800
00:35:40,860 --> 00:35:43,110
So here's the token that comes in,

801
00:35:43,110 --> 00:35:45,450
run it against Amazon
Verified Permissions.

802
00:35:45,450 --> 00:35:47,370
Amazon Verified Permissions
will then come back

803
00:35:47,370 --> 00:35:48,783
and say allow or deny.

804
00:35:50,070 --> 00:35:52,200
And then based on that,
we'll then perhaps invoke

805
00:35:52,200 --> 00:35:54,000
the backend if that was allowed.

806
00:35:54,000 --> 00:35:56,400
Now you may be asking like how do we know,

807
00:35:56,400 --> 00:35:59,970
or how do we actually define
like who's allowed to do what?

808
00:35:59,970 --> 00:36:02,370
Great question. So with
Verified Permissions,

809
00:36:02,370 --> 00:36:05,760
what it actually does is it
actually uses a policy language

810
00:36:05,760 --> 00:36:06,840
on the backend.

811
00:36:06,840 --> 00:36:08,160
And this is actually an open source

812
00:36:08,160 --> 00:36:10,170
policy language called Cedar.

813
00:36:10,170 --> 00:36:12,030
Here's a little bit of
what that might look like.

814
00:36:12,030 --> 00:36:13,590
So this is an example.

815
00:36:13,590 --> 00:36:14,970
So maybe for the security folks,

816
00:36:14,970 --> 00:36:17,700
I saw when Chris was asking
before there was maybe a third

817
00:36:17,700 --> 00:36:19,470
or maybe even a half of this audience,

818
00:36:19,470 --> 00:36:22,440
you're really focused on
the security side of things.

819
00:36:22,440 --> 00:36:27,240
You can actually using code
define the allowed actions

820
00:36:27,240 --> 00:36:29,640
for a particular set of resources.

821
00:36:29,640 --> 00:36:30,960
So here's an example

822
00:36:30,960 --> 00:36:33,780
where perhaps we have
a particular namespace.

823
00:36:33,780 --> 00:36:37,530
So I want to include, so here at reInvent

824
00:36:37,530 --> 00:36:39,810
we have a bunch of APIs that are defined

825
00:36:39,810 --> 00:36:41,850
for demos here at reInvent.

826
00:36:41,850 --> 00:36:43,950
There's actually also a group of users.

827
00:36:43,950 --> 00:36:47,760
So maybe the audience here
in this particular session

828
00:36:47,760 --> 00:36:50,940
is going to be included as
part of this permission.

829
00:36:50,940 --> 00:36:54,090
And then this is then
the Cognito user pool.

830
00:36:54,090 --> 00:36:56,100
Along with the Cognito user group, right?

831
00:36:56,100 --> 00:36:59,310
So this is the principle,
this is the allowed identity

832
00:36:59,310 --> 00:37:01,830
that is gonna be defined
by this particular policy.

833
00:37:01,830 --> 00:37:03,810
And then this then is the allowed action.

834
00:37:03,810 --> 00:37:07,080
So the audience here, if
you were to make a request

835
00:37:07,080 --> 00:37:10,200
to my particular API that
uses this Lambda authorizer,

836
00:37:10,200 --> 00:37:11,970
we'll be allowed to make a get request

837
00:37:11,970 --> 00:37:14,610
to the /products API endpoints,

838
00:37:14,610 --> 00:37:17,790
or maybe the /activities API endpoint.

839
00:37:17,790 --> 00:37:21,420
So this is an example of a
policy I can define using Cedar,

840
00:37:21,420 --> 00:37:25,350
I would then essentially
configure Verified Permissions

841
00:37:25,350 --> 00:37:27,780
to then use this policy when API gateway

842
00:37:27,780 --> 00:37:29,640
makes these type of requests.

843
00:37:29,640 --> 00:37:31,950
Okay, so a number of different ways.

844
00:37:31,950 --> 00:37:33,420
We talked about OAuth in depth,

845
00:37:33,420 --> 00:37:35,550
we talked about using Verified Permissions

846
00:37:35,550 --> 00:37:38,550
to be able to identify
users that are coming in,

847
00:37:38,550 --> 00:37:40,980
make sure we have these
identity aware interactions

848
00:37:40,980 --> 00:37:42,840
with my serverless APIs.

849
00:37:42,840 --> 00:37:45,690
So let's try to push the
boundaries a little bit,

850
00:37:45,690 --> 00:37:47,970
and think about is there a way
we can continue to innovate

851
00:37:47,970 --> 00:37:49,660
from a security perspective

852
00:37:50,850 --> 00:37:54,570
in where we're seeing a lot of
new applications being built.

853
00:37:54,570 --> 00:37:57,750
So coming back to our
Serverless Fitness Application,

854
00:37:57,750 --> 00:37:59,550
we have our traditional application,

855
00:37:59,550 --> 00:38:02,730
we have again our different API endpoints.

856
00:38:02,730 --> 00:38:05,160
So one thing that we
may wanna think about,

857
00:38:05,160 --> 00:38:06,780
and you may have heard
about some of this again,

858
00:38:06,780 --> 00:38:09,240
even in the keynote this
morning, Matt Garmin was talking

859
00:38:09,240 --> 00:38:12,390
a little bit about using
and building agents.

860
00:38:12,390 --> 00:38:15,180
And so one way we can think
about maybe transitioning

861
00:38:15,180 --> 00:38:19,110
our serverless fitness application
into an agent application

862
00:38:19,110 --> 00:38:21,630
is using something called
tool calling, right?

863
00:38:21,630 --> 00:38:24,240
So within our agents now
we're gonna build this agent

864
00:38:24,240 --> 00:38:25,860
using an agentic framework.

865
00:38:25,860 --> 00:38:27,510
We have an ability to then create

866
00:38:27,510 --> 00:38:29,460
and define what we call tools.

867
00:38:29,460 --> 00:38:31,800
The simplest way to think
about this is, is a tool

868
00:38:31,800 --> 00:38:35,430
is just another function that
we're gonna annotate as a tool

869
00:38:35,430 --> 00:38:37,770
and we're gonna then call our
different serverless APIs.

870
00:38:37,770 --> 00:38:40,710
So the activities route
socials, and support API

871
00:38:40,710 --> 00:38:43,830
that we already have for our
serverless fitness application.

872
00:38:43,830 --> 00:38:46,020
We're just gonna essentially
wrap it in a function,

873
00:38:46,020 --> 00:38:48,180
and annotate it as a tool.

874
00:38:48,180 --> 00:38:49,260
The nice thing then here...

875
00:38:49,260 --> 00:38:52,440
So these are the tools that
we're gonna be able to create.

876
00:38:52,440 --> 00:38:53,520
The nice thing then here

877
00:38:53,520 --> 00:38:57,450
is that our agentic application here,

878
00:38:57,450 --> 00:39:00,000
as it interacts with a model, an LLM,

879
00:39:00,000 --> 00:39:03,660
it is able to very easily
gain access to the data

880
00:39:03,660 --> 00:39:06,270
that is accessible from
these different APIs.

881
00:39:06,270 --> 00:39:09,330
So you can imagine
maybe Heeki as a runner,

882
00:39:09,330 --> 00:39:12,660
I just did, let's say for the
last 30 days I did 10 runs

883
00:39:12,660 --> 00:39:13,800
over that period of time,

884
00:39:13,800 --> 00:39:15,840
and I actually wanna do
a little bit of analysis.

885
00:39:15,840 --> 00:39:17,520
I wanna try to understand, you know,

886
00:39:17,520 --> 00:39:20,730
what is my average heart
rate over this period of time

887
00:39:20,730 --> 00:39:22,740
for a particular weather condition,

888
00:39:22,740 --> 00:39:25,200
and am I actually improving in my fitness

889
00:39:25,200 --> 00:39:26,790
or am I actually getting worse?

890
00:39:26,790 --> 00:39:28,740
Is there something that
I need to change in that?

891
00:39:28,740 --> 00:39:29,850
So this is certainly something

892
00:39:29,850 --> 00:39:32,550
that in a serverless
application I can go and build,

893
00:39:32,550 --> 00:39:35,460
and write imperative code
to be able to do this.

894
00:39:35,460 --> 00:39:36,540
But maybe as a developer,

895
00:39:36,540 --> 00:39:38,070
maybe there's a simpler way to do this

896
00:39:38,070 --> 00:39:41,070
and maybe I can actually
leverage an agent application

897
00:39:41,070 --> 00:39:42,777
to be able to do that on my behalf.

898
00:39:42,777 --> 00:39:45,540
And this is perhaps where
some of the ideation can come,

899
00:39:45,540 --> 00:39:48,180
and why we may wanna actually
move into this direction.

900
00:39:48,180 --> 00:39:50,520
Okay, so thinking about tool calling,

901
00:39:50,520 --> 00:39:53,430
then you may be thinking,
okay, do I have to like wrap

902
00:39:53,430 --> 00:39:56,820
a lot of my APIs and do a bunch of work

903
00:39:56,820 --> 00:39:58,530
in order to be able to bring this data,

904
00:39:58,530 --> 00:40:01,710
bring this API data into my agent?

905
00:40:01,710 --> 00:40:04,260
Well, fortunately we've actually created

906
00:40:04,260 --> 00:40:05,160
or we didn't create,

907
00:40:05,160 --> 00:40:08,550
Anthropic created an open
specification last year,

908
00:40:08,550 --> 00:40:09,780
and you may have heard of it,

909
00:40:09,780 --> 00:40:14,010
anyone ever heard of the
acronym M-C-P? M-C-P.

910
00:40:14,010 --> 00:40:15,210
So a number of handfuls.

911
00:40:15,210 --> 00:40:17,640
So MCP stands for model context protocol.

912
00:40:17,640 --> 00:40:22,290
It is basically a specification
that standardizes the way

913
00:40:22,290 --> 00:40:23,490
that you do tool calling

914
00:40:23,490 --> 00:40:25,890
within an agentic application, right?

915
00:40:25,890 --> 00:40:30,000
So this is where you can
now as your fitness agent

916
00:40:30,000 --> 00:40:33,300
can essentially have
a singular MCP client,

917
00:40:33,300 --> 00:40:37,200
and now the different data
providers can then provide

918
00:40:37,200 --> 00:40:38,760
an MCP server, right?

919
00:40:38,760 --> 00:40:41,460
And so again, you can
imagine with the activities,

920
00:40:41,460 --> 00:40:43,800
routes, socials and support APIs,

921
00:40:43,800 --> 00:40:46,470
maybe those are actually by
different development teams

922
00:40:46,470 --> 00:40:47,640
within your organization.

923
00:40:47,640 --> 00:40:50,610
So you can imagine team A
is doing the activities API,

924
00:40:50,610 --> 00:40:53,040
team B is doing the routes API, et cetera.

925
00:40:53,040 --> 00:40:55,710
So each of those teams as data providers,

926
00:40:55,710 --> 00:40:58,440
or as API providers would be responsible

927
00:40:58,440 --> 00:41:00,900
for vending an MCP server.

928
00:41:00,900 --> 00:41:03,090
Now you may be asking, okay,
what does this all have to do

929
00:41:03,090 --> 00:41:05,670
with the security talk that
we're really focused on here?

930
00:41:05,670 --> 00:41:09,060
Well, in this whole process there are...

931
00:41:09,060 --> 00:41:12,090
Continue to be security considerations.

932
00:41:12,090 --> 00:41:14,970
So here's an example where
all of that OAuth2 stuff

933
00:41:14,970 --> 00:41:16,110
that we just talked about and learned,

934
00:41:16,110 --> 00:41:18,990
we're gonna apply that into
this agentic application.

935
00:41:18,990 --> 00:41:20,400
So you could imagine

936
00:41:20,400 --> 00:41:24,390
as an end user interacting with an agent,

937
00:41:24,390 --> 00:41:26,670
maybe there's the code
authorization flow, right?

938
00:41:26,670 --> 00:41:28,410
And so again, as an end user,

939
00:41:28,410 --> 00:41:30,960
maybe I'm accessing this
through a web browser,

940
00:41:30,960 --> 00:41:33,960
I'm gonna log in and then
I'm gonna click authorize

941
00:41:33,960 --> 00:41:36,810
and now I have access
to this fitness agent.

942
00:41:36,810 --> 00:41:38,460
You can imagine then I asked that question

943
00:41:38,460 --> 00:41:40,860
that I asked before of
like help me understand

944
00:41:40,860 --> 00:41:42,840
the last 30 days of running.

945
00:41:42,840 --> 00:41:44,280
Can you do an analysis on my data?

946
00:41:44,280 --> 00:41:46,980
Am I improving and do I need
to change something in the way

947
00:41:46,980 --> 00:41:48,570
that I'm training?

948
00:41:48,570 --> 00:41:50,820
The fitness agent will then
make a determination and say,

949
00:41:50,820 --> 00:41:55,230
actually make a call
to our activities tool,

950
00:41:55,230 --> 00:41:58,950
which will use the MCP clients
and talk to the MCP server.

951
00:41:58,950 --> 00:42:00,300
So again, because this is a machine

952
00:42:00,300 --> 00:42:01,800
to machine communication,

953
00:42:01,800 --> 00:42:05,070
maybe we've configured client
credentials to allow my agent

954
00:42:05,070 --> 00:42:08,160
to be able to talk to this MCP server,

955
00:42:08,160 --> 00:42:10,080
but that's actually not the last step.

956
00:42:10,080 --> 00:42:11,880
The MCP server itself

957
00:42:11,880 --> 00:42:14,880
is going to then talk to
my serverless API, right?

958
00:42:14,880 --> 00:42:17,340
And so maybe we have a setup here

959
00:42:17,340 --> 00:42:19,140
where we're gonna also
use client credentials

960
00:42:19,140 --> 00:42:21,690
because this is also a machine
to machine communication.

961
00:42:21,690 --> 00:42:24,390
You may also want to think,
actually I want to make sure

962
00:42:24,390 --> 00:42:27,741
I'm propagating identity
information from Heeki

963
00:42:27,741 --> 00:42:30,750
as the end user accessing
the agent all the way down

964
00:42:30,750 --> 00:42:32,580
to the activities API.

965
00:42:32,580 --> 00:42:34,170
So maybe instead of a client credentials,

966
00:42:34,170 --> 00:42:36,930
maybe we actually want to use
the code authorization flow.

967
00:42:36,930 --> 00:42:38,340
And for the astute in the audience,

968
00:42:38,340 --> 00:42:41,130
you're probably thinking
how do you do that?

969
00:42:41,130 --> 00:42:45,480
My MCP server and activities
API is way far in the back end.

970
00:42:45,480 --> 00:42:48,810
How do I actually propagate
that end user request?

971
00:42:48,810 --> 00:42:50,670
Well there is a way
you can actually stream

972
00:42:50,670 --> 00:42:53,760
that request back all
the way to the front end,

973
00:42:53,760 --> 00:42:56,510
so that I as a user can
actually hit the accept button.

974
00:42:57,450 --> 00:43:00,090
Okay, so we talked a
little bit about, you know,

975
00:43:00,090 --> 00:43:02,160
we have our serverless
fitness application.

976
00:43:02,160 --> 00:43:04,710
We're thinking maybe
this is an opportunity

977
00:43:04,710 --> 00:43:06,450
to build an agentic application.

978
00:43:06,450 --> 00:43:10,980
We spent a bunch of
time on the OAuth2 flow.

979
00:43:10,980 --> 00:43:13,020
We talked about Amazon
Verified Permissions.

980
00:43:13,020 --> 00:43:16,050
This is a lot of security stuff
that we wanna think through.

981
00:43:16,050 --> 00:43:19,260
Is there perhaps a simpler
way that we can do this?

982
00:43:19,260 --> 00:43:20,550
There is a simpler way,

983
00:43:20,550 --> 00:43:23,010
or perhaps an alternate way to do this.

984
00:43:23,010 --> 00:43:26,160
So again, in the keynote earlier today,

985
00:43:26,160 --> 00:43:28,770
there was a bunch of
announcements around AgentCore.

986
00:43:28,770 --> 00:43:30,630
So there are a couple of services

987
00:43:30,630 --> 00:43:31,770
to actually make this simpler.

988
00:43:31,770 --> 00:43:35,370
So AgentCore runtime
is a serverless runtime

989
00:43:35,370 --> 00:43:38,070
similar to Lambda, similar even to Fargate

990
00:43:38,070 --> 00:43:40,383
to be able to run your agent applications.

991
00:43:41,280 --> 00:43:44,340
On top of that is then something
called AgentCore Gateway,

992
00:43:44,340 --> 00:43:47,460
similar to API gateway where
API gateway is the front door

993
00:43:47,460 --> 00:43:49,680
for all of your API front ends.

994
00:43:49,680 --> 00:43:51,510
We think of AgentCore
gateway as a front end

995
00:43:51,510 --> 00:43:53,940
for all of your tools that
you're gonna then expose

996
00:43:53,940 --> 00:43:56,583
to your agent applications.

997
00:43:57,510 --> 00:44:01,020
There are a number of managed tools

998
00:44:01,020 --> 00:44:02,280
that you have available to you.

999
00:44:02,280 --> 00:44:05,100
So again, browser, if you
want your agents to be able

1000
00:44:05,100 --> 00:44:06,870
to go and do research on the internet,

1001
00:44:06,870 --> 00:44:09,480
maybe you want to hit
other websites to be able

1002
00:44:09,480 --> 00:44:12,090
to glean information
about the particular query

1003
00:44:12,090 --> 00:44:13,470
that the user is coming in,

1004
00:44:13,470 --> 00:44:15,420
you could use AgentCore browser.

1005
00:44:15,420 --> 00:44:18,930
Code interpreter is a situation
where maybe your agent

1006
00:44:18,930 --> 00:44:21,660
is actually gonna be
generating code on your behalf

1007
00:44:21,660 --> 00:44:22,950
and this is untrusted code.

1008
00:44:22,950 --> 00:44:25,050
You don't want to actually
run this within the context

1009
00:44:25,050 --> 00:44:25,883
of your...

1010
00:44:25,883 --> 00:44:26,850
Perhaps your enterprise,

1011
00:44:26,850 --> 00:44:28,740
you want this code to
be actually be isolated.

1012
00:44:28,740 --> 00:44:30,330
And this is where you might
actually use something

1013
00:44:30,330 --> 00:44:32,343
like AgentCore code interpreter.

1014
00:44:34,170 --> 00:44:35,310
Where we'll spend a little bit of time

1015
00:44:35,310 --> 00:44:36,990
in the next slide is AgentCore identity

1016
00:44:36,990 --> 00:44:39,840
where we think about all of
these OAuth considerations,

1017
00:44:39,840 --> 00:44:42,017
all of these security
considerations in this auth flow.

1018
00:44:42,017 --> 00:44:44,190
And is there a way that we
could actually make it simpler?

1019
00:44:44,190 --> 00:44:47,190
AgentCore identity aims to
make that process simpler.

1020
00:44:47,190 --> 00:44:50,220
And we're going to dive
into the next slide.

1021
00:44:50,220 --> 00:44:51,330
There's also AgentCore memory.

1022
00:44:51,330 --> 00:44:55,680
So in your experiences with
different agent applications,

1023
00:44:55,680 --> 00:44:58,320
one of the key experience benefits

1024
00:44:58,320 --> 00:45:01,380
that we've seen customers
wanting out of these applications

1025
00:45:01,380 --> 00:45:03,000
is this personalized experience.

1026
00:45:03,000 --> 00:45:05,970
So this desire to see,
hey, it actually remembers

1027
00:45:05,970 --> 00:45:09,120
that this is Heeki interacting
with this fitness application

1028
00:45:09,120 --> 00:45:11,310
and remembering even
some of the last queries

1029
00:45:11,310 --> 00:45:12,690
about the particular application.

1030
00:45:12,690 --> 00:45:15,270
So memory will allow
you to do some of that.

1031
00:45:15,270 --> 00:45:17,102
And then of course there's observability.

1032
00:45:17,102 --> 00:45:20,100
So observability will allow
you to understand the full flow

1033
00:45:20,100 --> 00:45:22,410
of the actions that are happening

1034
00:45:22,410 --> 00:45:24,000
within this particular application.

1035
00:45:24,000 --> 00:45:25,230
It will also give you an idea

1036
00:45:25,230 --> 00:45:27,450
of the type of login
activities and the tool calls

1037
00:45:27,450 --> 00:45:29,940
that are being made with this application.

1038
00:45:29,940 --> 00:45:32,580
But again, let's talk a little
bit more about identity,

1039
00:45:32,580 --> 00:45:35,850
and how we can actually
apply some of the OAuth flows

1040
00:45:35,850 --> 00:45:38,850
in this agentic application
in a simpler way.

1041
00:45:38,850 --> 00:45:42,450
So before we talked again
about maybe there's the user,

1042
00:45:42,450 --> 00:45:45,030
maybe there's the interacting
through the web browser,

1043
00:45:45,030 --> 00:45:46,710
and now we wanna actually interact

1044
00:45:46,710 --> 00:45:48,480
with this particular agent.

1045
00:45:48,480 --> 00:45:50,580
So on the front end side there's something

1046
00:45:50,580 --> 00:45:52,260
what we call inbound auth.

1047
00:45:53,610 --> 00:45:56,700
And the idea here is if
this is a application

1048
00:45:56,700 --> 00:45:59,160
perhaps running on an EC2 instance,

1049
00:45:59,160 --> 00:46:01,830
maybe it's actually being
invoked by a Lambda function,

1050
00:46:01,830 --> 00:46:04,530
we could probably use
something like IAM, so IAM,

1051
00:46:04,530 --> 00:46:06,690
you can then do all of the things

1052
00:46:06,690 --> 00:46:07,770
that Chris was talking about before.

1053
00:46:07,770 --> 00:46:10,230
So IAM basically defines
what are the actions

1054
00:46:10,230 --> 00:46:12,510
that this entity within
AWS is allowed to do.

1055
00:46:12,510 --> 00:46:15,330
So if there's an app
running in EC2, in Fargate,

1056
00:46:15,330 --> 00:46:17,310
or even in Lambda, that execution role

1057
00:46:17,310 --> 00:46:21,300
would allow us to invoke
this particular agent.

1058
00:46:21,300 --> 00:46:24,990
Alternatively, if it's
actually maybe external

1059
00:46:24,990 --> 00:46:27,540
to your organization, this is
not actually running in AWS,

1060
00:46:27,540 --> 00:46:29,700
this is running in your own infrastructure

1061
00:46:29,700 --> 00:46:31,710
and you don't have an IAM role associated

1062
00:46:31,710 --> 00:46:33,390
with that particular infrastructure,

1063
00:46:33,390 --> 00:46:35,010
you're likely gonna then use OAuth2,

1064
00:46:35,010 --> 00:46:37,113
which we went to in great depth.

1065
00:46:38,280 --> 00:46:39,990
Then we have what we call outbound auth.

1066
00:46:39,990 --> 00:46:41,940
And outbound auth is basically configured

1067
00:46:41,940 --> 00:46:44,880
based on whatever the
target might actually be.

1068
00:46:44,880 --> 00:46:47,550
So if your agent is going to be accessing,

1069
00:46:47,550 --> 00:46:50,670
let's say an S3 bucket, so if
your agent is gonna try and go

1070
00:46:50,670 --> 00:46:54,540
and extract additional
information out of PDF documents

1071
00:46:54,540 --> 00:46:58,470
in an S3 bucket, you'll just
use an IAM role for that.

1072
00:46:58,470 --> 00:47:00,960
So similar to what Chris
was talking about before,

1073
00:47:00,960 --> 00:47:02,790
depending on what you're
gonna be accessing

1074
00:47:02,790 --> 00:47:04,170
is what you're gonna
actually end up using.

1075
00:47:04,170 --> 00:47:07,380
So again, maybe an S3
bucket, maybe a Dynamo table,

1076
00:47:07,380 --> 00:47:09,960
maybe something else
within your AWS account,

1077
00:47:09,960 --> 00:47:14,430
this is where you'll use an IAM
role for your outbound auth.

1078
00:47:14,430 --> 00:47:15,630
Otherwise, for anything else,

1079
00:47:15,630 --> 00:47:17,010
you're gonna end up using OAuth2.

1080
00:47:17,010 --> 00:47:20,160
And this is why we spend a
bunch of time on that OAuth flow

1081
00:47:20,160 --> 00:47:21,510
to really help you understand

1082
00:47:21,510 --> 00:47:23,640
when are you gonna be using
those different flows.

1083
00:47:23,640 --> 00:47:25,650
So if you have an end user interacting

1084
00:47:25,650 --> 00:47:28,500
with a particular protected
endpoint, that's likely

1085
00:47:28,500 --> 00:47:30,630
where you're gonna be using
the code authorization flow.

1086
00:47:30,630 --> 00:47:32,700
And then if this is machine
to machine communication,

1087
00:47:32,700 --> 00:47:33,930
you're likely gonna be using something

1088
00:47:33,930 --> 00:47:35,733
like the client credentials flow.

1089
00:47:36,750 --> 00:47:41,750
Okay, so why don't we have a
couple, I guess, key takeaways

1090
00:47:42,480 --> 00:47:43,620
from this talk.

1091
00:47:43,620 --> 00:47:46,230
So the first thing that...

1092
00:47:46,230 --> 00:47:48,750
One of the things that Chris
talked about here is, again,

1093
00:47:48,750 --> 00:47:50,340
implementing least privileged policy.

1094
00:47:50,340 --> 00:47:54,360
So if ever you're writing a
policy in your AWS account

1095
00:47:54,360 --> 00:47:57,660
and there is a star there
in your policy document,

1096
00:47:57,660 --> 00:47:59,610
it should give you pause and think,

1097
00:47:59,610 --> 00:48:00,870
should I really be doing this?

1098
00:48:00,870 --> 00:48:04,470
Now that said, there are some
policies that do require star.

1099
00:48:04,470 --> 00:48:07,140
And so in that scenario,
sure that is okay,

1100
00:48:07,140 --> 00:48:11,250
but if you're gonna be accessing
a particular Dynamo table

1101
00:48:11,250 --> 00:48:12,960
or a particular S3 bucket,

1102
00:48:12,960 --> 00:48:16,410
you want to be as
explicit in the resource,

1103
00:48:16,410 --> 00:48:19,050
and you wanna be as explicit
in the particular actions

1104
00:48:19,050 --> 00:48:21,150
that you're allowing in that policy.

1105
00:48:21,150 --> 00:48:23,043
So again, least privileged policies.

1106
00:48:24,300 --> 00:48:25,860
Defense in depth, so we get...

1107
00:48:25,860 --> 00:48:29,220
Chris talked through a
lot of different ideas

1108
00:48:29,220 --> 00:48:32,280
in how you can actually secure
your serverless applications.

1109
00:48:32,280 --> 00:48:35,340
The idea here being don't just
apply one or two of these,

1110
00:48:35,340 --> 00:48:36,810
apply as many as possible.

1111
00:48:36,810 --> 00:48:39,330
So you're gonna use, you
know, IAM execution rules,

1112
00:48:39,330 --> 00:48:41,010
you're gonna use your
resource-based policies,

1113
00:48:41,010 --> 00:48:43,140
you're gonna use WAF to
protect your public endpoints.

1114
00:48:43,140 --> 00:48:45,180
You're gonna use SEPs to make sure

1115
00:48:45,180 --> 00:48:48,360
that developers aren't deploying
resources that don't comply

1116
00:48:48,360 --> 00:48:50,520
with organizational policies.

1117
00:48:50,520 --> 00:48:52,410
So there's a lot of different mechanisms

1118
00:48:52,410 --> 00:48:55,110
that you as an organization
can apply to ensure

1119
00:48:55,110 --> 00:48:58,023
that you have a secure
serverless application deployed.

1120
00:49:00,000 --> 00:49:02,010
Leverage the deep integrations across AWS,

1121
00:49:02,010 --> 00:49:04,320
and so one of the beautiful things

1122
00:49:04,320 --> 00:49:06,300
around building serverless applications,

1123
00:49:06,300 --> 00:49:08,310
whether these are synchronous APIs

1124
00:49:08,310 --> 00:49:10,080
or what we didn't spend a lot of time on

1125
00:49:10,080 --> 00:49:12,210
is like async event driven patterns.

1126
00:49:12,210 --> 00:49:14,550
The fact that AWS will
manage those integrations

1127
00:49:14,550 --> 00:49:16,830
on your behalf, and a lot of
times you're gonna configure

1128
00:49:16,830 --> 00:49:19,740
IAM roles or resource-based policies,

1129
00:49:19,740 --> 00:49:21,540
create those least privileged policies,

1130
00:49:21,540 --> 00:49:24,600
and let AWS do a lot of those
integrations on your behalf.

1131
00:49:24,600 --> 00:49:27,150
This helps kind of ease the burden

1132
00:49:27,150 --> 00:49:28,710
of a lot of the
undifferentiated heavy lifting

1133
00:49:28,710 --> 00:49:31,740
of configuring these
different integrations.

1134
00:49:31,740 --> 00:49:32,880
And last, you know,

1135
00:49:32,880 --> 00:49:34,950
automate these security
protection mechanisms, right?

1136
00:49:34,950 --> 00:49:37,170
So again, Chris talked
about things like GuardDuty,

1137
00:49:37,170 --> 00:49:40,020
so you can configure it so that
you get runtime protection.

1138
00:49:40,020 --> 00:49:42,810
In your CICD pipelines as
Chris talked about before,

1139
00:49:42,810 --> 00:49:46,050
you can implement a bunch
of these protections,

1140
00:49:46,050 --> 00:49:47,700
whether you're on the developer machine,

1141
00:49:47,700 --> 00:49:49,770
whether you're committing
code to a repository,

1142
00:49:49,770 --> 00:49:51,600
and triggering your CI actions

1143
00:49:51,600 --> 00:49:53,670
or even as you're deploying
into your environments,

1144
00:49:53,670 --> 00:49:55,530
you wanna make sure
that all of these checks

1145
00:49:55,530 --> 00:49:58,230
are being included as part
of that deployment process.

1146
00:49:59,670 --> 00:50:02,130
Okay, so I think that concludes.

1147
00:50:02,130 --> 00:50:04,500
We have a number of other
sessions that we wanna recommend

1148
00:50:04,500 --> 00:50:06,540
that you go take a look at.

1149
00:50:06,540 --> 00:50:08,880
These are a bunch that are really relevant

1150
00:50:08,880 --> 00:50:10,140
for as you're thinking about building,

1151
00:50:10,140 --> 00:50:12,480
and securing your serverless applications.

1152
00:50:12,480 --> 00:50:14,100
There are a number of other resources

1153
00:50:14,100 --> 00:50:15,330
that are available to you.

1154
00:50:15,330 --> 00:50:17,160
So these are some resources

1155
00:50:17,160 --> 00:50:19,710
that we recommend you go check out.

1156
00:50:19,710 --> 00:50:23,493
And with that we wanna
say thank you for coming.

