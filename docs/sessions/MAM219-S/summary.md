# AWS re:Invent 2025 会议总结：使用 Agentic AI 框架实现遗留系统现代化

## 会议概述

本次会议由 Emphasis AI 的 CTO Anup Nyer 和高级合伙人 Barat 主讲，重点介绍了如何利用 Agentic AI 框架解决企业遗留系统现代化的难题。演讲者指出，过去 25 年来，几乎所有 CIO 都面临同样的困境：由于遗留平台风险太高而无法快速创新。许多企业拥有基于 COBOL 大型机构建的核心系统，这些系统相互依赖，牵一发而动全身。传统的现代化方法只是将代码从一种语言转换为另一种语言（如 COBOL 转 Java），但这种方法在 3 年后又会产生新的遗留系统。

Emphasis AI 提出了一种革命性的方法：不仅仅是技术现代化，而是将遗留系统中的业务智能提取出来并转化为数据。他们开发了一套由多个 AI 代理组成的框架，包括 NeoZeta（学习代理）、NeoSaba（业务分析代理）、NeoReena（架构代理）、NeoKrux（代码生成代理）和 NeoOps（运维代理）。这些代理通过企业知识图谱 Ontosphere 连接，形成了一个完整的现代化解决方案。演讲中展示了实际案例，将复杂的交易后处理系统从 COBOL 迁移到基于 Flink 的现代架构，并对比了 CPU 和 GPU 的性能差异。

## 详细时间线与关键要点

00:00:00 - 开场介绍
- Anup Nyer 介绍自己是 Emphasis AI 的 CTO
- Barat 介绍自己是 Emphasis AI 的高级合伙人
- 会议主题：使用 Agentic AI 框架实现遗留系统现代化

00:01:00 - 问题陈述
- 过去 25 年中每位 CIO 面临的共同问题：因遗留平台风险过高而无法快速创新
- 实际案例：某企业拥有 49 个基于 COBOL 大型机的核心系统，修改一个就需要修改其余 48 个
- 遗留系统阻碍了企业的 Agentic AI 创新目标

00:02:30 - 遗留系统的核心问题
- 业务逻辑嵌入在 COBOL、Java、Natural、Adabas 或汇编语言代码中多年
- 需要专业工程师处理，但这些工程师在市场上已不易获得
- 不断重复造轮子，产生大量技术债务
- 任何变更成本都很高，因为需要在多个地方进行修改
- 遗留系统的单体架构使得 AI 代理难以提高生产力

00:04:00 - Emphasis AI 的解决方案理念
- 现代化不仅仅是技术转换（COBOL 转 Java）
- 核心目标：将遗留系统中的智能提取出来并转化为数据
- 避免 3 年后再次产生遗留系统的循环

00:05:00 - 传统现代化方法的四个步骤
- 重新学习（Relearn）遗留系统
- 重新构想（Reimagine）
- 重新架构（Rearchitect）
- 重新编码（Recode）并运行

00:06:00 - Emphasis AI 的 Agentic 框架
- 构建了自主和半自主的 AI 代理（需要人工参与）
- **NeoZeta**：读取文档和代码，将其转换为人类可理解的知识，使用领域知识创建知识图谱
- **NeoSaba**（半自主业务分析师）：从知识图谱生成用户故事，关注治理、合规和业务流程
- **NeoReena**：帮助定义目标状态架构，可定制以符合企业标准
- **NeoKrux**：使用企业中可用的编码代理生成代码
- **NeoOps**：处理运维操作

00:08:00 - Ontosphere 企业知识图谱
- 作为连接组织的核心，提取整个系统的智能
- 不仅仅是数据库，而是具有企业意义的知识图谱
- 与企业领域知识相连接
- 使用编排层使整个过程尽可能自主化

00:09:00 - 演示内容预告
- 将展示 NeoZeta、NeoSaba、NeoReena、NeoKrux 和 Ontosphere
- 由于时间限制，不展示 AI Ops

00:09:30 - Ontosphere 演示
- Ontosphere 是所有知识的核心存储位置
- 使用金融行业、保险等领域的本体论
- 包含工程本体论，作为代理建模的基础

00:10:30 - NeoZeta 代理演示
- 选择了交易后处理（Post-trade Processing）这一复杂能力作为案例
- 该流程在下午 4 点停止，需要处理数百万笔交易并向联邦机构发送文件
- 从 COBOL 代码中提取智能，逆向工程后使用代理将其现代化为基于 Flink 的架构

00:11:30 - 上传和处理文件
- 上传 COBOL 程序、Copy Books 和领域模型
- 使用 Relearn 代理对每个程序或整个能力进行重新学习
- 对选定的程序（Quantiles）及其 Copy Books 进行逆向工程

00:12:30 - 数据字典生成
- 系统自动生成数据字典
- 将信息映射到实际功能属性
- 生成包含摘要和业务规则的文档

00:13:30 - 业务规则文档
- 为每个业务规则提供数据元素、逻辑、输入、受影响的数据和其他处理元素
- 使用 LLM 作为评判者验证准确性
- 为每个规则提供置信度分数

00:14:30 - 准确性验证
- 某个规则的覆盖率为 85%（被视为平均水平）
- 95% 以上被认为是更好的覆盖率
- 提供人工干预界面进行修正
- 前 10 万行代码通常需要修正，之后的百万行代码可达到 95% 的自动化准确率

00:15:30 - 输出内容
- 生成数据字典
- 生成业务规则
- 进行业务规则验证
- 将所有内容转换到 Ontosphere 知识图谱

00:16:30 - 能力级别视图
- 可以逐个程序处理，也可以处理整个能力
- 对于包含多个程序和流程的大型作业，提供整体视图
- 展示整个智能提取过程

00:17:00 - 知识图谱可视化
- 展示逆向工程的程序及其关联的领域模型
- 可以深入查看函数、属性和信息
- 用于验证目的

00:18:00 - NeoSaba 代理演示
- 第一个代理的信息传递到第二个代理
- 所有信息作为业务流程的一部分呈现
- 之前的图谱现在以工作流形式呈现

00:19:00 - 应用重新构想
- 可以按业务规则查看，合并多个业务规则创建新规则
- 顶部显示应用的整体敏捷重建模型
- 完全重新构想，而非简单的迁移
- 帮助业务系统分析师定义史诗、功能和用户故事

00:20:00 - 用户故事质量评估
- 通过 INVEST 评分评估每个用户故事的质量
- 提供提示机制生成验收标准
- 生成 Gherkin 输出，在此阶段创建 BDD（行为驱动开发）
- 质量保证从这个阶段开始

00:21:00 - 提示功能
- 如果不符合 INVEST 标准，可以进一步分解为多个规则

00:21:30 - NeoReena 代理演示（第三个代理）
- 重新架构或重新设计
- 需要两个输入：逆向工程步骤的 Playbook 和要使用的标准
- 提供所有信息：逻辑模型、物理模型、序列图、可观察性模式
- 根据输入的标准生成所有内容

00:23:00 - 架构生成
- 为下一个开发代理构建整个上下文并准备提示
- 演示中使用 Java Flink 模型生成
- 提供 Playbook 和必须使用的标准
- 使用数据工程架构和 Flink Playbook
- 生成整个上下文和所有信息

00:24:00 - NeoKrux 代理演示（第四个代理）
- 代码生成代理
- 获取所有信息并从 Java Flink 架构角度生成代码
- 展示在 GPU 和 CPU 上运行的示例
- 显示运行时间的显著差异

00:25:00 - GPU vs CPU 性能对比
- 针对多组交易进行建模
- 示例：从 20,000 笔交易增加到 100,000 笔交易
- 比较 CPU 和 GPU 的成本
- 帮助客户从作业角度做出决策

00:26:00 - 成果展示
- 典型的现代化项目：5000 万行代码通常需要 7 年时间
- Emphasis AI 显著缩短了这一时间
- 最重要的成果（无限符号∞）：整个智能转化为数据并永久保存，不再产生遗留系统

00:27:00 - 差异化优势
- 许多公司只是将 A 迁移到 B
- 很少有公司能提取智能并确保永远不再产生遗留系统
- Emphasis AI 的独特价值主张

00:27:30 - 技术补充说明
- 代理在 Databricks 上运行
- 可以高度扩展
- 持续进行测量和监控

00:28:00 - 会议结束
- 演讲者感谢听众
- 时间到，会议结束