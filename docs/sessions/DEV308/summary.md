# AWS re:Invent 2025 DEV308 会议总结

## 会议概述

本次会议由AWS解决方案架构师Alexi Vanchenko和AWS Serverless Hero、IPLs开发主管Vadim Kazulkin共同主讲，深入探讨了如何使用Amazon Aurora DSQL构建现代应用程序。会议重点介绍了Aurora DSQL这一全新的serverless数据库服务，它旨在解决传统关系型数据库在serverless架构中的痛点，同时提供类似DynamoDB的无服务器体验和关系型数据库的ACID事务保证。

Aurora DSQL采用了创新的分布式解耦架构，将传统单体OLTP数据库的关键组件分离为独立服务，包括连接管理、查询处理、隔离执行、事务日志和存储层。这种架构使得数据库能够实现真正的弹性扩展，无需管理任何基础设施，支持多区域强一致性写入，并提供五个9的可用性保证。会议还详细演示了如何通过Java代码连接和使用DSQL，包括基于令牌的身份验证机制和性能测试结果。

## 详细时间线

### 开场介绍 (00:00 - 02:30)
- **00:00** - 会议开始，Alexi Vanchenko介绍自己是AWS解决方案架构师
- **00:30** - 介绍Vadim Kazulkin，IPLs开发主管和AWS Serverless Hero
- **01:00** - 说明解决方案架构师的主要目标是帮助客户扩展业务和现代化工作负载
- **01:30** - 概述会议议程：深入探讨Aurora DSQL的构建模块、架构、代码示例、性能和挑战
- **02:00** - 强调这是300级别的技术会议，将包含代码示例

### 现有数据库服务分析 (02:30 - 08:00)
- **02:30** - Vadim提出问题：为什么需要另一个serverless数据库
- **03:00** - 介绍AWS现有数据库产品：DynamoDB、RDS、Aurora Provisioned和Aurora Serverless V2
- **03:30** - DynamoDB优势：完美适配serverless工作负载，无基础设施管理，毫秒级性能
- **04:00** - DynamoDB挑战：NoSQL数据库设计思维不同，最终一致性，事务限制
- **04:30** - RDS局限性：需要大量基础设施工作（VPC、安全组），无法独立扩展计算和存储
- **05:30** - RDS连接管理挑战：Lambda函数大规模并发时可能耗尽数据库连接
- **06:00** - Aurora Provisioned：可以独立扩展存储，但其他限制与RDS类似
- **06:30** - Aurora Serverless V2：自动扩展计算和存储，可选VPC，支持扩展到零
- **07:00** - Aurora Serverless V2的缺点：扩展到零后启动需要15秒，会丢失缓存
- **07:30** - 提出核心问题：能否拥有像DynamoDB一样serverless但提供关系型数据库ACID特性的服务

### Aurora DSQL介绍 (08:00 - 12:00)
- **08:00** - 介绍Aurora DSQL：去年re:Invent发布，今年年中正式可用
- **08:30** - DSQL核心特性：完全serverless，无需管理基础设施，提供五个9可用性
- **09:00** - 独立扩展计算和存储，独立扩展读写，提供几乎无限的扩展能力
- **09:30** - 在所有扩展过程中保持强一致性
- **10:00** - DSQL适用场景：需要多区域ACID事务、serverless架构、微服务设计
- **10:30** - 适合事件驱动应用、流量波动不可预测的场景
- **11:00** - 支持继续使用现有SQL工具和技能
- **11:30** - 开始深入讲解DSQL的设计架构

### 单区域集群架构 (12:00 - 16:00)
- **12:00** - 单区域集群是跨多个可用区的主-主多写入集群
- **12:30** - 数据跨三个可用区复制，读写使用单一端点
- **13:00** - 无需预置实例，所有请求直接发送到数据库
- **13:30** - 无需停机进行补丁和更新，单区域提供四个9可用性
- **14:00** - 采用分布式解耦架构，而非隐藏的PostgreSQL实例
- **14:30** - 将单体OLTP数据库的关键组件分离为独立服务
- **15:00** - 五大核心组件：连接管理、查询处理、隔离执行、事务日志、存储
- **15:30** - 每个组件独立工作，针对特定角色优化，可独立扩展

### 多区域集群架构 (16:00 - 18:00)
- **16:00** - 多区域集群提供五个9可用性和多区域一致性写入
- **16:30** - 提供两个区域端点，都支持并发读写
- **17:00** - 作为单一逻辑数据库呈现
- **17:30** - 引入见证区域（witness region）作为仲裁者，参与写入仲裁
- **17:45** - 见证区域在网络分区时决定哪个区域可以继续写入

### 核心组件详解 (18:00 - 22:00)
- **18:00** - 前端（Front End）：处理连接
- **18:30** - 查询处理器（Query Processor）：执行大部分SQL处理工作
- **19:00** - 每个事务都有专用的PostgreSQL引擎，可以有任意多个查询处理器
- **19:30** - 裁决器（Adjudicator）：决定事务是否可以提交，遵循隔离规则
- **20:00** - 每个分片键在任何时刻只由一个裁决器拥有
- **20:30** - 日志（Journal）：使事务持久化，在可用区和区域间复制数据
- **21:00** - 交叉栏（Crossbar）：合并数据流并导向存储节点
- **21:30** - 存储节点：提供数据访问，保存多个副本，基于数据库键包含特定数据范围

### 读事务流程演示 (22:00 - 26:00)
- **22:00** - 使用披萨订购服务示例演示读事务
- **22:30** - 执行查询：SELECT  FROM restaurants WHERE rating >= 4.0
- *23:00** - 应用连接到DSQL前端，前端分配查询处理器
- **23:30** - 查询处理器读取本地时钟设置事务开始时间
- **24:00** - 只读事务自动开始，存储根据数据库键自动分区
- **24:30** - 查询处理器查询分片映射了解数据位置
- **25:00** - 只读事务直接访问存储，无需经过裁决器或日志
- **25:30** - 存储节点返回行而非页面，支持谓词下推、过滤和聚合
- **26:00** - 显著减少网络传输数据量和查询处理器工作量

### 写事务和交互式事务 (26:00 - 32:00)
- **26:00** - 读操作始终是本地的，查询处理器访问同一可用区的存储节点
- **26:30** - 介绍交互式事务：开始事务、执行工作、多次往返、最终提交
- **27:00** - 披萨订购示例：选择餐厅、浏览菜单、选择商品、添加到订单、下单提交
- **27:30** - 传统数据库每个语句都需要跨区域检查和记录日志，增加延迟
- **28:00** - 查询处理器作为"暂存区"，保存事务中的所有语句
- **28:30** - 从本地存储读取数据并保存到本地内存
- **29:00** - 写入数据时修改内存中的本地数据，累积所有更改
- **29:30** - 等待提交时才进入写入路径，将完整事务发送给裁决器
- **30:00** - 查询处理器在Firecracker轻量级虚拟机（microVM）中运行
- **30:30** - 单个裸机主机可运行数千个预置的microVM
- **31:00** - 每个查询处理器完全独立和隔离，彼此不通信
- **31:30** - 自动扩展microVM以处理工作负载

### 隔离级别和MVCC (32:00 - 36:00)
- **32:00** - 支持快照隔离（Snapshot Isolation）事务级别隔离
- **32:30** - 每个事务在数据库的一致快照上操作
- **33:00** - 事务开始时的快照状态贯穿整个SQL执行路径
- **33:30** - 使用多版本并发控制（MVCC）实现读取
- **34:00** - 存储引擎保留同一行的多个版本
- **34:30** - 允许访问旧版本同时不阻塞创建新版本
- **35:00** - 写操作不立即应用到存储，查询处理器将更改缓存到本地内存
- **35:30** - 为事务创建私有工作空间，支持读取自己的写入能力

### 事务提交和裁决器 (36:00 - 42:00)
- **36:00** - 事务提交时，DSQL需要确定更改是否可以应用到存储
- **36:30** - 裁决器位于写入路径，决定事务是否可以提交
- **37:00** - 裁决器检测和解决事务间冲突，确保一致性写入
- **37:30** - 查询处理器形成负载（payload）发送给裁决器
- **38:00** - 负载包含：写入集（修改的项）、后镜像集（应用更改后的表行副本）
- **38:30** - 包含事务开始时间戳，这对决定提交或中止至关重要
- **39:00** - 两个事务示例：事务A和B几乎同时开始，A略早提交
- **39:30** - 裁决器分析两个事务的负载，检查写入集和开始时间
- **40:00** - 查找开始时间后的所有更改，寻找重叠或匹配的行
- **40:30** - 如果两个事务修改同一行，后提交的事务B被中止
- **41:00** - 事务A被允许继续并分配提交时间戳
- **41:30** - 如果写入集不重叠或不冲突，两个事务都可以提交

### 持久性和日志系统 (42:00 - 46:00)
- **42:00** - 传统数据库在存储层实现持久性
- **42:30** - 事务只有在持久写入存储后才被视为已提交
- **43:00** - 传统方式需要检查点、日志记录、内存与存储同步协调
- **43:30** - 这些增加了大量延迟和系统复杂性
- **44:00** - DSQL使用日志（Journal）管理复杂性
- **44:30** - 日志是为DSQL专门编写的内部组件，优化了跨多个可用区和区域的有序数据复制
- **45:00** - 日志水平扩展，事务可以进入任何日志实例
- **45:30** - 日志协调维护已提交事务的有序流

### 交叉栏和存储写入 (46:00 - 48:00)
- **46:00** - 交叉栏从日志拉取更改，将事务路由到存储
- **46:30** - 使用顺序确保所有事务按正确顺序写入存储
- **47:00** - 裁决器决定提交后，将负载和提交时间戳发送到日志
- **47:30** - 日志确认写入后，事务持久化并原子性提交
- **48:00** - 日志向查询处理器返回成功代码，交叉栏开始从日志拉取数据写入存储

### 时间同步服务 (48:00 - 50:00)
- **48:00** - 查询处理器向用户返回成功代码，事务成功提交
- **48:30** - 强调两个关键组件：开始时间戳（T_start）和提交时间戳（T_commit）
- **49:00** - 没有时间同步无法实现强一致性
- **49:30** - 需要可信赖的参考时钟来协调事务
- **50:00** - 引入Amazon Time Sync Service，配备专用计时硬件
- **50:30** - 跨AWS和AWS Nitro系统部署GPS授时参考时钟
- **51:00** - 在EC2和DSQL中提供微秒级精度的全球同步时钟

### 身份验证机制 (50:00 - 56:00)
- **50:00** - Vadim开始讲解开发者视角的DSQL使用
- **51:00** - 传统关系型数据库使用用户名和密码认证
- **51:30** - 密码认证存在安全风险，需要定期轮换
- **52:00** - DSQL不使用密码，而是使用令牌（token）进行身份验证
- **52:30** - 令牌由AWS SDK使用本地加密生成，类似于S3和DynamoDB的机制
- **53:00** - 令牌生命周期非常短，即使被拦截也可能已过期
- **53:30** - 演示使用AWS CLI生成令牌：aws dsql generate-db-connect-admin-auth-token
- **54:00** - 提供主机名和过期时间参数
- **54:30** - 将令牌导出为环境变量PG_PASSWORD，用于psql连接
- **55:00** - 可在DBeaver等工具中使用令牌代替密码
- **55:30** - DSQL团队发布了集成的浏览器SQL编辑器，自动处理令牌生成

### 创建DSQL集群演示 (56:00 - 58:00)
- **56:00** - 演示创建Aurora DSQL单区域集群的简易性
- **56:30** - 与RDS相比，创建界面没有滚动条，选项极少
- **57:00** - 只需提供集群名称，其他都已配置好
- **57:30** - 可选启用删除保护、自定义加密设置、添加标签
- **58:00** - 多区域集群稍复杂，需要选择另一个区域和见证区域

### Java代码示例 (58:00 - 66:00)
- **58:00** - 询问观众是否理解Java代码，大多数举手
- **58:30** - 使用披萨订购应用的订单部分作为示例
- **59:00** - 架构包含API Gateway和多个Lambda函数：创建订单、按ID获取订单、按时间范围获取订单
- **59:30** - 数据存储在Aurora DSQL中
- **60:00** - 使用AWS SAM定义基础设施（也可用SDK、CloudFormation或Terraform）
- **60:30** - 传递Aurora DSQL集群ID作为环境变量
- **61:00** - 创建Aurora DSQL集群端点，遵循固定模式
- **61:30** - 将端点导出为所有Lambda函数的环境变量
- **62:00** - Java代码通过System.getenv获取环境变量
- **62:30** - 使用JDBC协议连接数据库：jdbc:postgresql://
- **63:00** - 配置IAM授权，允许Lambda函数访问Aurora DSQL
- **63:30** - 提供资源ARN，使用集群ID作为变量
- **64:00** - 推荐使用服务器端连接池（如HikariCP）
- **64:30** - 适用于所有编程语言（Java、Python等）
- **65:00** - 创建连接仍有成本，连接可能过期需要重新获取
- **65:30** - Lambda单线程应用只需一个连接

### 令牌生成代码 (66:00 - 70:00)
- **66:00** - 展示获取连接的逻辑
- **66:30** - 两处需要获取令牌：创建连接池时和每次获取连接时
- **67:00** - 使用Aurora DSQL SDK生成令牌
- **67:30** - 创建GenerateDbConnectAdminAuthTokenRequest，提供端点和过期时间
- **68:00** - 将生成的令牌设置为密码
- **68:30** - 这是样板代码，需要在两个地方重复
- **69:00** - 唯一的AWS SDK依赖就是获取令牌，其他都是标准JDBC代码
- **69:30** - 可以重用现有代码，便于数据库迁移

### DSQL连接器 (70:00 - 74:00)
- **70:00** - AWS团队发布了连接器（Connector）简化令牌管理
- **70:30** - 首先支持Java，现在也支持Python和Node.js
- **71:00** - Python支持psycopg和psycopg2驱动
- **71:30** - Node.js支持node-postgres和postgres.js驱动
- **72:00** - 添加连接器依赖到依赖管理
- **72:30** - 代码中移除所有令牌生成逻辑，变成纯JDBC代码
- **73:00** - 唯一的DSQL依赖是JDBC URL中的"aws-dsql"标识
- **73:30** - 连接器自动拦截并生成令牌代替密码
- **74:00** - 大幅提高代码可读性和可维护性

### ORM框架支持 (74:00 - 76:00)
- **74:00** - DSQL与常见对象关系映射（ORM）框架良好兼容
- **74:30** - 可以使用实体注解，如@Column映射数据库列
- **75:00** - Java支持Hibernate
- **75:30** - Python支持SQLAlchemy和Django
- **76:00** - 无需更改现有ORM代码

### 性能测试说明 (76:00 - 80:00)
- **76:00** - 开始讨论数据库性能
- **76:30** - 测试目标：从Lambda函数角度测量性能
- **77:00** - 使用Java作为编程语言
- **77:30** - 只关注热启动时间，不关注冷启动
- **78:00** - 只关注P99百分位数，排除编程语言影响
- **78:30** - 对单区域和多区域集群都进行了性能测试
- **79:00** - 明确不是目标：不比较不同数据库（RDS、DynamoDB、Aurora等）
- **79:30** - 不测试大规模性能（每秒数万事务）
- **80:00** - 不测试扩展时的性能，扩展在后台自动发生

### 测试场景和数据结构 (80:00 - 84:00)
- **80:00** - 使用订单应用进行测试
- **80:30** - 数据库结构非常简单：只有两个表（order和order_items）
- **81:00** - order表：order_id作为主键，包含created时间戳等字段
- **81:30** - order_items表：包含product_id等字段
- **82:00** - 在items表上有两个索引：order_id索引（按订单ID获取商品）
- **82:30** - 在order表的时间戳上有索引（按时间范围查询订单）
- **83:00** - 没有用户表和产品表，保持简单
- **83:30** - 第一个测试：创建包含两个商品的订单
- **84:00** - 一个事务中执行三次插入：一次插入order表，两次插入order_items表

### 性能测试结果 (84:00 - 结束)
- **84:00** - 展示P90性能结果（90%的情况下不会比这个结果差）
- **84:30** - 开始展示具体的性能数据和图表
- **85:00** - 会议继续讨论更多性能指标和测试结果

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━


注：由于提供的字幕在性能测试结果部分被截断，完整的性能数据和会议结尾部分未包含在此总结中。