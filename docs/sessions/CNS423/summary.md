# AWS re:Invent 2025 Lambda 深度解析会议总结

## 会议概述

本次会议由AWS Lambda团队的开发者倡导者Julian和首席工程师Rajesh Pande共同主讲，深入探讨了AWS Lambda服务的内部架构和设计理念。Julian在AWS无服务器团队工作，专注于帮助开发者利用Lambda构建应用程序。Rajesh在Lambda团队已有6年时间，见证了Lambda从数千客户增长到数百万客户的历程。

会议延续了往年re:Invent大会"Lambda揭秘"系列的传统，旨在帮助开发者更深入地理解Lambda的工作原理。演讲者强调，虽然Lambda的魔力在于用户无需了解这些底层细节就能使用服务，但理解其工作机制有助于更好地利用这项服务。会议内容分为两大部分：Julian首先介绍了Lambda的基础知识、各种调用方式以及轮询功能；随后Rajesh深入探讨了Lambda的构建过程、设计决策以及轮询器的详细工作原理。

Lambda目前每月处理超过15万亿次调用，仅Prime Day当天就达到1.7万亿次调用，服务可用性高达99.99%。会议还介绍了最新发布的Lambda托管实例功能，该功能将Lambda的操作简便性与EC2的实例选择范围相结合，可为大规模工作负载节省高达12%的成本。

## 详细时间线

### 开场介绍 (0:00-2:30)
- **0:00** - Julian自我介绍，AWS无服务器团队开发者倡导者
- **0:30** - Rajesh Pande介绍，Lambda首席工程师，在Lambda团队工作6年
- **1:00** - Rajesh分享Lambda从数千客户增长到数百万客户的历程
- **1:30** - 会议议程介绍：Lambda基础知识、调用方式、轮询功能及深度架构分析

### Lambda基础与规模 (2:30-5:00)
- **2:30** - 揭秘"无服务器"的最大秘密：底层实际有数十万台服务器
- **3:00** - Lambda的核心价值：AWS管理所有底层基础设施，用户只需关注业务代码
- **3:30** - Lambda处理的复杂性：自动扩展、可用区故障转移、重试逻辑、连接池、背压、租约管理等
- **4:00** - Lambda规模数据：每月超过15万亿次调用
- **4:20** - Prime Day单日1.7万亿次调用
- **4:40** - 99.99%的可用性和内置弹性

### Lambda技术基础 (5:00-8:00)
- **5:00** - Lambda的技术基础：开源Firecracker
- **5:30** - 新发布：Lambda托管实例，结合Lambda简便性与EC2实例范围
- **6:00** - Lambda托管实例特性：可选择Graviton、CPU、内存或网络优化实例
- **6:30** - 成本优势：大规模工作负载节省高达12%，支持多并发和EC2定价优惠
- **7:00** - 架构对比：传统Lambda在Lambda服务VPC中运行，托管实例在客户账户VPC中运行
- **7:30** - 相关会议推荐：CNS 382

### Lambda调用类型 (8:00-11:00)
- **8:00** - 同步调用：调用者直接调用或通过API Gateway，等待响应后返回
- **8:40** - 异步调用：客户端调用或通过S3变更通知、EventBridge规则触发，不等待响应
- **9:20** - 异步调用流程：事件放入内部队列，Lambda返回成功响应，后台单独处理
- **10:00** - 事件源映射：Lambda资源从流（Kinesis、DynamoDB）或队列（SQS）读取消息
- **10:40** - Lambda管理轮询器读取消息并发送到函数进行处理

### Lambda API与数据平面 (11:00-14:30)
- **11:00** - Lambda API：所有请求的前端入口，多可用区负载均衡器
- **11:30** - 请求路由：将调用请求路由到数据平面，最终到达工作主机
- **12:00** - 前端负载均衡器区分控制平面请求和调用请求
- **12:30** - 数据平面分离：同步调用服务和异步调用服务独立
- **13:00** - 架构决策：分离数据平面以防止异步洪峰影响同步服务
- **13:30** - 数据平面为无状态主机集群，Lambda是多可用区服务
- **14:00** - 性能优化：函数版本信息缓存在主机和L2可用区缓存中

### 同步调用路径详解 (14:30-19:00)
- **14:30** - 负载均衡器将调用请求分发到同步调用服务主机集群
- **15:00** - 身份验证和授权：确保只有授权调用者可以访问Lambda
- **15:30** - 元数据加载和配额检查
- **16:00** - 计费服务：检查配额限制和预留并发，延迟低于1.5毫秒
- **16:30** - 分配服务：协调执行环境的创建和管理
- **17:00** - 放置服务：在工作主机上创建执行环境，基于时间的租约
- **17:30** - 初始化路径：提供IAM角色、环境变量，启动运行时，下载函数代码
- **18:00** - 后续请求：直接路由到现有执行环境，避免初始化开销
- **18:30** - 租约管理：租约到期或出错时，逐步排空连接并关闭执行环境

### Lambda工作主机架构 (19:00-23:00)
- **19:00** - 工作主机：标准裸机EC2实例
- **19:30** - 性能优化：预先维护不同内存大小的空microVM池
- **20:00** - 快速分配：收到调用时分配最小满足需求的内存大小
- **20:30** - Firecracker架构：管理单个安全执行环境的进程
- **21:00** - 沙箱隔离：函数代码、运行时、扩展的特权容器命名空间
- **21:30** - 管理沙箱：用户代码无法访问，用于管理执行环境
- **22:00** - 架构重构：今年完全重新设计执行环境架构
- **22:30** - 无缝升级：数万亿次调用中平滑升级，用户无感知

### 工作主机组件 (23:00-25:30)
- **23:00** - 主机管理：协调其他服务，构建和销毁执行环境
- **23:30** - 调用代理：前端到代码的直接链接
- **24:00** - 缓存机制：存储microVM文件、运行时二进制、容器镜像
- **24:30** - 外部连接：容器镜像块平面、S3（用于zip包）
- **25:00** - Lambda托管实例：使用containerd而非Firecracker，容器而非microVM

### 异步调用架构 (25:30-29:00)
- **25:30** - 异步服务架构：类似同步服务，但只处理异步事件请求
- **26:00** - 负载大小提升：最近增加到1MB
- **26:30** - 内部队列：前端将调用请求发送到内部SQS队列
- **27:00** - 快速响应：向调用者返回确认，Lambda将异步调用函数
- **27:30** - 队列管理：Lambda管理SQS队列，用户不可见
- **28:00** - 动态扩展：根据负载和函数并发动态扩展队列数量
- **28:30** - 队列策略：部分队列共享，部分事件使用专用队列以减少延迟

### 异步轮询机制 (29:00-32:00)
- **29:00** - 轮询器集群：Lambda管理的轮询实例集群
- **29:30** - 消息处理：从内部SQS队列读取消息，确定函数、账户和负载
- **30:00** - 同步转换：最终将异步调用转换为同步调用发送到同步调用服务
- **30:30** - 所有Lambda调用最终都是同步路径
- **31:00** - 重试机制：失败时不删除消息，使用可见性超时，轮询器可重试
- **31:30** - 事件目标：可配置异步调用的成功或失败回调

### 异步控制平面服务 (32:00-34:00)
- **32:00** - 队列管理器：监控队列积压，创建和删除队列
- **32:30** - 租约服务：管理轮询器处理哪些队列
- **33:00** - 故障检测：检测轮询器故障并将工作转移到其他轮询器
- **33:30** - 服务协调：队列管理器与租约服务协同工作

### 事件源映射 (34:00-37:30)
- **34:00** - 生产者应用：异步将消息放入流或队列
- **34:30** - 不同轮询器：根据事件源使用不同客户端
- **35:00** - 架构相似性：与异步调用架构非常相似
- **35:30** - 消息处理：读取、过滤、批处理消息，发送到函数
- **36:00** - 队列消息删除：函数成功处理后删除队列消息
- **36:30** - 调用响应目标：支持SQS、SNS、EventBridge、S3，最近新增Kafka
- **37:00** - 控制平面服务：状态管理器、流跟踪器管理轮询器和事件源

### 队列与流的区别 (37:30-40:00)
- **37:30** - 队列：独立任务处理，消息处理后删除
- **38:00** - 流：多消费者场景，顺序重要，消息可重放
- **38:30** - ESM功能：过滤、批处理控制、批次拆分（用于流）
- **39:00** - 流起始位置：可选择从何处开始读取流
- **39:30** - 重试和故障处理、Kinesis分析、平台性能配置
- **40:00** - Lambda ESM优势：处理所有差异，用户只需配置

### ESM深度功能 (40:00-45:00)
- **40:00** - 事件源轮询：从队列或流拉取可用记录
- **40:30** - 网络考虑：SQS和Kinesis在公共端点，Kafka可能在私有子网或AWS外部
- **41:00** - VPC连接：函数可能连接到VPC
- **41:30** - 身份验证：AWS服务使用IAM，Kafka支持所有授权方法
- **42:00** - 顺序保证：SQS FIFO和流源始终保持消息处理顺序
- **42:30** - 流起始位置配置：从头开始、特定时间戳或最新记录
- **43:00** - 偏移量管理：ESM记住流中的位置（偏移量或序列号）
- **43:30** - 重新分片处理：流可以增长或收缩，需要持续监控
- **44:00** - 新分片发现：检测新Kafka代理或新分片/分区
- **44:30** - 父分片拆分：创建子分片时保持顺序

### Kinesis特殊功能 (45:00-48:30)
- **45:00** - 滚动窗口：用于数据聚合的有用设置
- **45:30** - 跨调用状态传递：实时聚合数据的快速替代方案
- **46:00** - 共享扇出：最多5个消费者共享流的读取吞吐量
- **46:30** - 共享扇出限制：每个分片支持特定读取速率和数据速率，延迟约200毫秒
- **47:00** - 增强扇出（EFO）：更快的流数据响应
- **47:30** - EFO机制：从ESM拉取改为Kinesis推送到ESM
- **48:00** - EFO性能：使用HTTP推送机制，延迟低至70毫秒
- **48:30** - 透明管理：ESM自动处理逻辑流变化

### 专用轮询器 (48:30-51:00)
- **48:30** - 专用轮询器：SQS和Kafka最近支持，SQS也支持
- **49:00** - 预配置轮询器：提前配置事件轮询器以处理峰值
- **49:30** - 配置选项：最小和最大轮询器数量，控制吞吐量
- **50:00** - 性能提升：SQS轮询扩展和吞吐量提升16倍
- **50:30** - 并发对比：专用模式最高20,000并发，标准轮询1,250
- **51:00** - Kafka优势：简化网络和成本模型

### 专用轮询器定价与功能 (51:00-53:30)
- **51:00** - 额外费用：基于事件处理单元（EPU），可管理和配置
- **51:30** - 适用场景：高流量源、低延迟需求、大规模节省轮询成本
- **52:00** - 新功能支持：模式注册表、高效二进制格式（Avro、Protobuf）
- **52:30** - 过滤功能：丢弃不需要处理的记录
- **53:00** - 过滤原因：CPU密集型，避免浪费Lambda调用

### 消息过滤与批处理 (53:30-56:30)
- **53:30** - 过滤类型：正向过滤（包含匹配消息）或负向过滤（排除不匹配消息）
- **54:00** - 过滤语法：使用EventBridge过滤语法，非常灵活
- **54:30** - 示例：仅处理轮胎压力低于32的消息
- **55:00** - 批处理：将记录分组以高效处理
- **55:30** - 批处理控制：控制Lambda调用以提高效率
- **56:00** - 批处理配置：大小（1到默认10,000）、批处理窗口、6MB负载限制

### 函数调用与扩展 (56:30-60:00)
- **56:30** - 批处理形成后：通过同步控制平面调用函数
- **57:00** - 扩展考虑：流和队列的不同架构
- **57:30** - 流扩展：上限问题，尽快处理数据以保持最大吞吐量
- **58:00** - 流目标：消费和处理消息的最高速率，最小化延迟
- **58:30** - 流挑战：扩展以满足或超过摄取速率
- **59:00** - 队列扩展：下限问题，高效处理但不压垮下游服务
- **59:30** - 队列作用：作为缓冲或减震器，控制排空速率以保护下游资源

### SQS流量控制 (60:00-63:00)
- **60:00** - 流量控制：管理Lambda消费消息的速率
- **60:30** - 最大并发配置：ESM尝试发送到Lambda的并发执行数
- **61:00** - 防止压垮：保护下游服务，这是关键的缓冲控制
- **61:30** - 预留并发：函数上的独立设置，从账户并发中预留容量
- **62:00** - 预留并发作用：确保函数可在可用账户并发内扩展
- **62:30** - 建议：使用最大并发管理缓冲和流量，可同时使用两者
- **63:00** - 配合使用：预留并发应高于最大并发以防止限流

### 流自动扩展 (63:00-66:00)
- **63:00** - 流扩展：ESM自动确定如何扩展
- **63:30** - Kinesis扩展：添加分片；Kafka扩展：添加分区
- **64:00** - 自动扩展：Lambda自动扩展消费者轮询器以匹配吞吐量
- **64:30** - 顺序保证：每个分区或分片保持消息顺序
- **65:00** - 并行化因子：Kinesis的额外处理能力
- **65:30** - 默认配置：每个分片一个函数，可扩展到10以实现大规模吞吐量
- **66:00** - Lambda特定功能：专为Lambda高吞吐量流处理构建

### 错误处理 (66:00-70:00)
- **66:00** - 流与队列语义：流需要保持顺序，队列通常不需要
- **66:30** - 毒丸消息：决定是否停止处理
- **67:00** - 日志数据vs银行交易：日志可能可以跳过，交易必须停止并修复
- **67:30** - 传感器数据：频繁数据可以容忍部分丢失，继续处理
- **68:00** - GPS数据示例：几秒后会有新结果，不需要停止流
- **68:30** - 队列错误处理：通常不因失败消息停止，继续处理其余消息
- **69:00** - 部分批次响应：知道失败记录时返回成功响应，告知ESM哪条消息失败
- **69:30** - AWS Powertools：批处理实用程序，支持多种语言

### 批次拆分 (70:00-73:30)
- **70:00** - 批次拆分：流的有用功能，队列通常不需要
- **70:30** - 示例场景：消息3是坏消息，但尚不知道
- **71:00** - 处理失败：批次失败后，ESM拆分批次而非无限重试
- **71:30** - 保持顺序：尝试前半部分以保持顺序，处理更多消息
- **72:00** - 继续拆分：拆分的批次再次失败，ESM继续拆分
- **72:30** - 隔离问题：第一批次成功，单条毒丸消息批次失败
- **73:00** - 继续处理：处理原始批次的后半部分，保持成功消息的顺序
- **73:30** - 高效处理：尽可能多地处理消息，无需拒绝整个批次

### 故障目标 (73:30-76:00)
- **73:30** - 失败处理：配置Lambda失败目标处理函数错误
- **74:00** - 两种错误路径：SQS有两种不同的错误处理路径
- **74:30** - SQS DLQ：捕获轮询或处理期间反复失败的消息
- **75:00** - 失败目标：捕获Lambda函数的调用错误
- **75:30** - 调用错误类型：网络问题、限流、函数删除、权限问题
- **76:00** - 综合错误处理：两者服务不同流程，可一起使用

### Lambda基础总结 (76:00-78:00)
- **76:00** - 回顾内容：同步、异步、工作主机、轮询器、事件源映射所有功能
- **76:30** - 配置简单性：看起来只是配置选项，但Lambda底层做了大量工作
- **77:00** - 拉取与推送：处理不同架构的流和队列
- **77:30** - 效率优化：尽可能高效地从不同架构获取消息
- **78:00** - 过渡：交给Rajesh深入探讨轮询器和Lambda构建经验

### Rajesh开场 (78:00-80:00)
- **78:00** - Rajesh接棒：冷启动玩笑
- **78:30** - 演讲分段：心智模型和操作复杂性
- **79:00** - 设计理念：心智模型如何推动Lambda设计
- **79:30** - 创新驱动：操作复杂性如何激发创新
- **80:00** - 上次主题回顾：Lambda作为存储服务，应用EBS等服务的经验

### Lambda作为队列服务 (80:00-83:00)
- **80:00** - 新观点：Lambda也是队列服务
- **80:30** - 看似矛盾：计算即队列服务
- **81:00** - Rajesh背景：2013年加入Amazon，超过十年经验
- **81:30** - 第一个项目：构建队列处理器
- **82:00** - 队列处理器组成：消息缓冲区、工作器拉取、业务逻辑处理
- **82:30** - 早期挑战：Lambda不存在，需要大量手动工作
- **83:00** - 模拟需求：建模上游、下游、故障点，构建弹性服务

### 队列理论基础 (83:00-86:30)
- **83:00** - 加入Lambda：2018-19年，发现相同模式无处不在
- **83:30** - 功能设计：许多功能受相同分析启发
- **84:00** - 队列理论：研究等待队列，事物如何到达、等待、处理和离开
- **84:30** - 基本图表：每个队列系统的基本形状
- **85:00** - 到达率：事件以某种速率到达，速率从不固定
- **85:30** - 客户行为：有的疯狂激增，有的缓慢且有界
- **86:00** - 服务率：工作器速度，也不是恒定的
- **86:30** - 依赖性变化：有时10毫秒，有时100毫秒

### 缓冲与方差 (86:30-89:00)
- **86:30** - 缓冲区爆发和可变性：构建队列服务时的大量方差
- **87:00** - 方差来源：峰值、限流问题、服务无法处理工作负载
- **87:30** - 方差影响：系统中的简单方差可能导致积压堆积
- **88:00** - 后续讨论：将在具体部分详细讨论
- **88:30** - Lambda经验：从队列理论中学到的教训
- **89:00** - 应用实践：如何将理论应用到Lambda

### Lambda的队列理论教训 (89:00-92:00)
- **89:00** - 第一课：缓冲区平滑方差到达
- **89:30** - 到达特性：从不均匀，突发性，不可预测
- **90:00** - 不立即处理：不可能且昂贵
- **90:30** - 峰值配置：总是可以为峰值配置，但成本高昂
- **91:00** - 第二课：为工作负载类型专门化工作器
- **91:30** - 设计影响：导致轮询器与Lambda执行环境分离
- **92:00** - 工作器差异：轮询器工作器与执行环境的不同性质

### 更多队列理论教训 (92:00-94:00)
- **92:00** - 第三课：控制方差以防止不稳定
- **92:30** - 方差问题：即使平均到达率小于平均服务率，方差也会导致临时不稳定
- **93:00** - 方差杀手：方差会破坏系统
- **93:30** - 第四课：通过集中控制协调共享资源
- **94:00** - 队列理论模型：工作守恒意味着如果有工作可做...

注：字幕在此处截断