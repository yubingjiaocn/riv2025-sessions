1
00:00:02,740 --> 00:00:04,599
Yeah Good afternoon,

2
00:00:05,179 --> 00:00:06,980
everyone. What if

3
00:00:07,459 --> 00:00:09,579
we tell you that Phillips was

4
00:00:09,579 --> 00:00:12,519
able to migrate their 20,000+

5
00:00:13,060 --> 00:00:13,599
critical

6
00:00:14,140 --> 00:00:15,739
Medicare devices

7
00:00:16,010 --> 00:00:17,199
from the legacy

8
00:00:17,940 --> 00:00:19,920
machine to machine communication back end

9
00:00:20,179 --> 00:00:22,708
to more modern event-driven

10
00:00:22,708 --> 00:00:24,899
serverless architecture to

11
00:00:24,899 --> 00:00:27,068
integrate with the modern IoT

12
00:00:27,068 --> 00:00:29,138
platform to gain

13
00:00:29,138 --> 00:00:31,399
more reliability, scalability

14
00:00:31,690 --> 00:00:32,859
at the same time.

15
00:00:33,200 --> 00:00:35,500
Result into the cost avoidance

16
00:00:35,500 --> 00:00:37,560
of 20 million plus.

17
00:00:38,408 --> 00:00:40,048
It is an exciting story, right?

18
00:00:40,569 --> 00:00:42,810
And we are going to tell you how we

19
00:00:42,810 --> 00:00:44,908
achieve that and how we transform

20
00:00:45,090 --> 00:00:47,250
the legacy back end systems into

21
00:00:47,250 --> 00:00:49,450
the more modern architectures

22
00:00:49,450 --> 00:00:51,829
using event driven and serverless

23
00:00:51,929 --> 00:00:52,668
and for that.

24
00:00:53,529 --> 00:00:55,029
I am Anand Bulgia. I'm an

25
00:00:55,368 --> 00:00:57,029
enterprise transformation specialist

26
00:00:57,368 --> 00:00:59,689
and a senior partner solution architect

27
00:00:59,689 --> 00:01:02,020
with AWS, and I'm joined by Shrini

28
00:01:02,020 --> 00:01:04,088
Shrini. Good afternoon

29
00:01:04,088 --> 00:01:05,989
everyone. I know we are between

30
00:01:06,448 --> 00:01:08,650
the last session and the replay,

31
00:01:08,849 --> 00:01:10,168
so we'll keep it

32
00:01:10,730 --> 00:01:12,638
short, excited, um,

33
00:01:12,930 --> 00:01:14,930
you all must have heard of Phillips as a

34
00:01:14,930 --> 00:01:15,549
brand,

35
00:01:16,209 --> 00:01:18,959
so the toothbrushes, the shavers,

36
00:01:19,290 --> 00:01:21,409
uh, but what Anand was talking

37
00:01:21,409 --> 00:01:23,629
about is the critical care

38
00:01:23,629 --> 00:01:25,069
devices that we have

39
00:01:25,338 --> 00:01:26,808
which are related to the.

40
00:01:27,168 --> 00:01:29,480
Diagnostics and treatment devices

41
00:01:29,730 --> 00:01:32,088
like the integrated um

42
00:01:32,088 --> 00:01:33,659
IGT devices,

43
00:01:34,168 --> 00:01:35,329
CT scanners,

44
00:01:35,609 --> 00:01:36,829
X-ray machines.

45
00:01:37,370 --> 00:01:39,528
So I am Sriniva Seram, platform

46
00:01:39,528 --> 00:01:41,599
architecture lead in digital innovation

47
00:01:41,599 --> 00:01:42,430
platforms,

48
00:01:42,730 --> 00:01:45,019
and we are going to talk about how

49
00:01:45,290 --> 00:01:46,939
in our organization

50
00:01:47,209 --> 00:01:48,349
we have

51
00:01:48,930 --> 00:01:51,510
used the event driven architecture to connect

52
00:01:51,689 --> 00:01:54,349
our legacy devices to a modern integrated

53
00:01:54,930 --> 00:01:56,329
services from the back end.

54
00:01:56,719 --> 00:01:58,760
So we'll first let Anan continue

55
00:01:58,760 --> 00:02:01,609
giving an introduction about event driven architecture,

56
00:02:01,668 --> 00:02:03,698
and I'll come back in between

57
00:02:04,198 --> 00:02:06,198
to walk through the use case and

58
00:02:06,198 --> 00:02:08,229
uh how everything comes together.

59
00:02:08,588 --> 00:02:09,538
Anan, sure,

60
00:02:09,849 --> 00:02:10,479
thanks, Vinnie.

61
00:02:12,080 --> 00:02:13,618
So this is how our

62
00:02:13,879 --> 00:02:16,000
agenda look like for the next hour or so.

63
00:02:16,399 --> 00:02:18,629
We are going to talk about why event driven architecture,

64
00:02:18,719 --> 00:02:20,939
why they matters for the modern applications,

65
00:02:21,110 --> 00:02:21,659
and then

66
00:02:21,919 --> 00:02:24,000
we also wanna look about the Phillips case study.

67
00:02:24,088 --> 00:02:26,240
What were the business requirement? What are the challenges,

68
00:02:26,439 --> 00:02:26,979
and how

69
00:02:27,360 --> 00:02:29,679
the modern event driven architecture help us to mitigate

70
00:02:29,679 --> 00:02:31,679
those. And then we are going to look about

71
00:02:31,679 --> 00:02:33,558
some of the event driven architecture pattern.

72
00:02:34,058 --> 00:02:36,139
Which could help us to transform

73
00:02:36,139 --> 00:02:38,159
those legacy systems into the more

74
00:02:38,419 --> 00:02:40,538
modernized state and last but not the

75
00:02:40,538 --> 00:02:42,770
least, the most important one, the end to end

76
00:02:42,770 --> 00:02:44,960
solution what we were able to build

77
00:02:45,020 --> 00:02:47,020
to gain those business outcome in terms of

78
00:02:47,020 --> 00:02:49,278
scalability, reliability, and avoiding

79
00:02:49,419 --> 00:02:50,949
that cost, uh, right,

80
00:02:51,618 --> 00:02:53,800
for 20 million which otherwise, uh,

81
00:02:53,860 --> 00:02:56,139
would have been the part of the overall transformation.

82
00:02:57,118 --> 00:02:58,058
So first thing first,

83
00:02:58,879 --> 00:03:00,278
what is even driven architecture?

84
00:03:01,110 --> 00:03:02,368
Now if I have to give you

85
00:03:02,830 --> 00:03:05,229
a very simplistic, non-technical

86
00:03:05,229 --> 00:03:05,969
definition,

87
00:03:06,308 --> 00:03:07,008
and I will

88
00:03:07,550 --> 00:03:08,169
explain that

89
00:03:08,629 --> 00:03:09,808
in one statement.

90
00:03:10,429 --> 00:03:12,319
Something happened and we react.

91
00:03:12,669 --> 00:03:14,179
This is the event of an architecture.

92
00:03:15,758 --> 00:03:18,118
Some systems are doing some

93
00:03:18,639 --> 00:03:20,830
business processes and they are

94
00:03:21,118 --> 00:03:23,319
then expecting the other component

95
00:03:23,319 --> 00:03:25,399
of the system and the architecture to react

96
00:03:26,020 --> 00:03:28,379
and that's where the event driven architecture

97
00:03:28,379 --> 00:03:30,580
comes. Into the play

98
00:03:30,838 --> 00:03:33,338
now if I move into the more technical definition

99
00:03:33,838 --> 00:03:35,919
now why even driven architectures

100
00:03:35,919 --> 00:03:38,159
are used they are used to build

101
00:03:38,159 --> 00:03:39,659
more decoupled

102
00:03:40,389 --> 00:03:42,338
applications where the different

103
00:03:42,599 --> 00:03:44,679
component in the decoupled state

104
00:03:44,679 --> 00:03:47,080
can communicate with each other via

105
00:03:47,080 --> 00:03:49,278
emitting the events and then

106
00:03:49,278 --> 00:03:51,278
responding to those events. Now if we

107
00:03:51,278 --> 00:03:54,088
take an example of. Modern applications, right, modern

108
00:03:54,088 --> 00:03:55,229
applications are complex,

109
00:03:55,528 --> 00:03:57,610
right, because they are distributed in

110
00:03:57,610 --> 00:03:59,689
nature. Take an example of microservices

111
00:03:59,689 --> 00:04:02,569
based architecture. Microservices based architecture

112
00:04:02,569 --> 00:04:04,929
requires many different layers

113
00:04:04,929 --> 00:04:06,929
in the levers in terms of the different domain

114
00:04:06,929 --> 00:04:09,008
services which need to communicate with each

115
00:04:09,008 --> 00:04:10,569
other and sometimes

116
00:04:10,929 --> 00:04:13,449
if the distributed components have a tight integration

117
00:04:13,449 --> 00:04:16,088
between them, it impacts the overall scalability,

118
00:04:16,209 --> 00:04:18,088
reliability, and the agility.

119
00:04:18,838 --> 00:04:20,978
Of the architectures and that's where

120
00:04:21,079 --> 00:04:23,398
the event driven architecture helps to

121
00:04:23,398 --> 00:04:25,918
define more decoupled

122
00:04:25,918 --> 00:04:27,959
asynchronous way of dealing

123
00:04:27,959 --> 00:04:30,598
the communication between these uh uh

124
00:04:30,598 --> 00:04:32,038
architectural components right?

125
00:04:34,298 --> 00:04:34,949
So

126
00:04:35,259 --> 00:04:36,420
the first class citizen

127
00:04:36,738 --> 00:04:38,778
of the event of an architecture is an

128
00:04:38,778 --> 00:04:40,809
event itself. Now if I, if I have to

129
00:04:40,809 --> 00:04:43,100
define what is the definition,

130
00:04:43,139 --> 00:04:45,238
a sim simplistic definition of event

131
00:04:45,238 --> 00:04:47,420
could be a something which has

132
00:04:47,420 --> 00:04:47,939
happened.

133
00:04:48,220 --> 00:04:49,319
So event represent.

134
00:04:50,459 --> 00:04:52,910
Something which has happened in your system

135
00:04:53,019 --> 00:04:55,338
and always represented into the past

136
00:04:55,338 --> 00:04:56,480
means they are idempotent.

137
00:04:56,738 --> 00:04:58,939
Something which has already happened which cannot be

138
00:04:58,939 --> 00:04:59,939
changed, but.

139
00:05:00,649 --> 00:05:02,928
It's what the event represents

140
00:05:02,928 --> 00:05:05,048
something which you, as a domain care

141
00:05:05,048 --> 00:05:07,149
about. If I take

142
00:05:07,149 --> 00:05:09,350
an example of the healthcare devices itself,

143
00:05:09,619 --> 00:05:11,629
the event could be my healthcare devices

144
00:05:11,629 --> 00:05:12,540
are registered,

145
00:05:12,829 --> 00:05:15,238
right, so that they can start interacting,

146
00:05:15,428 --> 00:05:16,689
uh, with the back end system

147
00:05:17,309 --> 00:05:19,488
for performing the operation what they're supposed to do,

148
00:05:19,750 --> 00:05:21,819
right? The event could be, OK, the file

149
00:05:21,819 --> 00:05:24,059
has been received now start processing it, right?

150
00:05:24,269 --> 00:05:26,528
Or the event could be there are some security alert

151
00:05:26,949 --> 00:05:28,949
which need to get imme uh which required your

152
00:05:28,949 --> 00:05:31,329
imme immediate attention to mitigate those, right.

153
00:05:33,410 --> 00:05:35,608
So event driven architectures are all revolve

154
00:05:35,608 --> 00:05:36,298
around the

155
00:05:36,850 --> 00:05:38,928
events right now let's talk about

156
00:05:38,928 --> 00:05:41,649
what are some of the design tenet or the properties

157
00:05:41,649 --> 00:05:43,899
of the event driven architecture, right?

158
00:05:44,319 --> 00:05:46,649
Why they met why the event driven architecture matter,

159
00:05:46,850 --> 00:05:48,250
right, for the modern applications.

160
00:05:49,028 --> 00:05:51,449
The very first thing, the event driven architecture,

161
00:05:51,548 --> 00:05:53,290
it's not a tool, it's not a technology,

162
00:05:53,548 --> 00:05:55,819
but it's an architectural mindset, right,

163
00:05:56,149 --> 00:05:57,129
which help us.

164
00:05:58,040 --> 00:05:58,798
To build

165
00:05:59,079 --> 00:06:01,189
a decomposed the decoupled

166
00:06:01,189 --> 00:06:03,278
systems, right, so it's architectural

167
00:06:03,278 --> 00:06:05,879
style and even driven architecture can be implemented

168
00:06:05,879 --> 00:06:07,879
in various different ways. It

169
00:06:07,879 --> 00:06:10,129
depends upon what is the nature of the workload

170
00:06:10,129 --> 00:06:12,238
you are dealing with, and we are going to tap upon

171
00:06:12,238 --> 00:06:14,259
some of these different ways in which

172
00:06:14,259 --> 00:06:16,559
the even driven architecture can be built as

173
00:06:16,559 --> 00:06:18,720
we go along subsequently in our session.

174
00:06:19,850 --> 00:06:22,160
The second thing, event-driven architectures

175
00:06:22,160 --> 00:06:24,170
are asynchronous, and that's why they

176
00:06:24,170 --> 00:06:26,850
are loosely coupled. So the so the components

177
00:06:26,850 --> 00:06:28,970
between the event driven architecture do not

178
00:06:28,970 --> 00:06:29,588
directly

179
00:06:29,988 --> 00:06:32,269
tightly integrated with each other. They

180
00:06:32,449 --> 00:06:34,480
asynchronously communicate with each other. So

181
00:06:34,480 --> 00:06:35,059
it's typical.

182
00:06:35,769 --> 00:06:38,048
So we are converging from a typical request

183
00:06:38,048 --> 00:06:40,069
response based model to more an

184
00:06:40,069 --> 00:06:42,170
event-based responsive model, right?

185
00:06:43,639 --> 00:06:45,678
The third, the event autonomy. What

186
00:06:45,678 --> 00:06:47,920
does it mean for event event architecture?

187
00:06:47,959 --> 00:06:50,040
It is very important that the event should

188
00:06:50,040 --> 00:06:52,238
be self-contained, so event.

189
00:06:53,079 --> 00:06:54,850
Contain the information about.

190
00:06:56,040 --> 00:06:58,160
Why they get created, why they were

191
00:06:58,160 --> 00:07:00,238
imitated, who imited them or

192
00:07:00,238 --> 00:07:01,170
who created them,

193
00:07:01,439 --> 00:07:02,119
and when.

194
00:07:02,829 --> 00:07:04,949
They were created so this information is

195
00:07:04,949 --> 00:07:06,970
important for the subsequent downstream

196
00:07:06,970 --> 00:07:07,528
system

197
00:07:07,949 --> 00:07:10,019
to consume these events and act accordingly,

198
00:07:10,509 --> 00:07:12,709
right? So event autonomy is important and

199
00:07:12,709 --> 00:07:14,509
last but not the least as I mentioned

200
00:07:14,949 --> 00:07:17,500
the. How the event different architect

201
00:07:17,500 --> 00:07:18,910
architecture works,

202
00:07:19,829 --> 00:07:21,889
some components are emitting the event and the

203
00:07:21,889 --> 00:07:24,048
other component in the system are actually responding

204
00:07:24,048 --> 00:07:26,129
to those events. It's as simple as simple

205
00:07:26,129 --> 00:07:28,608
as that, right? So these are the different properties,

206
00:07:28,689 --> 00:07:30,769
right, which define the event-driven

207
00:07:30,769 --> 00:07:31,449
architecture.

208
00:07:32,420 --> 00:07:33,238
Now we have seen

209
00:07:33,980 --> 00:07:35,600
event driven architecture. We have seen

210
00:07:35,939 --> 00:07:37,980
the, the, the, the

211
00:07:37,980 --> 00:07:40,199
events which are the critical and the

212
00:07:40,199 --> 00:07:42,420
uh integral part of the event event architecture sit

213
00:07:42,420 --> 00:07:43,910
in the center of the EDA

214
00:07:44,338 --> 00:07:46,459
and we also seen some of the properties of

215
00:07:46,459 --> 00:07:47,379
event even architecture.

216
00:07:47,709 --> 00:07:49,778
Now let's look into what are some

217
00:07:49,778 --> 00:07:50,399
of the

218
00:07:51,250 --> 00:07:52,670
Benefit we get

219
00:07:52,970 --> 00:07:54,889
from this event driven architecture.

220
00:07:55,250 --> 00:07:57,290
The first benefit, as I mentioned, is the loose

221
00:07:57,290 --> 00:07:59,389
coupling and the agility. Why

222
00:07:59,389 --> 00:08:01,449
the agility matters the most? Because the

223
00:08:01,449 --> 00:08:03,569
event driven architecture allows us to

224
00:08:03,569 --> 00:08:05,689
then build the system in

225
00:08:05,689 --> 00:08:06,309
parallel,

226
00:08:06,730 --> 00:08:08,850
agnostic or independent to each

227
00:08:08,850 --> 00:08:11,170
other, and that does not impact your

228
00:08:11,170 --> 00:08:11,949
overall

229
00:08:12,528 --> 00:08:13,189
release cycle

230
00:08:13,528 --> 00:08:15,725
for. Releasing the new different features

231
00:08:15,725 --> 00:08:17,934
what matter the most for your business so the team

232
00:08:17,934 --> 00:08:20,285
can go and independently build the systems

233
00:08:20,285 --> 00:08:22,334
and they can just communicate

234
00:08:22,725 --> 00:08:25,004
the communication between these channels or these

235
00:08:25,744 --> 00:08:27,314
application components can happen can happen

236
00:08:28,564 --> 00:08:30,084
over the network via

237
00:08:30,444 --> 00:08:32,445
emitting the event and consuming the event, right.

238
00:08:33,408 --> 00:08:35,158
The scalability, right,

239
00:08:35,649 --> 00:08:38,178
because the event driven architecture are more responsive

240
00:08:38,178 --> 00:08:39,109
so, so

241
00:08:39,369 --> 00:08:41,369
the independently the components can

242
00:08:41,369 --> 00:08:43,830
be scaled based on their business

243
00:08:44,129 --> 00:08:44,928
needs, right?

244
00:08:45,469 --> 00:08:47,590
More res the event of an architecture bring more

245
00:08:47,590 --> 00:08:48,940
resiliency in the architecture because

246
00:08:49,428 --> 00:08:51,808
they are loosely coupled they're running in parallel

247
00:08:52,298 --> 00:08:54,428
independently agnostic to each other

248
00:08:54,668 --> 00:08:56,869
so if any components has got any

249
00:08:56,869 --> 00:08:59,090
challenges or any failure, it is not

250
00:08:59,389 --> 00:09:01,750
creating a downstream or cascading

251
00:09:01,750 --> 00:09:03,750
effect and impacting your entire business

252
00:09:03,750 --> 00:09:04,349
continuity.

253
00:09:05,070 --> 00:09:07,548
And last but not the least, it manages

254
00:09:07,548 --> 00:09:09,759
the complex integrations as I mentioned,

255
00:09:09,798 --> 00:09:11,649
the distributed system, the modern

256
00:09:12,349 --> 00:09:14,639
applications, they have a lot of complexities

257
00:09:14,639 --> 00:09:16,940
involved in terms of the different, uh,

258
00:09:17,479 --> 00:09:19,899
building block and the event driven architecture

259
00:09:19,899 --> 00:09:21,918
abstract that integration

260
00:09:21,918 --> 00:09:22,590
complexities because

261
00:09:23,000 --> 00:09:24,139
the competents are now

262
00:09:24,759 --> 00:09:26,928
decoupled to each other. They're agnostic to each other.

263
00:09:27,080 --> 00:09:29,119
They just react based on the events

264
00:09:29,119 --> 00:09:30,340
which flow between them.

265
00:09:31,139 --> 00:09:33,639
Right? So

266
00:09:34,418 --> 00:09:36,500
we looked into the EDA properties. We

267
00:09:36,500 --> 00:09:38,700
looked into the event driven architecture's benefits.

268
00:09:39,070 --> 00:09:41,070
Now look into some of the core building

269
00:09:41,070 --> 00:09:43,099
block of event-driven architecture using

270
00:09:43,099 --> 00:09:45,139
which we actually established the EDA

271
00:09:45,139 --> 00:09:47,389
in our, um, uh, uh, in

272
00:09:47,389 --> 00:09:49,538
our, in our applications based on the business requirements.

273
00:09:49,619 --> 00:09:50,879
The very first thing is event

274
00:09:51,139 --> 00:09:52,359
we have already talked about.

275
00:09:52,820 --> 00:09:54,859
The second thing is event routers. So as

276
00:09:54,859 --> 00:09:57,009
I mentioned, how the event driven architecture works,

277
00:09:57,330 --> 00:09:59,408
there are some producers, there's some component

278
00:09:59,408 --> 00:10:01,538
who are actually producing the event. We call

279
00:10:01,538 --> 00:10:02,379
them as a producer.

280
00:10:02,719 --> 00:10:04,719
And there are some components which are actually

281
00:10:04,719 --> 00:10:06,190
consuming those events and

282
00:10:06,509 --> 00:10:08,769
responsing and and they are

283
00:10:08,769 --> 00:10:10,879
responding accordingly uh to those events

284
00:10:10,879 --> 00:10:12,418
so we call them as a consumer

285
00:10:12,840 --> 00:10:15,178
what event router does they actually.

286
00:10:16,070 --> 00:10:18,469
Sit between the producer and consumer

287
00:10:18,469 --> 00:10:20,779
and allow this communication happen

288
00:10:20,989 --> 00:10:23,090
so it's the event router who will then

289
00:10:23,269 --> 00:10:25,349
take a ownership of how the

290
00:10:25,349 --> 00:10:27,548
event should flow from producer to

291
00:10:27,548 --> 00:10:28,250
consumer,

292
00:10:28,710 --> 00:10:31,389
right? And the third component

293
00:10:31,590 --> 00:10:33,710
is the event store. Often the

294
00:10:33,710 --> 00:10:34,229
time

295
00:10:34,558 --> 00:10:35,330
you may

296
00:10:35,750 --> 00:10:37,408
require the consumer

297
00:10:37,700 --> 00:10:39,769
to consume the event and act

298
00:10:39,940 --> 00:10:41,889
accordingly whenever they are available.

299
00:10:42,149 --> 00:10:44,149
So you need some sort of an intermediate

300
00:10:44,149 --> 00:10:46,349
store where these events can get

301
00:10:46,349 --> 00:10:48,710
stored and they can get replay

302
00:10:48,879 --> 00:10:50,908
as and when the bus as and when

303
00:10:50,908 --> 00:10:53,229
it is needed, right, based on your business

304
00:10:53,229 --> 00:10:55,048
processes and the business flow

305
00:10:55,788 --> 00:10:57,879
requirements, right? So these are the three

306
00:10:57,879 --> 00:10:58,658
building blocks.

307
00:10:59,869 --> 00:11:01,908
We use to define or build the

308
00:11:01,908 --> 00:11:03,038
event driven architecture.

309
00:11:04,330 --> 00:11:06,769
Let's take a simple example, how the overall

310
00:11:06,769 --> 00:11:08,570
event driven architecture looked like, right?

311
00:11:09,700 --> 00:11:10,349
Let's say

312
00:11:11,690 --> 00:11:13,690
We are in the world, we are, we are generating a lot

313
00:11:13,690 --> 00:11:16,139
of data, a lot of content. So let's say we are generating

314
00:11:16,139 --> 00:11:18,210
some data. It could be your images, it could be your

315
00:11:18,210 --> 00:11:20,239
document, right? And those data we

316
00:11:20,239 --> 00:11:22,489
are storing in our Amazon

317
00:11:22,489 --> 00:11:24,719
Simple storage Service in S3. The

318
00:11:24,719 --> 00:11:25,229
moment

319
00:11:25,489 --> 00:11:27,678
the document gets stored or uploaded,

320
00:11:27,769 --> 00:11:29,808
we want to perform certain action

321
00:11:29,969 --> 00:11:32,210
on top of that. Let's take an example of

322
00:11:32,210 --> 00:11:34,288
a critical medical devices.

323
00:11:34,500 --> 00:11:36,649
If let's say the X-ray or MRI has been

324
00:11:36,649 --> 00:11:37,928
done, you want to then.

325
00:11:38,450 --> 00:11:40,558
And do the analysis of those X-ray

326
00:11:40,558 --> 00:11:42,070
or MRI reports so that you can

327
00:11:42,369 --> 00:11:44,649
accordingly generate the outcome and the summary

328
00:11:44,649 --> 00:11:47,129
and push back to the respective, uh, clinical

329
00:11:47,129 --> 00:11:47,808
team, right?

330
00:11:48,129 --> 00:11:49,869
So the document is uploaded to the S3.

331
00:11:50,369 --> 00:11:52,369
The S3 as a service can emit

332
00:11:52,369 --> 00:11:54,450
an event that the file has been uploaded.

333
00:11:54,798 --> 00:11:57,129
And once the file is uploaded, that

334
00:11:57,129 --> 00:11:59,229
can that event can be consumed

335
00:11:59,519 --> 00:12:01,668
by an event router, and we are taking

336
00:12:01,668 --> 00:12:03,889
an example of Amazon Event Bridge, which

337
00:12:03,889 --> 00:12:04,428
is our

338
00:12:04,889 --> 00:12:06,960
service which helps

339
00:12:06,960 --> 00:12:08,288
us to define.

340
00:12:09,029 --> 00:12:10,940
The event driven architecture and we will

341
00:12:11,639 --> 00:12:13,658
go into the more detail

342
00:12:13,658 --> 00:12:16,229
of how event bridge works and what are its properties

343
00:12:16,229 --> 00:12:18,239
and what are some of the design patterns which we can

344
00:12:18,239 --> 00:12:19,950
build. Around it right,

345
00:12:20,250 --> 00:12:22,320
and then event router will consume,

346
00:12:22,469 --> 00:12:23,859
take this, uh, event,

347
00:12:24,168 --> 00:12:26,288
do some sort of, uh, filtering, apply

348
00:12:26,288 --> 00:12:28,298
certain rule based according to your business need,

349
00:12:28,450 --> 00:12:30,609
and then it push it to the target

350
00:12:30,609 --> 00:12:33,058
system. The target system could be your

351
00:12:33,058 --> 00:12:35,330
logic, business logic, which then

352
00:12:35,330 --> 00:12:37,349
take that image and then do the

353
00:12:37,349 --> 00:12:39,658
cert for her, you know, the certain analysis

354
00:12:39,808 --> 00:12:41,808
and then generate the outcome or the

355
00:12:41,808 --> 00:12:43,869
summary. So in our case,

356
00:12:43,969 --> 00:12:46,168
the producer was the, the document

357
00:12:46,168 --> 00:12:48,538
store. Consumer was our lambda

358
00:12:48,538 --> 00:12:50,590
function which is running a business logic to process

359
00:12:50,590 --> 00:12:52,710
that X-ray image or MRI image and

360
00:12:52,710 --> 00:12:54,750
in between sitting as an event router

361
00:12:54,750 --> 00:12:57,190
which is making sure the communication

362
00:12:57,190 --> 00:12:57,849
happens

363
00:12:58,149 --> 00:13:00,548
between these two these two components

364
00:13:00,629 --> 00:13:01,428
over the

365
00:13:02,149 --> 00:13:04,090
over the events, right? And this is how

366
00:13:04,349 --> 00:13:06,590
the event event architecture looked like now

367
00:13:06,590 --> 00:13:08,590
with this let's try to understand

368
00:13:08,590 --> 00:13:10,538
the Phillips business case

369
00:13:10,830 --> 00:13:12,029
right? and then.

370
00:13:13,070 --> 00:13:13,590
We will

371
00:13:13,879 --> 00:13:15,009
take it from there on

372
00:13:15,340 --> 00:13:17,658
to look into the various different,

373
00:13:17,750 --> 00:13:20,009
you know, the advanced EDA patterns and

374
00:13:20,009 --> 00:13:22,109
the end to end solution, right, which we

375
00:13:22,109 --> 00:13:24,158
were able to build for this Phillips use case.

376
00:13:24,250 --> 00:13:25,109
So Srini, over to you.

377
00:13:25,899 --> 00:13:26,649
Thank you Anan.

378
00:13:34,769 --> 00:13:36,399
First, let me set the context.

379
00:13:36,808 --> 00:13:38,808
How many of you have dealt with

380
00:13:38,808 --> 00:13:41,210
more than 1,000s of devices in the field?

381
00:13:42,119 --> 00:13:43,668
A quick show of hands.

382
00:13:45,210 --> 00:13:45,769
OK.

383
00:13:46,200 --> 00:13:47,769
Around maybe 20%.

384
00:13:48,129 --> 00:13:50,519
How many of you from healthcare dealing

385
00:13:50,519 --> 00:13:52,349
with legacy systems in the field?

386
00:13:54,500 --> 00:13:55,340
OK, a few.

387
00:13:56,469 --> 00:13:58,668
It will definitely resonate to you of

388
00:13:58,668 --> 00:14:00,129
what I'm going to show

389
00:14:00,428 --> 00:14:00,969
because.

390
00:14:06,058 --> 00:14:08,058
The devices that we ship

391
00:14:08,058 --> 00:14:10,058
to these healthcare facilities,

392
00:14:10,139 --> 00:14:11,940
the critical care devices,

393
00:14:12,779 --> 00:14:15,190
they connect to our back end systems,

394
00:14:15,298 --> 00:14:15,918
and

395
00:14:16,369 --> 00:14:18,700
Phillips has been connecting these devices

396
00:14:18,700 --> 00:14:20,418
for a long time and.

397
00:14:21,359 --> 00:14:23,798
These devices, they connect into our back end.

398
00:14:24,119 --> 00:14:26,479
Uh, this is, um, they are sending

399
00:14:26,479 --> 00:14:28,678
the, uh, log file information.

400
00:14:29,408 --> 00:14:31,899
And normally what happens is this log file

401
00:14:31,899 --> 00:14:33,269
information are

402
00:14:34,099 --> 00:14:36,379
processed. There is an alert that gets

403
00:14:36,379 --> 00:14:37,200
generated

404
00:14:37,820 --> 00:14:39,308
to a remote service engineer.

405
00:14:40,229 --> 00:14:42,369
The remote service engineer can remotely connect

406
00:14:42,369 --> 00:14:44,408
to the device and see if he can

407
00:14:44,408 --> 00:14:45,509
resolve the issue.

408
00:14:46,200 --> 00:14:47,399
In some cases,

409
00:14:48,320 --> 00:14:50,450
He will not be able to do it by himself,

410
00:14:50,529 --> 00:14:51,308
so he would

411
00:14:51,869 --> 00:14:53,928
dispatch a service request with a

412
00:14:53,928 --> 00:14:56,200
field change order to a field service

413
00:14:56,200 --> 00:14:56,779
engineer,

414
00:14:57,210 --> 00:14:59,710
and the field service engineer will travel

415
00:14:59,710 --> 00:15:01,889
to the specific location

416
00:15:01,889 --> 00:15:03,889
where the device is and he will try to

417
00:15:03,889 --> 00:15:05,969
fix it. This is a

418
00:15:05,969 --> 00:15:07,519
general serviceability flow.

419
00:15:07,849 --> 00:15:08,710
This is how

420
00:15:09,048 --> 00:15:11,210
Phillips has been trying to deal

421
00:15:11,210 --> 00:15:13,750
with serviceability. Services is a larger,

422
00:15:14,529 --> 00:15:16,729
uh, business model within Phillips because once

423
00:15:16,729 --> 00:15:18,889
we ship the device, we want those

424
00:15:18,889 --> 00:15:21,479
devices to be up and running 24/7

425
00:15:21,479 --> 00:15:22,808
in the hospital systems.

426
00:15:24,200 --> 00:15:26,418
Now the fundamental challenge that we had,

427
00:15:26,759 --> 00:15:27,820
like in any system,

428
00:15:28,519 --> 00:15:31,038
the legacy M2M systems

429
00:15:31,038 --> 00:15:32,009
that we have

430
00:15:32,359 --> 00:15:33,940
had its own end of life.

431
00:15:34,759 --> 00:15:36,798
And it came so fast to

432
00:15:36,798 --> 00:15:38,918
us and slowly as well. We had

433
00:15:38,918 --> 00:15:40,960
known it many years ago, so we

434
00:15:40,960 --> 00:15:43,279
replaced with a modern remote

435
00:15:43,279 --> 00:15:44,418
services gateway.

436
00:15:45,158 --> 00:15:47,649
But in this case, there were certain devices

437
00:15:47,649 --> 00:15:49,609
that could not be updated in time.

438
00:15:49,969 --> 00:15:52,048
So that was the use case that Anand

439
00:15:52,048 --> 00:15:54,288
was speaking about. We have roughly around

440
00:15:54,288 --> 00:15:55,729
these 20,000

441
00:15:56,119 --> 00:15:58,129
X-ray machines and image

442
00:15:58,129 --> 00:15:59,950
guided therapy devices

443
00:16:00,509 --> 00:16:02,690
that have an agent that connect to

444
00:16:02,690 --> 00:16:05,070
these legacy devices that cannot be updated.

445
00:16:05,750 --> 00:16:08,070
Now if we do a little bit math

446
00:16:08,070 --> 00:16:08,908
around this,

447
00:16:10,408 --> 00:16:11,168
a simple trip

448
00:16:11,509 --> 00:16:12,489
off an FSC

449
00:16:13,229 --> 00:16:15,250
costs around $1000

450
00:16:15,399 --> 00:16:17,009
and if we just calculate

451
00:16:17,509 --> 00:16:19,830
just to restore the connectivity of these

452
00:16:19,830 --> 00:16:20,739
devices,

453
00:16:21,369 --> 00:16:23,538
it costs us around roughly $20

454
00:16:23,538 --> 00:16:25,859
million. Just to restore the connectivity.

455
00:16:27,109 --> 00:16:29,158
And our requirement was

456
00:16:29,158 --> 00:16:30,940
to make sure that

457
00:16:31,279 --> 00:16:33,379
we have to deal with this in a time

458
00:16:33,379 --> 00:16:35,700
frame, which was December 31st,

459
00:16:35,840 --> 00:16:37,229
2024.

460
00:16:37,519 --> 00:16:39,678
So this has already passed

461
00:16:39,678 --> 00:16:41,798
through, so we have gone through and that's why we're able

462
00:16:41,798 --> 00:16:43,058
to talk about it now.

463
00:16:44,969 --> 00:16:47,489
So we, our requirements were very simple,

464
00:16:47,889 --> 00:16:49,899
OK? We have to replace the end

465
00:16:49,899 --> 00:16:51,349
of life M2M.

466
00:16:52,259 --> 00:16:54,690
Which are affecting these 20,000 devices.

467
00:16:55,609 --> 00:16:57,750
Now it has to be

468
00:16:57,750 --> 00:16:58,889
zero disruption.

469
00:16:59,690 --> 00:17:01,548
And zero touch solution.

470
00:17:02,009 --> 00:17:04,368
If we have to touch the devices, then the FSC

471
00:17:04,368 --> 00:17:06,650
has to travel, and that again is

472
00:17:06,650 --> 00:17:07,789
a cost to us.

473
00:17:08,549 --> 00:17:10,709
And then of course, we have to maintain

474
00:17:10,709 --> 00:17:13,049
these devices because they're in the field

475
00:17:13,049 --> 00:17:15,410
and we have our contractual

476
00:17:15,410 --> 00:17:17,509
obligations to meet these

477
00:17:17,509 --> 00:17:18,670
devices up and running.

478
00:17:20,809 --> 00:17:22,598
The other challenge was

479
00:17:23,059 --> 00:17:24,618
the architecture itself,

480
00:17:24,939 --> 00:17:27,019
so our challenges were twofold. One, the

481
00:17:27,019 --> 00:17:29,259
way how the architecture is of

482
00:17:29,259 --> 00:17:31,459
what has, uh, the

483
00:17:31,459 --> 00:17:33,500
M2M systems were in the

484
00:17:33,500 --> 00:17:34,160
field.

485
00:17:34,709 --> 00:17:36,858
Um, there were many services. It's

486
00:17:36,858 --> 00:17:39,348
a monolith services, API driven.

487
00:17:40,088 --> 00:17:42,289
I don't know how many of you will resonate

488
00:17:42,289 --> 00:17:44,368
with you. These are so based web

489
00:17:44,368 --> 00:17:47,078
services, sim simple object access protocol,

490
00:17:47,410 --> 00:17:49,799
and you can imagine how old these systems

491
00:17:49,799 --> 00:17:51,309
are in the back end.

492
00:17:51,729 --> 00:17:54,289
And for making these systems

493
00:17:54,289 --> 00:17:55,299
complex enough,

494
00:17:55,769 --> 00:17:58,049
there is an ESB enterprise service

495
00:17:58,049 --> 00:18:00,108
bus that sit sits in between

496
00:18:00,608 --> 00:18:02,809
and makes these these services

497
00:18:02,809 --> 00:18:03,750
talk to each other.

498
00:18:04,059 --> 00:18:06,269
And of course, there's a lot of complexity

499
00:18:06,269 --> 00:18:08,420
or a period of time because we have added

500
00:18:08,420 --> 00:18:11,009
so many workflows, so many use cases.

501
00:18:11,650 --> 00:18:13,309
And then, of course, these

502
00:18:13,890 --> 00:18:16,430
services themselves, they do a lot,

503
00:18:16,588 --> 00:18:19,410
uh, because of the, um, uh,

504
00:18:19,529 --> 00:18:21,750
the complexity of workflows over a period of

505
00:18:21,750 --> 00:18:24,848
time. In

506
00:18:24,848 --> 00:18:27,150
order for us to actually

507
00:18:27,769 --> 00:18:28,848
solve this,

508
00:18:29,130 --> 00:18:31,410
one was the architecture of the way how

509
00:18:31,410 --> 00:18:33,910
the backing system was, and then

510
00:18:34,449 --> 00:18:36,689
I would say we can sell the challenges in

511
00:18:36,689 --> 00:18:37,539
fivefold.

512
00:18:38,130 --> 00:18:40,170
One, because we have to

513
00:18:40,170 --> 00:18:41,549
translating since we said

514
00:18:42,209 --> 00:18:44,328
the devices cannot be touched, there

515
00:18:44,328 --> 00:18:45,750
is a legacy API,

516
00:18:46,358 --> 00:18:48,489
and you know when APIs reside

517
00:18:48,489 --> 00:18:50,689
in your system for 10 years, you lose

518
00:18:50,689 --> 00:18:52,430
the documentation about them.

519
00:18:52,949 --> 00:18:55,299
Um, generally it's tribal knowledge.

520
00:18:55,759 --> 00:18:57,838
Somebody knows somewhere, you wouldn't have

521
00:18:57,838 --> 00:18:59,739
the full documentation to start with.

522
00:19:00,868 --> 00:19:02,939
And because these devices have been

523
00:19:02,939 --> 00:19:05,549
living in the field for so many years,

524
00:19:05,680 --> 00:19:07,920
there are multiple versions of the clients.

525
00:19:08,358 --> 00:19:10,358
So of course we know which client

526
00:19:10,358 --> 00:19:12,439
we are dealing with, but if you have

527
00:19:12,439 --> 00:19:14,509
20,000 devices and you have 7

528
00:19:14,509 --> 00:19:15,880
versions of the clients,

529
00:19:16,358 --> 00:19:18,559
you would have to understand how those

530
00:19:18,559 --> 00:19:20,618
clients behave when interacting with the back

531
00:19:20,618 --> 00:19:21,140
end system.

532
00:19:23,029 --> 00:19:25,009
And I was talking about how

533
00:19:25,430 --> 00:19:27,910
the workflows have become

534
00:19:27,910 --> 00:19:29,529
complex for just for

535
00:19:29,979 --> 00:19:31,989
heartbeat we have something called

536
00:19:31,989 --> 00:19:33,088
true reachability

537
00:19:33,348 --> 00:19:35,809
where we say whether a device is up and running

538
00:19:36,269 --> 00:19:38,209
and the devices sends a ping

539
00:19:38,588 --> 00:19:40,789
that particular workflow itself has become

540
00:19:40,789 --> 00:19:42,828
so complex even though somebody says oh

541
00:19:42,828 --> 00:19:44,969
just a ping to my back end system

542
00:19:45,469 --> 00:19:47,670
but. We will have to say whether

543
00:19:48,160 --> 00:19:50,309
is this device connecting from

544
00:19:50,309 --> 00:19:51,309
where it should be.

545
00:19:51,608 --> 00:19:53,769
Sometimes some of these devices do are,

546
00:19:53,890 --> 00:19:55,729
are mobile-based as well, right?

547
00:19:57,239 --> 00:19:59,640
And then of course we are in a compliance ecosystem,

548
00:19:59,759 --> 00:20:01,838
so anything we touch

549
00:20:02,318 --> 00:20:04,430
has to be compliant from a regulatory

550
00:20:04,430 --> 00:20:05,019
standpoint.

551
00:20:05,848 --> 00:20:06,789
And then

552
00:20:07,328 --> 00:20:07,868
the

553
00:20:08,130 --> 00:20:10,108
scale of the solution

554
00:20:10,368 --> 00:20:11,309
cannot be done

555
00:20:11,729 --> 00:20:13,239
at like one go,

556
00:20:13,578 --> 00:20:16,049
and I'll come to it in a minute because.

557
00:20:16,880 --> 00:20:19,509
As I was saying, these 20,000 devices,

558
00:20:19,598 --> 00:20:21,959
we cannot replicate them in our test

559
00:20:21,959 --> 00:20:22,549
environment.

560
00:20:22,880 --> 00:20:25,098
So this is production data that we are trying

561
00:20:25,098 --> 00:20:27,279
to deal with and in order for us

562
00:20:27,279 --> 00:20:27,818
to,

563
00:20:28,400 --> 00:20:29,068
um,

564
00:20:29,439 --> 00:20:31,779
figure out what is the best solution

565
00:20:31,779 --> 00:20:34,039
or the patterns that we want to apply

566
00:20:34,039 --> 00:20:34,709
for it,

567
00:20:35,039 --> 00:20:37,509
we have to understand how these systems

568
00:20:37,509 --> 00:20:38,939
in the field are behaving.

569
00:20:39,328 --> 00:20:41,410
We did not, we do not have a good

570
00:20:41,410 --> 00:20:42,588
digital twin

571
00:20:42,848 --> 00:20:45,049
kind of an ecosystem that we can play

572
00:20:45,049 --> 00:20:47,170
around and see, oh, this system behaves

573
00:20:47,170 --> 00:20:49,328
in this way with this version versus this

574
00:20:49,328 --> 00:20:50,189
system behaves,

575
00:20:50,539 --> 00:20:52,469
and this is, I'm talking about

576
00:20:52,769 --> 00:20:54,769
25 product lines over

577
00:20:54,769 --> 00:20:56,209
the last 10 years,

578
00:20:56,489 --> 00:20:58,969
so it, it just becomes

579
00:20:58,969 --> 00:20:59,769
complicated.

580
00:21:00,519 --> 00:21:02,568
So these were our challenges. I think I

581
00:21:02,568 --> 00:21:04,588
have introduced the use case. I will

582
00:21:04,588 --> 00:21:06,289
let Anand come in,

583
00:21:06,598 --> 00:21:08,608
dive a little bit deeper into some of the

584
00:21:08,608 --> 00:21:10,608
patterns that we would have

585
00:21:10,608 --> 00:21:12,578
leveraged or we would have thought

586
00:21:12,890 --> 00:21:14,250
best to solve this problem.

587
00:21:17,150 --> 00:21:17,680
Thanks, Renee.

588
00:21:22,199 --> 00:21:24,608
So what we saw, what Sydney just explained,

589
00:21:25,150 --> 00:21:27,250
what police was having earlier,

590
00:21:27,680 --> 00:21:29,750
a legacy machine to machine

591
00:21:29,750 --> 00:21:31,789
back end which has taken a form

592
00:21:31,789 --> 00:21:34,348
of typical monolithic right

593
00:21:34,670 --> 00:21:36,750
now the first thing

594
00:21:36,750 --> 00:21:37,689
we have to do is

595
00:21:37,949 --> 00:21:40,189
how we can decompose this monolithic

596
00:21:40,420 --> 00:21:42,068
into a more modular

597
00:21:42,709 --> 00:21:45,000
uh you know, decoupledle architecture, right?

598
00:21:45,430 --> 00:21:48,269
and. For

599
00:21:48,269 --> 00:21:50,709
that, let's look into how the EDA

600
00:21:50,709 --> 00:21:51,588
can help us,

601
00:21:51,989 --> 00:21:54,900
too. Define

602
00:21:55,039 --> 00:21:57,949
a new architectural style for a given monolithic

603
00:21:57,949 --> 00:21:59,959
application which is more even driven and

604
00:21:59,959 --> 00:22:00,539
more

605
00:22:00,900 --> 00:22:02,799
decoupled. So the first thing is

606
00:22:03,118 --> 00:22:05,259
you do not just go and decompose

607
00:22:05,259 --> 00:22:07,318
the application from its

608
00:22:07,318 --> 00:22:09,598
implementation perspective because whatever

609
00:22:09,598 --> 00:22:11,285
implementation you are doing. Whatever

610
00:22:12,045 --> 00:22:14,125
technology it is representing your business

611
00:22:14,125 --> 00:22:16,193
behaviors, so it's very important to

612
00:22:16,193 --> 00:22:18,564
understand your business processes first, your

613
00:22:18,564 --> 00:22:21,305
domain first, and then you try to rearchitect

614
00:22:21,404 --> 00:22:23,515
your existing business processes via

615
00:22:23,515 --> 00:22:26,045
applying the architectural patterns, right? So

616
00:22:26,045 --> 00:22:27,864
understanding of the domain is very important.

617
00:22:28,354 --> 00:22:28,943
Once you

618
00:22:29,275 --> 00:22:31,604
understood the domain, the second thing is then you

619
00:22:31,604 --> 00:22:33,799
design. The events

620
00:22:33,799 --> 00:22:35,920
around the domain because as I mentioned we are talking about

621
00:22:35,920 --> 00:22:37,920
the event event architecture so everything will

622
00:22:37,920 --> 00:22:40,199
go around the events it's become very

623
00:22:40,199 --> 00:22:42,358
important to identify what are the relevant.

624
00:22:43,469 --> 00:22:45,969
Domain events which matter the most

625
00:22:45,969 --> 00:22:48,709
for your business services for your customers,

626
00:22:49,108 --> 00:22:51,219
and once you have identified that then

627
00:22:51,229 --> 00:22:53,328
around those events you apply

628
00:22:53,549 --> 00:22:55,588
the right event driven architecture

629
00:22:55,588 --> 00:22:57,739
pattern as I mentioned EDA can be

630
00:22:57,739 --> 00:22:59,709
implemented in various different ways,

631
00:22:59,989 --> 00:23:02,019
right? It depend upon the nature of

632
00:23:02,019 --> 00:23:04,029
your workload, the nature of your business

633
00:23:04,029 --> 00:23:06,068
processes you adopt the

634
00:23:06,068 --> 00:23:08,068
right pattern according to your need.

635
00:23:08,299 --> 00:23:10,299
And last but not the least, once you've

636
00:23:10,299 --> 00:23:12,400
identified the pattern, you have the solution

637
00:23:12,400 --> 00:23:14,539
ready. Now implementation of

638
00:23:14,539 --> 00:23:16,838
that solution then happens via

639
00:23:17,259 --> 00:23:19,459
leveraging our AWS

640
00:23:19,459 --> 00:23:21,660
serverless, even even architectural

641
00:23:21,660 --> 00:23:23,368
services capacities, right?

642
00:23:24,578 --> 00:23:26,598
Which make it super fast to build

643
00:23:26,598 --> 00:23:29,098
the event driven architecture for your business

644
00:23:29,098 --> 00:23:30,150
applications, right?

645
00:23:30,519 --> 00:23:32,539
So let's first look into the domain.

646
00:23:32,618 --> 00:23:34,049
Let's start with the domain, right?

647
00:23:34,338 --> 00:23:36,358
Let's do the things architecturally

648
00:23:36,358 --> 00:23:37,259
right, right?

649
00:23:39,160 --> 00:23:41,199
So what is the toughest, toughest part? The

650
00:23:41,199 --> 00:23:42,250
toughest part

651
00:23:42,680 --> 00:23:45,199
is to how do we decompose

652
00:23:45,199 --> 00:23:47,578
this monolithic application into the more

653
00:23:47,670 --> 00:23:48,618
modular

654
00:23:49,239 --> 00:23:51,578
microservices based architecture,

655
00:23:51,719 --> 00:23:53,729
right? Now why it

656
00:23:53,729 --> 00:23:56,529
is important, it is important because as we know, monolithic

657
00:23:56,529 --> 00:23:58,098
applications are complex.

658
00:23:58,410 --> 00:24:00,239
They have a lot of challenges though

659
00:24:00,769 --> 00:24:03,130
in terms of their scalability. If you have to scale

660
00:24:03,130 --> 00:24:04,029
any part of the,

661
00:24:04,289 --> 00:24:06,410
uh, monothic application, you end up deploying

662
00:24:06,410 --> 00:24:08,650
the entire application which increased a lot of

663
00:24:08,650 --> 00:24:10,750
operational overhead has also increased your cost

664
00:24:11,009 --> 00:24:11,868
and as well as

665
00:24:12,598 --> 00:24:14,729
any issue in any part of your application

666
00:24:15,088 --> 00:24:17,289
may. Bog down the

667
00:24:17,289 --> 00:24:19,449
entire application so it also impact your business

668
00:24:19,449 --> 00:24:20,529
continuity, right?

669
00:24:20,890 --> 00:24:23,318
So they're not scalable, they're not reliable, right?

670
00:24:23,410 --> 00:24:25,930
Operational also there are challenges with the monolithics.

671
00:24:25,969 --> 00:24:28,199
It's always better to transform these monolithic

672
00:24:28,199 --> 00:24:30,250
into the more modern architecture like a

673
00:24:30,250 --> 00:24:32,250
microservices based architecture, like an event

674
00:24:32,250 --> 00:24:33,709
driven based architecture, and how

675
00:24:34,009 --> 00:24:35,930
this can be. But the question is

676
00:24:36,410 --> 00:24:39,000
how do I break my legacy monolithic

677
00:24:39,000 --> 00:24:39,969
application you talked about, OK,

678
00:24:40,328 --> 00:24:41,140
understand the domain.

679
00:24:41,449 --> 00:24:43,689
How will I understand the domain? Who can

680
00:24:43,689 --> 00:24:45,049
help me to understand the domain?

681
00:24:45,509 --> 00:24:46,939
What is the process around it? So,

682
00:24:47,229 --> 00:24:49,250
so. What happens

683
00:24:50,029 --> 00:24:52,029
often we have seen the

684
00:24:52,029 --> 00:24:54,229
application owners, they go, they start

685
00:24:54,229 --> 00:24:56,269
the journey of decomposing any monolithic

686
00:24:56,269 --> 00:24:58,430
into the more decoupled architectures,

687
00:24:58,509 --> 00:25:00,509
but they fall into certain pitfalls. Now

688
00:25:00,509 --> 00:25:02,699
what are those pitfalls? The very first pit pitfall

689
00:25:02,699 --> 00:25:04,068
is the distributed monolithic.

690
00:25:04,578 --> 00:25:06,588
They try to and distributed monolithic

691
00:25:06,588 --> 00:25:08,789
can happen via applying the horizontal

692
00:25:08,789 --> 00:25:10,789
tiering. What the application owners try to

693
00:25:10,789 --> 00:25:12,949
do, they try to group the related

694
00:25:12,949 --> 00:25:15,259
components, the similar components of the

695
00:25:15,259 --> 00:25:17,309
application together and then carve out the

696
00:25:17,309 --> 00:25:18,549
different. Uh,

697
00:25:18,809 --> 00:25:21,098
different Smaller

698
00:25:21,098 --> 00:25:23,489
smaller sub module out of your monolithic

699
00:25:23,489 --> 00:25:24,049
application, right?

700
00:25:24,380 --> 00:25:26,539
And then they try to decompose this

701
00:25:26,539 --> 00:25:27,618
application in this way, right?

702
00:25:27,979 --> 00:25:30,279
So they take a monolithic, they try to

703
00:25:30,640 --> 00:25:32,699
merge the similar components which are

704
00:25:32,699 --> 00:25:33,598
interacting to each other

705
00:25:33,858 --> 00:25:35,890
in a single group, and they try to converge

706
00:25:35,890 --> 00:25:37,199
into the smaller, smaller

707
00:25:37,459 --> 00:25:38,920
sub module of the application

708
00:25:39,328 --> 00:25:41,809
which again take a shape of the smaller monolithic

709
00:25:41,809 --> 00:25:43,818
application and they all inherit the challenges

710
00:25:43,818 --> 00:25:45,818
of otherwise the monolithic application

711
00:25:45,818 --> 00:25:48,118
have. The 2nd pitfall

712
00:25:48,118 --> 00:25:50,118
in which the application owner falls into

713
00:25:50,118 --> 00:25:51,358
is the nanoservices,

714
00:25:51,799 --> 00:25:53,880
and that happens by applying the vertical tiering.

715
00:25:54,368 --> 00:25:56,630
So they look into the different functionality

716
00:25:56,769 --> 00:25:58,900
from the UI perspective, from the web

717
00:25:58,900 --> 00:26:01,279
user interface perspective, how the end user is interacting

718
00:26:01,279 --> 00:26:01,949
with their application,

719
00:26:02,328 --> 00:26:04,509
and they try to split the application functionality

720
00:26:04,689 --> 00:26:06,969
based on those UI screens. And imagine

721
00:26:06,969 --> 00:26:09,729
an app if you have an application which has 100,000s

722
00:26:09,729 --> 00:26:11,759
of the uh user features, right,

723
00:26:11,930 --> 00:26:13,930
or the screens, then you may end up having

724
00:26:13,930 --> 00:26:15,930
multiple services, and that creates a lot

725
00:26:15,930 --> 00:26:17,568
of chattiness in your environment.

726
00:26:18,009 --> 00:26:19,250
So how this works, sorry.

727
00:26:20,219 --> 00:26:22,368
So you have a monolithic and you are actually

728
00:26:22,368 --> 00:26:24,818
decomposing into the multiple smaller granular

729
00:26:24,818 --> 00:26:25,759
services and

730
00:26:26,759 --> 00:26:28,759
that create operational overhead because managing

731
00:26:29,170 --> 00:26:31,299
uh many services are challenging at the same

732
00:26:31,299 --> 00:26:33,380
time you also need

733
00:26:33,380 --> 00:26:35,420
to think about the lot of chattiness with

734
00:26:35,420 --> 00:26:37,680
this application can create in the environment

735
00:26:37,858 --> 00:26:39,979
and that's where the right granularity is

736
00:26:39,979 --> 00:26:42,059
a key. So how do we achieve this right

737
00:26:42,059 --> 00:26:43,019
granularity?

738
00:26:43,328 --> 00:26:45,160
So the right granularity can be achieved

739
00:26:45,439 --> 00:26:47,640
when we have a right understanding

740
00:26:48,059 --> 00:26:48,959
of our domain.

741
00:26:50,279 --> 00:26:52,469
From the business owner and the

742
00:26:52,469 --> 00:26:54,598
application owners, so if our

743
00:26:54,598 --> 00:26:56,979
business owners and the application owners

744
00:26:57,318 --> 00:26:59,439
are having the common understanding of the

745
00:26:59,439 --> 00:26:59,989
domain,

746
00:27:00,279 --> 00:27:02,900
then they can define the right boundaries

747
00:27:03,160 --> 00:27:05,160
and the right granularity in which

748
00:27:05,160 --> 00:27:07,358
any given monolithic applications should get

749
00:27:07,358 --> 00:27:08,229
decomposed.

750
00:27:08,519 --> 00:27:10,559
And one such architectural practice and the

751
00:27:10,559 --> 00:27:12,920
methodologies we have seen customers using.

752
00:27:13,160 --> 00:27:14,939
Is a domain driven design

753
00:27:15,239 --> 00:27:17,358
which was first talked about by the Eric Ivan.

754
00:27:17,920 --> 00:27:19,799
What did he mention? He mentioned

755
00:27:20,160 --> 00:27:21,420
for any software development.

756
00:27:22,358 --> 00:27:24,328
The technology should not be the first focus.

757
00:27:24,670 --> 00:27:27,059
Rather, the business process and the activities

758
00:27:27,318 --> 00:27:29,598
which need to get supported by the

759
00:27:29,598 --> 00:27:31,598
technology should be the focus, right? So

760
00:27:31,598 --> 00:27:33,640
the domain driven design help us

761
00:27:33,640 --> 00:27:35,989
to get the details

762
00:27:35,989 --> 00:27:38,390
around the domain and bring the

763
00:27:38,390 --> 00:27:40,549
application owners, the domain owners and the domain expert

764
00:27:40,549 --> 00:27:42,279
and the application expert and application owner.

765
00:27:43,045 --> 00:27:45,055
On the same understanding, right, so that they

766
00:27:45,055 --> 00:27:47,074
can take the right decision. Take example of

767
00:27:47,324 --> 00:27:49,525
health care, the use case what we are talking about

768
00:27:49,884 --> 00:27:51,414
for us, the domain is healthcare.

769
00:27:51,733 --> 00:27:53,973
Under that domain there could be a multiple

770
00:27:53,973 --> 00:27:56,094
subdomains. For example, we are talking, we

771
00:27:56,094 --> 00:27:57,834
are taking a case of critical

772
00:27:58,174 --> 00:28:00,295
medical healthcare devices around

773
00:28:00,295 --> 00:28:02,493
imaging, for example, X-rays, right?

774
00:28:02,814 --> 00:28:05,015
And then, so this, these become the imaging

775
00:28:05,015 --> 00:28:06,174
become the one of the subdomain.

776
00:28:06,509 --> 00:28:08,549
And under the subdomain you need to define what

777
00:28:08,549 --> 00:28:10,588
are some of the core functionality which matter

778
00:28:10,588 --> 00:28:12,900
the most for my business which I want to transform,

779
00:28:12,949 --> 00:28:15,029
which I want to decompose, right? So

780
00:28:15,029 --> 00:28:17,229
this analysis can be done

781
00:28:17,229 --> 00:28:19,229
using the domain driven design. I'm

782
00:28:19,229 --> 00:28:21,549
not going to go into the much detail of this

783
00:28:21,549 --> 00:28:23,890
subject because you can have your.

784
00:28:24,459 --> 00:28:26,549
Uh, you know, the, uh, reading around

785
00:28:26,549 --> 00:28:28,568
this topic, uh, right, uh, I recommend

786
00:28:28,568 --> 00:28:30,630
that, uh, you know, go through the, what are the

787
00:28:30,630 --> 00:28:32,729
some of the design principle around the domain

788
00:28:32,729 --> 00:28:34,949
driven design, but this helps, right, the business

789
00:28:34,949 --> 00:28:37,009
owner and, uh, applicationer to

790
00:28:37,209 --> 00:28:38,709
have the shared understanding, right?

791
00:28:40,189 --> 00:28:43,380
But OK,

792
00:28:43,539 --> 00:28:45,519
domain driven design can help us to

793
00:28:45,979 --> 00:28:46,920
understand the domain,

794
00:28:47,420 --> 00:28:49,568
right, but, uh, Alberto Brandolini,

795
00:28:49,660 --> 00:28:51,939
right, he's the inventor of the event storming,

796
00:28:52,098 --> 00:28:53,180
he's, he.

797
00:28:54,009 --> 00:28:55,739
Mention a very interesting quote

798
00:28:56,130 --> 00:28:58,368
like whatever goes into the production is

799
00:28:58,368 --> 00:29:00,559
not always the expert knowledge of the domain

800
00:29:00,559 --> 00:29:02,930
expert rather the understanding

801
00:29:02,930 --> 00:29:05,170
or misunderstanding of the developers, and

802
00:29:05,170 --> 00:29:07,328
that's what's happened. You need to make sure

803
00:29:07,328 --> 00:29:09,328
your application owners are understanding

804
00:29:09,328 --> 00:29:10,019
your domain,

805
00:29:10,449 --> 00:29:12,650
uh, perfectly fine according to the

806
00:29:12,650 --> 00:29:14,689
business owners need and the business

807
00:29:14,689 --> 00:29:16,170
owners are also aligned to that.

808
00:29:16,568 --> 00:29:18,328
And how do we get that?

809
00:29:18,608 --> 00:29:20,818
How do we convert our application owners or

810
00:29:20,880 --> 00:29:22,309
application team into the domain expert?

811
00:29:22,818 --> 00:29:24,598
One of the ways to do this is.

812
00:29:25,910 --> 00:29:26,608
leveraging

813
00:29:27,789 --> 00:29:29,989
The events and

814
00:29:29,989 --> 00:29:31,989
start understanding the domain by

815
00:29:31,989 --> 00:29:34,269
identifying the different

816
00:29:34,269 --> 00:29:36,309
events which are happening in your

817
00:29:36,309 --> 00:29:38,430
business processes and that's where we are going

818
00:29:38,430 --> 00:29:40,818
to talk about the second phase of the event driven architecture

819
00:29:40,818 --> 00:29:43,029
journey now that how do we design these

820
00:29:43,029 --> 00:29:45,150
events and how we can design and identify

821
00:29:45,150 --> 00:29:46,348
the events right?

822
00:29:46,699 --> 00:29:48,309
uh, for your given application.

823
00:29:49,189 --> 00:29:51,219
That can be done by using event storming,

824
00:29:51,509 --> 00:29:53,630
right? And event storming is

825
00:29:53,630 --> 00:29:55,789
another architectural methodology which can

826
00:29:55,789 --> 00:29:58,289
be adopted to identify

827
00:29:58,469 --> 00:30:00,529
the different events which are happening in your system.

828
00:30:00,630 --> 00:30:02,709
Let's take the example of the event could be the divide

829
00:30:02,709 --> 00:30:04,838
got registered right now. And

830
00:30:05,059 --> 00:30:07,289
what are the commands which are actually

831
00:30:07,390 --> 00:30:09,529
got exec which are getting executed in your system

832
00:30:09,529 --> 00:30:11,789
to generate those events? Who are the producer of those

833
00:30:11,789 --> 00:30:13,949
events? Who should be the consumer of those events?

834
00:30:14,170 --> 00:30:16,358
What should be the some external system which

835
00:30:16,358 --> 00:30:18,358
should care about those events? So all

836
00:30:18,358 --> 00:30:20,729
this analysis can be done by using

837
00:30:20,729 --> 00:30:22,920
event storming. Now event storming is again

838
00:30:22,920 --> 00:30:25,078
like a domain event design is architectural style

839
00:30:25,078 --> 00:30:27,239
is a methodology. I will encourage you

840
00:30:27,239 --> 00:30:29,400
to go through it so that you can

841
00:30:29,400 --> 00:30:31,618
apply this pattern to identify,

842
00:30:31,789 --> 00:30:32,318
uh,

843
00:30:32,880 --> 00:30:34,880
in your business requirement and so that you

844
00:30:34,880 --> 00:30:37,078
can get a right shared understanding

845
00:30:37,078 --> 00:30:37,779
of your given,

846
00:30:38,118 --> 00:30:39,410
uh, business domain, right?

847
00:30:40,459 --> 00:30:42,500
So what happens, so decomposition, how

848
00:30:42,500 --> 00:30:43,989
it happens, so it happens via.

849
00:30:44,910 --> 00:30:47,229
Domain event, so we call it as a domain

850
00:30:47,229 --> 00:30:49,640
driven, uh, you know, domain event

851
00:30:50,068 --> 00:30:52,108
driven decomposition. So in this

852
00:30:52,108 --> 00:30:54,180
case domain driven design and the event

853
00:30:54,180 --> 00:30:54,809
storming.

854
00:30:55,199 --> 00:30:57,529
The knowledge of both the architectural

855
00:30:57,529 --> 00:30:59,309
mythologies can come together

856
00:30:59,608 --> 00:31:02,049
to identify the right microservices boundaries

857
00:31:02,049 --> 00:31:04,779
for you. How this happened, you perform the domain analysis

858
00:31:05,130 --> 00:31:07,489
and then you apply the event storming

859
00:31:07,489 --> 00:31:09,630
in that domain to identify the

860
00:31:10,049 --> 00:31:12,049
respective events and then from

861
00:31:12,049 --> 00:31:14,449
there you go into the respective bounded context.

862
00:31:14,880 --> 00:31:16,892
So each domain service. Will have its own

863
00:31:16,892 --> 00:31:18,952
context under which it wants to

864
00:31:18,952 --> 00:31:20,952
perform the certain capabilities, right? For

865
00:31:20,952 --> 00:31:23,311
example, if I have a device registration service, what

866
00:31:23,311 --> 00:31:25,593
should be the capability of the device registration service?

867
00:31:25,791 --> 00:31:27,952
What are the tasks is supposed to do? So

868
00:31:27,952 --> 00:31:30,672
that understanding is nothing but the bounded context

869
00:31:30,672 --> 00:31:32,952
which can be arrived using using this

870
00:31:32,952 --> 00:31:35,002
particular methodology. And last but not the

871
00:31:35,002 --> 00:31:37,061
least, each bounded context then converge

872
00:31:37,061 --> 00:31:39,375
into. The right microservices, right? So

873
00:31:39,375 --> 00:31:41,415
let's look into the one example how the event

874
00:31:41,415 --> 00:31:43,494
storming output can look like for

875
00:31:43,494 --> 00:31:45,134
a device registration flow.

876
00:31:45,494 --> 00:31:47,556
So we identify in event storming

877
00:31:47,556 --> 00:31:49,734
exercise who are the actor. Actor could be a

878
00:31:49,734 --> 00:31:51,776
device. It could be a machine. It could be the user

879
00:31:51,776 --> 00:31:53,816
in our Phillips Healthcare use

880
00:31:53,816 --> 00:31:55,855
case, it is a device who is currently

881
00:31:55,855 --> 00:31:57,935
going to emit some events, so it become a

882
00:31:57,935 --> 00:31:59,318
producer. Now

883
00:31:59,858 --> 00:32:00,519
device

884
00:32:01,059 --> 00:32:02,140
perform a command.

885
00:32:02,420 --> 00:32:04,719
Let's say register me, register device.

886
00:32:05,019 --> 00:32:07,338
It's a new device which is getting onboarded to any medical

887
00:32:07,338 --> 00:32:09,618
facility, it will emit a command register

888
00:32:09,618 --> 00:32:11,699
me. Then this command will

889
00:32:11,699 --> 00:32:12,400
actually

890
00:32:12,838 --> 00:32:15,479
produce some event. OK, the device is registered

891
00:32:15,818 --> 00:32:17,160
and this event

892
00:32:17,420 --> 00:32:19,650
may have some 10 business policies.

893
00:32:19,818 --> 00:32:21,979
For example, before registering the device,

894
00:32:22,219 --> 00:32:23,939
validate the device

895
00:32:24,219 --> 00:32:24,799
is.

896
00:32:26,229 --> 00:32:27,250
The device is ready to get

897
00:32:28,140 --> 00:32:30,670
on boarded so that the medical

898
00:32:30,670 --> 00:32:32,890
information, clinical information get get start

899
00:32:32,890 --> 00:32:34,890
getting exchanged from the device. So we

900
00:32:34,890 --> 00:32:36,989
identify the business policy and

901
00:32:37,209 --> 00:32:39,209
there could be uh external systems

902
00:32:39,209 --> 00:32:41,309
as well for uh right, uh,

903
00:32:41,449 --> 00:32:43,449
who also care about those events. So

904
00:32:43,449 --> 00:32:45,549
when the device is registered, maybe

905
00:32:45,848 --> 00:32:48,108
the connection is established and the external system

906
00:32:48,328 --> 00:32:50,150
want to then start communicating

907
00:32:50,489 --> 00:32:52,430
with your different back end processes.

908
00:32:52,930 --> 00:32:55,039
And consume that information which has been

909
00:32:55,039 --> 00:32:57,098
emitted by the device. So this,

910
00:32:57,289 --> 00:32:59,719
the entire domain driven design and even storming analysis

911
00:32:59,719 --> 00:33:01,799
can help you to define these workflows, and

912
00:33:01,799 --> 00:33:04,039
these workflows will be defined by your application owner

913
00:33:04,039 --> 00:33:06,299
and the business owner together. And then

914
00:33:06,640 --> 00:33:09,039
this, the intent here is you combine

915
00:33:09,039 --> 00:33:11,039
the related domain events and

916
00:33:11,039 --> 00:33:12,979
then convert to the granular

917
00:33:13,239 --> 00:33:15,368
boundaries and the granular microservices.

918
00:33:15,640 --> 00:33:17,759
So with this and what we do, what

919
00:33:17,759 --> 00:33:20,259
we did, we applied the same design principle,

920
00:33:20,338 --> 00:33:22,108
domain domain design and even test storming.

921
00:33:22,363 --> 00:33:24,472
In the Philips legacy

922
00:33:25,402 --> 00:33:27,883
machine to machine back end system and then we converge

923
00:33:27,883 --> 00:33:30,172
into the different services

924
00:33:30,172 --> 00:33:32,172
with the right granularity so we

925
00:33:32,172 --> 00:33:34,212
could converge to the services, for

926
00:33:34,212 --> 00:33:36,252
example, registration service which take care of the

927
00:33:36,252 --> 00:33:37,252
registering the device,

928
00:33:37,531 --> 00:33:39,603
the alert service where the when the

929
00:33:39,603 --> 00:33:41,732
device send the alerts how to consume and how to act on

930
00:33:41,732 --> 00:33:43,853
that, the file transfer because these

931
00:33:43,853 --> 00:33:45,892
devices will be keep sending the data

932
00:33:45,892 --> 00:33:48,172
at a certain frequency, how we can consume

933
00:33:48,172 --> 00:33:49,192
that and process them,

934
00:33:49,492 --> 00:33:51,021
and the polling service as.

935
00:33:51,464 --> 00:33:53,546
I was mentioning for you know checking the

936
00:33:53,546 --> 00:33:55,546
health of the devices and then there was

937
00:33:55,546 --> 00:33:57,615
a communication which was happening

938
00:33:57,615 --> 00:33:59,615
between these devices via applying the synchronous

939
00:33:59,615 --> 00:34:01,625
architecture or even even architecture which

940
00:34:01,625 --> 00:34:03,046
we'll see in a moment right

941
00:34:03,345 --> 00:34:05,505
now what advantage we get by applying

942
00:34:05,505 --> 00:34:07,744
these architectural techniques and the methodologies

943
00:34:07,744 --> 00:34:09,905
we converse to the microservices which does

944
00:34:09,905 --> 00:34:12,226
not do which does not perform multiple

945
00:34:12,226 --> 00:34:14,304
things which does uh one thing but

946
00:34:14,304 --> 00:34:16,706
one thing right, and it has its own APIs,

947
00:34:16,746 --> 00:34:18,726
its own business logic, its own data

948
00:34:19,144 --> 00:34:19,726
under which

949
00:34:19,985 --> 00:34:20,666
it actually.

950
00:34:21,409 --> 00:34:23,329
Uh, get, uh, deployed.

951
00:34:23,820 --> 00:34:25,989
So what are the benefit we get with the,

952
00:34:26,570 --> 00:34:28,889
uh, microservices based architecture? You

953
00:34:28,889 --> 00:34:30,478
can independently build them,

954
00:34:30,769 --> 00:34:33,128
you know, independently deploy them and independently

955
00:34:33,128 --> 00:34:34,360
scale them, right?

956
00:34:34,639 --> 00:34:36,769
And they, you can then leverage

957
00:34:36,769 --> 00:34:38,668
the power of the elastic, um.

958
00:34:39,360 --> 00:34:41,559
Infrastructure from cloud to accordingly

959
00:34:41,559 --> 00:34:43,878
scale them based on, you know, your business

960
00:34:43,878 --> 00:34:46,360
needs and you can make them as a reusable

961
00:34:46,519 --> 00:34:48,179
um uh you can apply

962
00:34:48,559 --> 00:34:50,739
them apply on them a usable pattern

963
00:34:50,739 --> 00:34:52,760
you can deploy them as a container you can deploy them

964
00:34:52,760 --> 00:34:54,280
as a serverless architecture, right?

965
00:34:54,539 --> 00:34:56,713
A lot thing can be done, uh. When

966
00:34:56,713 --> 00:34:58,733
you converge to the modern microservices

967
00:34:58,733 --> 00:35:00,313
based architecture.

968
00:35:00,864 --> 00:35:03,114
Now we have converged from a

969
00:35:03,114 --> 00:35:05,492
legacy API driven monolithic

970
00:35:05,492 --> 00:35:08,143
to the API driven microservices,

971
00:35:08,313 --> 00:35:09,273
but is it enough?

972
00:35:09,673 --> 00:35:11,914
Are we saying that my architecture is now having

973
00:35:11,914 --> 00:35:13,572
all the right patterns in the tenants?

974
00:35:14,860 --> 00:35:15,579
Maybe not.

975
00:35:16,010 --> 00:35:18,010
Why? Because each architecture has

976
00:35:18,010 --> 00:35:19,329
got its own consideration.

977
00:35:19,688 --> 00:35:21,449
Modern thing was having some considerations.

978
00:35:21,809 --> 00:35:22,789
We solve those using

979
00:35:23,079 --> 00:35:25,809
micro surfaces based architecture, but the microservices

980
00:35:25,809 --> 00:35:28,090
based architecture also requires certain considerations.

981
00:35:28,250 --> 00:35:29,059
Now what are those?

982
00:35:29,360 --> 00:35:30,829
Let's dig into those.

983
00:35:32,099 --> 00:35:34,438
How the services communicate with each other.

984
00:35:35,059 --> 00:35:36,398
Each microservice

985
00:35:36,898 --> 00:35:38,800
will be communicating over each other

986
00:35:39,320 --> 00:35:40,148
over a network.

987
00:35:40,458 --> 00:35:42,610
Now let's say for a given business

988
00:35:42,610 --> 00:35:44,898
process there are multiple service services

989
00:35:44,898 --> 00:35:46,119
need to act together

990
00:35:46,530 --> 00:35:48,978
and they need to work together, communicate together

991
00:35:48,978 --> 00:35:51,059
for the fulfillment of fulfillment of that request. So

992
00:35:51,059 --> 00:35:53,179
how it will happen? Service A communicating with the service

993
00:35:53,179 --> 00:35:55,300
B. Service B, go and reach

994
00:35:55,300 --> 00:35:57,309
out to the service C, and the response

995
00:35:57,309 --> 00:35:57,849
is then

996
00:35:58,148 --> 00:35:59,829
written back in the reverse manner.

997
00:36:00,119 --> 00:36:02,309
Now there could be a different possibilities,

998
00:36:02,389 --> 00:36:04,409
right? What if the, if the service B goes down?

999
00:36:04,510 --> 00:36:05,989
What if the service C is slow?

1000
00:36:06,269 --> 00:36:08,329
So a lot of different design considerations which

1001
00:36:08,329 --> 00:36:10,389
are also need to be. Consider when we are building

1002
00:36:10,389 --> 00:36:12,688
a microservices based architecture. So

1003
00:36:12,989 --> 00:36:15,099
one choice is consistency versus ability

1004
00:36:15,099 --> 00:36:16,489
standard cap theorem problem.

1005
00:36:16,750 --> 00:36:18,829
Do you want all your system to see the same

1006
00:36:18,829 --> 00:36:20,918
consistent state versus you want your

1007
00:36:20,918 --> 00:36:23,050
system to be always available to react

1008
00:36:23,349 --> 00:36:24,188
for the requests.

1009
00:36:24,809 --> 00:36:26,340
The latency versus throughput,

1010
00:36:26,688 --> 00:36:28,809
what matters the most, the how fast you

1011
00:36:28,809 --> 00:36:31,228
get the response versus how many requests

1012
00:36:31,369 --> 00:36:33,409
you can manage, right, for a given system.

1013
00:36:33,728 --> 00:36:35,809
The coupling versus performance, the more it

1014
00:36:35,809 --> 00:36:38,148
is tightly coupled, the performance is

1015
00:36:38,289 --> 00:36:40,349
you can achieve a better performance, but

1016
00:36:40,530 --> 00:36:42,639
you are also increasing the tight couple, uh,

1017
00:36:42,688 --> 00:36:44,889
the tight integration between your component,

1018
00:36:45,010 --> 00:36:47,369
right? And then definitely if your

1019
00:36:47,369 --> 00:36:49,409
complex business flows required a

1020
00:36:49,409 --> 00:36:51,570
transactionality means multiple systems

1021
00:36:51,570 --> 00:36:52,590
need to act together

1022
00:36:52,889 --> 00:36:55,039
in the atomicity, consistency, isolation,

1023
00:36:55,059 --> 00:36:57,489
and durability that become the complex affair

1024
00:36:57,489 --> 00:36:58,329
as well, right?

1025
00:36:59,449 --> 00:37:01,570
So how do we handle this, and that's

1026
00:37:01,570 --> 00:37:03,829
where we need to apply the right event

1027
00:37:03,829 --> 00:37:06,010
driven architecture pattern to solve

1028
00:37:06,010 --> 00:37:08,289
some of these challenges in the modern

1029
00:37:08,289 --> 00:37:10,438
complex distributed microservices systems.

1030
00:37:10,769 --> 00:37:13,030
And now let's look into some of those

1031
00:37:13,530 --> 00:37:15,050
event driven architecture patterns.

1032
00:37:16,878 --> 00:37:19,159
So very so as we know the, the,

1033
00:37:19,208 --> 00:37:21,239
the, the, the concept of the inventive

1034
00:37:21,239 --> 00:37:23,239
architecture, as I mentioned, there are producers,

1035
00:37:23,449 --> 00:37:24,309
there are consumer,

1036
00:37:24,648 --> 00:37:26,648
producer emit the event, consumer consume

1037
00:37:26,648 --> 00:37:28,918
the event, right now we need to

1038
00:37:28,918 --> 00:37:31,128
see how we solve this puzzle, how the communication

1039
00:37:31,128 --> 00:37:33,208
from producer to the consumer should happen over

1040
00:37:33,208 --> 00:37:35,329
the events and what are the different ways in which

1041
00:37:35,329 --> 00:37:36,090
it can happen.

1042
00:37:36,489 --> 00:37:38,489
So it's, so one of the way it

1043
00:37:38,489 --> 00:37:39,628
should happen is

1044
00:37:39,889 --> 00:37:41,510
the cue-based communication.

1045
00:37:41,969 --> 00:37:44,250
So you have the producers or the senders who

1046
00:37:44,250 --> 00:37:46,110
are sending the messages and.

1047
00:37:46,829 --> 00:37:49,030
Those messages are receivers

1048
00:37:49,030 --> 00:37:49,869
receiving it

1049
00:37:50,228 --> 00:37:52,550
over a queue, so there is a queue in between, and

1050
00:37:52,550 --> 00:37:54,668
this queue is actually storing those messages

1051
00:37:54,949 --> 00:37:55,599
and then

1052
00:37:55,949 --> 00:37:58,030
each consumer is consuming these messages from

1053
00:37:58,030 --> 00:38:00,398
the queue. Now this kind of patterns are

1054
00:38:00,398 --> 00:38:02,628
useful where you need to have some

1055
00:38:02,628 --> 00:38:04,889
sort of a transactionality involved where you want

1056
00:38:05,030 --> 00:38:07,110
a single message to be consumed by

1057
00:38:07,110 --> 00:38:07,820
the single. Single,

1058
00:38:08,168 --> 00:38:10,489
uh, single message should be consumed by the single consumer

1059
00:38:10,489 --> 00:38:11,360
itself. For example,

1060
00:38:11,918 --> 00:38:14,148
if my devices are emitting an event

1061
00:38:14,148 --> 00:38:15,449
like register device,

1062
00:38:15,769 --> 00:38:17,809
then I do not want the device

1063
00:38:17,809 --> 00:38:19,929
to get registered multiple times. So I need

1064
00:38:19,929 --> 00:38:21,530
that transactional ID. I want that

1065
00:38:21,849 --> 00:38:23,929
that particular registered device message to

1066
00:38:23,929 --> 00:38:25,469
get consumed once and

1067
00:38:25,889 --> 00:38:26,579
processed ones.

1068
00:38:26,969 --> 00:38:28,148
So this kind of.

1069
00:38:28,688 --> 00:38:30,789
Architecture help us to define those

1070
00:38:31,050 --> 00:38:33,289
uh uh you know, to handle

1071
00:38:33,289 --> 00:38:35,530
those use cases in our Phyllis

1072
00:38:35,530 --> 00:38:37,780
RSG use case. The second is the stream

1073
00:38:37,780 --> 00:38:39,510
based in certain scenario

1074
00:38:39,769 --> 00:38:41,969
where what happens you have senders

1075
00:38:41,969 --> 00:38:44,500
who are emitting the events or the messages

1076
00:38:44,849 --> 00:38:45,469
you

1077
00:38:45,728 --> 00:38:48,110
may want to replay them more. Than

1078
00:38:48,110 --> 00:38:49,128
once, for example,

1079
00:38:49,389 --> 00:38:51,679
if the device is sending certain alert, you

1080
00:38:51,679 --> 00:38:53,789
want to keep notifying the end user

1081
00:38:53,789 --> 00:38:55,809
or the admin or the relative staff

1082
00:38:56,030 --> 00:38:58,110
to fix that problem. There are some challenges

1083
00:38:58,110 --> 00:39:00,409
and you want to do that at a certain frequency,

1084
00:39:00,469 --> 00:39:01,329
so you want to

1085
00:39:01,750 --> 00:39:04,070
replay the event right at certain frequency.

1086
00:39:04,148 --> 00:39:06,148
So you will leverage the stream-based,

1087
00:39:06,469 --> 00:39:08,550
uh, communication between

1088
00:39:08,550 --> 00:39:10,289
the producer and the consumer.

1089
00:39:10,628 --> 00:39:12,668
AWS help you to build

1090
00:39:12,668 --> 00:39:15,239
this. Pull base, uh,

1091
00:39:15,340 --> 00:39:17,369
uh, you know, the event, uh,

1092
00:39:17,378 --> 00:39:19,780
driven architecture via providing the AWS native

1093
00:39:19,780 --> 00:39:21,478
services like Amazon SQS.

1094
00:39:22,519 --> 00:39:24,789
From the queuing perspective and from the streaming

1095
00:39:24,789 --> 00:39:27,059
perspective it is Amazon uh

1096
00:39:27,139 --> 00:39:27,780
Kinesis

1097
00:39:28,199 --> 00:39:30,360
and from the menaces if you want

1098
00:39:30,360 --> 00:39:32,898
open source, uh, uh,

1099
00:39:32,909 --> 00:39:35,519
uh, technology to to define your EDA architecture,

1100
00:39:35,599 --> 00:39:37,648
then it could be done by using Amazon MQ,

1101
00:39:38,280 --> 00:39:40,438
uh, from the queuing perspective and from the streaming

1102
00:39:40,438 --> 00:39:42,438
perspective we also have a manage

1103
00:39:42,438 --> 00:39:43,489
service for Kafka.

1104
00:39:45,369 --> 00:39:47,369
Right, so this so

1105
00:39:47,369 --> 00:39:49,449
far what we have seen is the pool-based architecture.

1106
00:39:49,570 --> 00:39:51,809
What does it mean? Here the consumer are actually

1107
00:39:51,809 --> 00:39:54,050
pulling the information. The consumer will pull

1108
00:39:54,050 --> 00:39:56,128
the messages from the queue. The consumer

1109
00:39:56,128 --> 00:39:58,599
will pull the messages from the stream,

1110
00:39:58,809 --> 00:40:01,128
right? So in this case, the consumer is actually

1111
00:40:01,128 --> 00:40:02,469
taking the additional,

1112
00:40:02,780 --> 00:40:04,849
uh, behavior of pulling

1113
00:40:04,849 --> 00:40:07,155
the messages. Trying the messages right

1114
00:40:07,434 --> 00:40:09,793
now let's also look into the, the other architectural

1115
00:40:09,793 --> 00:40:11,253
pattern which is a push base.

1116
00:40:11,664 --> 00:40:13,824
Now again we have a same producer of the

1117
00:40:13,824 --> 00:40:16,074
event on the left hand side and we have a

1118
00:40:16,074 --> 00:40:17,894
consumer of the messages on the right hand side

1119
00:40:18,425 --> 00:40:20,813
now but in this case we introduce

1120
00:40:21,034 --> 00:40:22,974
a concept called service bus.

1121
00:40:23,394 --> 00:40:25,135
So what this service bus does.

1122
00:40:25,688 --> 00:40:27,769
Leveraging the service was we can configure

1123
00:40:27,769 --> 00:40:29,039
the different rules

1124
00:40:29,309 --> 00:40:31,458
for all the ingress events

1125
00:40:31,458 --> 00:40:32,398
and we can define

1126
00:40:32,860 --> 00:40:35,300
for based on the rule validation

1127
00:40:35,300 --> 00:40:37,570
what should be the probable target to

1128
00:40:37,570 --> 00:40:39,570
which these events should go uh for the

1129
00:40:39,570 --> 00:40:41,619
consumer and that's that is

1130
00:40:41,619 --> 00:40:43,619
called an event bus based communication

1131
00:40:43,619 --> 00:40:44,949
pattern within the EDA

1132
00:40:45,340 --> 00:40:47,570
and. In this case

1133
00:40:47,708 --> 00:40:49,789
it's an event router which is a service to us

1134
00:40:49,789 --> 00:40:52,070
which take a responsibility of pushing

1135
00:40:52,070 --> 00:40:54,148
these events to the consumer rather than consumer

1136
00:40:54,148 --> 00:40:56,148
is consuming them or pulling them which we

1137
00:40:56,148 --> 00:40:56,688
saw in the

1138
00:40:56,949 --> 00:40:58,708
previous po based model.

1139
00:40:59,110 --> 00:41:01,228
The other way it could be done is using

1140
00:41:01,228 --> 00:41:03,228
the topic-based architecture as well where we

1141
00:41:03,228 --> 00:41:04,090
have a publisher.

1142
00:41:04,469 --> 00:41:06,550
Publisher is uh also publishing

1143
00:41:06,550 --> 00:41:08,820
the messages and we define the different

1144
00:41:08,820 --> 00:41:10,949
topic and there are consumers who can

1145
00:41:10,949 --> 00:41:13,349
subscribe to the related topic and

1146
00:41:13,349 --> 00:41:15,429
whenever the producer is pushing any message

1147
00:41:15,429 --> 00:41:17,519
to the topic all the subscriber

1148
00:41:17,519 --> 00:41:19,668
who are part who have subscribed to that topic

1149
00:41:19,668 --> 00:41:21,684
they all get. The messages or

1150
00:41:21,684 --> 00:41:24,114
the notification a typical publisher subscriber

1151
00:41:24,114 --> 00:41:26,465
pattern what we are talking about, right? And

1152
00:41:26,465 --> 00:41:27,704
AWS does support,

1153
00:41:27,965 --> 00:41:29,965
uh, this capability as well via

1154
00:41:29,965 --> 00:41:32,043
different native as well as the open source

1155
00:41:32,043 --> 00:41:33,824
manage services in case of

1156
00:41:34,083 --> 00:41:36,144
event bus space architecture we have a.

1157
00:41:37,050 --> 00:41:39,449
Event bridge and in case of topic-based architecture

1158
00:41:39,449 --> 00:41:40,829
we have a SNS

1159
00:41:41,128 --> 00:41:43,208
and also for the manage open source

1160
00:41:43,208 --> 00:41:44,769
we have Amazon and Q, right?

1161
00:41:47,139 --> 00:41:49,300
So how the overall end to end EDA

1162
00:41:49,300 --> 00:41:51,340
implementation look like, right? So

1163
00:41:51,340 --> 00:41:53,378
as I mentioned, we could have a different event

1164
00:41:53,378 --> 00:41:55,579
producers. Those could be your AWS services,

1165
00:41:55,699 --> 00:41:57,820
those could be your microservices. Those could

1166
00:41:57,820 --> 00:41:59,878
be your third party SAS application

1167
00:42:00,059 --> 00:42:02,059
emitting an event and let's say the event bridge

1168
00:42:02,059 --> 00:42:04,059
as a router is consuming those events,

1169
00:42:04,119 --> 00:42:06,260
applying the rules, doing the filtering, and

1170
00:42:06,260 --> 00:42:07,760
then configuring the target

1171
00:42:08,219 --> 00:42:09,519
to push this event to the

1172
00:42:09,780 --> 00:42:11,878
different consumers like running a

1173
00:42:12,019 --> 00:42:14,019
different workflows, for example, if device

1174
00:42:14,019 --> 00:42:16,159
registration is a multi. Step

1175
00:42:16,159 --> 00:42:18,378
process then that process need to get kick

1176
00:42:18,378 --> 00:42:19,760
in and that could be

1177
00:42:20,219 --> 00:42:21,989
done by you know invoking our

1178
00:42:22,739 --> 00:42:24,820
uh workflow business process workflow via step

1179
00:42:24,820 --> 00:42:26,938
function or maybe you know

1180
00:42:26,938 --> 00:42:29,340
notifying the admin if there are some device alert

1181
00:42:29,340 --> 00:42:30,280
using the SNS or maybe

1182
00:42:31,300 --> 00:42:33,639
pushing these events or the messages

1183
00:42:33,820 --> 00:42:36,688
to the other back end downstream microservices

1184
00:42:36,780 --> 00:42:39,050
if transactionallyport

1185
00:42:39,050 --> 00:42:41,099
transactionality is important and multiple services need

1186
00:42:41,099 --> 00:42:41,958
to act together

1187
00:42:42,300 --> 00:42:44,260
for the fulfillment of the business requirement.

1188
00:42:46,550 --> 00:42:50,280
Right? So

1189
00:42:50,280 --> 00:42:52,320
I think yeah this is the previous slide.

1190
00:42:52,719 --> 00:42:54,760
Now with this now we have

1191
00:42:54,760 --> 00:42:56,878
understood the end to end event driven

1192
00:42:56,878 --> 00:42:57,579
architecture

1193
00:42:58,030 --> 00:43:00,438
uh uh patterns and how the communication

1194
00:43:00,438 --> 00:43:02,719
happen. Yeah

1195
00:43:10,429 --> 00:43:12,708
Sure, now I'll quickly go into the

1196
00:43:12,708 --> 00:43:15,110
how we have adopted some of these patterns

1197
00:43:15,110 --> 00:43:17,228
for our PLS, uh, machine to

1198
00:43:17,228 --> 00:43:19,309
machine communication backend transformation.

1199
00:43:19,550 --> 00:43:21,628
So we define the Phyllis RG service as we

1200
00:43:21,628 --> 00:43:23,668
saw earlier, and then these services

1201
00:43:23,668 --> 00:43:25,750
are emitting the event like registration of the

1202
00:43:25,750 --> 00:43:26,369
devices.

1203
00:43:26,833 --> 00:43:29,144
File transfer uh for these devices

1204
00:43:29,144 --> 00:43:29,833
and these

1205
00:43:30,304 --> 00:43:32,425
events were captured in the

1206
00:43:32,425 --> 00:43:33,905
event was which we build using the

1207
00:43:35,224 --> 00:43:37,344
Amazon event bridge and we defined

1208
00:43:37,344 --> 00:43:39,364
the certain rules which were getting

1209
00:43:39,364 --> 00:43:41,603
applied to these different events

1210
00:43:41,603 --> 00:43:42,175
and then.

1211
00:43:43,349 --> 00:43:45,510
Based on those rules and validation, we

1212
00:43:45,510 --> 00:43:47,530
were executing the different flow. For example,

1213
00:43:47,750 --> 00:43:49,829
if it is a registration of the device, we were

1214
00:43:49,829 --> 00:43:51,909
executing the registration workflow using our step

1215
00:43:51,909 --> 00:43:53,949
function. If it is a file

1216
00:43:53,949 --> 00:43:55,989
transfer for which the file transfer

1217
00:43:55,989 --> 00:43:58,030
need the once the file is transferred, the

1218
00:43:58,030 --> 00:44:00,000
processing of the file has to happen in the back end.

1219
00:44:00,269 --> 00:44:02,429
For that it's a dedicated queue to which

1220
00:44:02,429 --> 00:44:04,708
we need to push these messages for our

1221
00:44:04,708 --> 00:44:06,750
file transfer service. So we are pushing these

1222
00:44:06,750 --> 00:44:08,949
messages and even to the dedicated queue for that

1223
00:44:08,949 --> 00:44:11,320
service or. It could be the alert,

1224
00:44:11,550 --> 00:44:13,878
right? We have to consume the alert and act accordingly.

1225
00:44:14,148 --> 00:44:16,168
So this is how we were able to manage

1226
00:44:16,389 --> 00:44:18,429
the communication using even even

1227
00:44:18,429 --> 00:44:20,500
architecture between the difficult

1228
00:44:20,500 --> 00:44:22,208
between the different medical care,

1229
00:44:22,500 --> 00:44:24,550
uh, RSD services as well as the

1230
00:44:24,550 --> 00:44:26,860
respecting business processes or their dedicated

1231
00:44:26,860 --> 00:44:27,708
cues, right?

1232
00:44:28,800 --> 00:44:30,750
The other was the choreography pattern.

1233
00:44:31,010 --> 00:44:32,869
The choreography pattern is very important,

1234
00:44:33,168 --> 00:44:35,360
which comes handy when you have a diff you're

1235
00:44:35,360 --> 00:44:37,438
dealing with a different domain services, and each

1236
00:44:37,438 --> 00:44:39,579
services need to communicate with each

1237
00:44:39,579 --> 00:44:40,148
other

1238
00:44:40,530 --> 00:44:42,929
across the domain boundaries. And in our RSG

1239
00:44:42,929 --> 00:44:45,128
use case, the remote services gateway use

1240
00:44:45,128 --> 00:44:47,188
case for the FLIS, we had exactly the similar

1241
00:44:47,188 --> 00:44:49,208
requirement where the different services

1242
00:44:49,208 --> 00:44:51,429
like registration, file transfer, and alert

1243
00:44:51,809 --> 00:44:52,449
need to.

1244
00:44:53,079 --> 00:44:55,159
Also had an interaction with the different

1245
00:44:55,159 --> 00:44:57,438
architectural uh components

1246
00:44:57,438 --> 00:44:58,789
like workflows,

1247
00:44:59,199 --> 00:45:01,219
the messaging cues, and we were doing

1248
00:45:01,219 --> 00:45:02,300
that via

1249
00:45:02,559 --> 00:45:04,208
interacting or communication,

1250
00:45:04,469 --> 00:45:06,519
communicating these services with

1251
00:45:06,519 --> 00:45:08,519
the different business processes using

1252
00:45:08,519 --> 00:45:09,539
the event, right?

1253
00:45:10,219 --> 00:45:11,570
And this choreography pattern

1254
00:45:11,829 --> 00:45:12,780
what we have built,

1255
00:45:13,110 --> 00:45:15,168
we have built using the Amazon event

1256
00:45:15,168 --> 00:45:17,269
page. So left hand side we have our services, right hand side

1257
00:45:17,269 --> 00:45:19,570
we have a step function, messaging cues, and

1258
00:45:19,570 --> 00:45:21,728
all those are getting integrated to each other

1259
00:45:21,728 --> 00:45:23,780
over the event using the survey bus.

1260
00:45:24,148 --> 00:45:26,429
The last but not the least is the orchestration

1261
00:45:26,429 --> 00:45:26,938
pattern.

1262
00:45:27,269 --> 00:45:29,389
Take an example of the device registration flow

1263
00:45:29,389 --> 00:45:31,909
again. The device registration is a multi-step

1264
00:45:31,909 --> 00:45:33,989
process. It first need to validate

1265
00:45:33,989 --> 00:45:34,688
the device.

1266
00:45:35,039 --> 00:45:37,159
If the validation is successful, it register the

1267
00:45:37,159 --> 00:45:39,280
device. If the registration is successful, it

1268
00:45:39,280 --> 00:45:41,579
notify either success or the failure

1269
00:45:41,840 --> 00:45:43,409
to the respective stakeholders.

1270
00:45:43,668 --> 00:45:46,300
Now, sometime in a given domain boundaries,

1271
00:45:46,398 --> 00:45:49,119
you need to orchestrate this multi-step

1272
00:45:49,119 --> 00:45:51,199
process, this task, and how this

1273
00:45:51,199 --> 00:45:51,739
can happen

1274
00:45:52,409 --> 00:45:54,179
in event of an architecture.

1275
00:45:55,360 --> 00:45:57,449
It could happen via applying

1276
00:45:57,449 --> 00:45:59,590
the orchestration patterns. So how this happened, let's

1277
00:45:59,590 --> 00:46:01,679
look into the registration device flow.

1278
00:46:02,188 --> 00:46:04,478
Once we get a registration registration

1279
00:46:04,478 --> 00:46:06,909
device event alert from the devices,

1280
00:46:07,159 --> 00:46:07,938
we first

1281
00:46:08,199 --> 00:46:09,119
start the workflow,

1282
00:46:09,429 --> 00:46:11,599
validate the devices, register the

1283
00:46:11,599 --> 00:46:12,119
devices,

1284
00:46:12,438 --> 00:46:14,500
and if the registration is successfully complete,

1285
00:46:15,199 --> 00:46:17,199
we publish the device registration is

1286
00:46:17,199 --> 00:46:18,478
successful as an event.

1287
00:46:19,019 --> 00:46:21,289
Or if it is failed, we notify

1288
00:46:21,289 --> 00:46:23,329
to the end users they're saying that or the

1289
00:46:23,329 --> 00:46:25,389
admins that OK the event has failed

1290
00:46:25,389 --> 00:46:27,280
the registration has failed and.

1291
00:46:28,119 --> 00:46:30,260
We end our workflow and this could be done

1292
00:46:30,590 --> 00:46:33,179
applying the step function so the choreography

1293
00:46:33,360 --> 00:46:35,739
and the orchestration both are important

1294
00:46:36,070 --> 00:46:38,449
choreography for applying the.

1295
00:46:39,090 --> 00:46:41,159
The multi-step process within the service

1296
00:46:41,159 --> 00:46:43,688
domain and choreography for applying

1297
00:46:43,688 --> 00:46:45,938
the communication across the domains, right?

1298
00:46:46,329 --> 00:46:48,648
So that was another pattern which we leveraged

1299
00:46:48,648 --> 00:46:50,429
for Phyllis RSGU's case.

1300
00:46:50,688 --> 00:46:51,869
Last but not least again,

1301
00:46:52,250 --> 00:46:54,250
the integration we so far

1302
00:46:54,250 --> 00:46:56,329
talked about a lot of integration between the different

1303
00:46:56,329 --> 00:46:57,550
components, but often

1304
00:46:57,969 --> 00:47:00,148
the. Applying the integration

1305
00:47:00,148 --> 00:47:02,228
can be hard for the developers. They

1306
00:47:02,228 --> 00:47:04,309
have to spend an undeficiated

1307
00:47:04,309 --> 00:47:06,590
effort to build this integration logic

1308
00:47:06,708 --> 00:47:08,849
and how we can solve that. So for take

1309
00:47:08,849 --> 00:47:11,519
example, there are a lot of events which has been emitted

1310
00:47:11,519 --> 00:47:13,668
right by our transactional system. Let's take example

1311
00:47:13,668 --> 00:47:14,610
of Dynamo DB,

1312
00:47:14,978 --> 00:47:17,148
and we want to apply certain filtering on those

1313
00:47:17,148 --> 00:47:19,188
events, not all events we want to respond or

1314
00:47:19,188 --> 00:47:21,309
act upon, act upon, right? And

1315
00:47:21,309 --> 00:47:23,340
then we want to also enrich these events,

1316
00:47:23,510 --> 00:47:25,728
right? And then we want to.

1317
00:47:26,458 --> 00:47:28,898
Route this event to the respective targets

1318
00:47:28,898 --> 00:47:30,969
and we execute the business, uh, sorry,

1319
00:47:31,070 --> 00:47:33,300
bus business processes accordingly so

1320
00:47:33,300 --> 00:47:35,579
all this thing can happen applying the

1321
00:47:35,579 --> 00:47:37,579
event bridge pipe which provide us a

1322
00:47:37,579 --> 00:47:39,590
capability to build a low code

1323
00:47:39,590 --> 00:47:41,780
no code integration pattern. So in this slide

1324
00:47:41,780 --> 00:47:43,978
what we see from left hand side where the Dynamo

1325
00:47:43,978 --> 00:47:46,300
DB stream is emitting the, the

1326
00:47:46,300 --> 00:47:47,579
messages which can be then.

1327
00:47:48,019 --> 00:47:50,510
Enrich, transform, and then distributed

1328
00:47:50,510 --> 00:47:52,760
to the different consumer via EventBridge

1329
00:47:52,760 --> 00:47:54,369
is seamlessly happening without writing

1330
00:47:55,219 --> 00:47:57,280
a single line of code. So this

1331
00:47:57,280 --> 00:47:57,840
also

1332
00:47:58,099 --> 00:48:00,418
accelerate your entire event driven architecture

1333
00:48:00,418 --> 00:48:02,820
implementation journey. Now with this, I

1334
00:48:02,820 --> 00:48:04,918
hand over to the Shirini so that we go through

1335
00:48:04,918 --> 00:48:07,010
the end to end architecture and the

1336
00:48:07,010 --> 00:48:09,059
solution for Phillips RSG Bridge use

1337
00:48:09,059 --> 00:48:10,320
case, what we were able to.

1338
00:48:11,458 --> 00:48:12,199
Built upon Sweni,

1339
00:48:13,260 --> 00:48:14,789
over to you. Thank you, Anand.

1340
00:48:15,188 --> 00:48:17,389
This felt like 10 years' worth

1341
00:48:17,389 --> 00:48:19,590
of knowledge in 30 minutes crash

1342
00:48:19,590 --> 00:48:20,128
course,

1343
00:48:20,869 --> 00:48:22,949
and it's also the joke for me because

1344
00:48:22,949 --> 00:48:25,110
we went through the same exercise

1345
00:48:25,110 --> 00:48:27,188
last year when we were actually trying to

1346
00:48:27,188 --> 00:48:28,168
solve for this.

1347
00:48:30,458 --> 00:48:32,659
One critical thing that I missed telling

1348
00:48:32,659 --> 00:48:34,739
earlier that Legacy M2M

1349
00:48:34,739 --> 00:48:37,219
system that I was talking about is

1350
00:48:37,219 --> 00:48:39,760
not Philip's own, it's a third party system,

1351
00:48:40,139 --> 00:48:42,579
and that was the fundamental challenge

1352
00:48:42,898 --> 00:48:44,898
or why somebody could say, oh, you

1353
00:48:44,898 --> 00:48:45,599
build the system,

1354
00:48:46,059 --> 00:48:48,260
why do you need to reverse engineer

1355
00:48:48,260 --> 00:48:50,418
to figure out how the system behaves or how

1356
00:48:50,418 --> 00:48:51,639
the system performs.

1357
00:48:53,239 --> 00:48:55,679
In order for so resetting

1358
00:48:55,679 --> 00:48:58,119
the context, right? So we have

1359
00:48:58,119 --> 00:48:59,918
on the left side the devices.

1360
00:49:00,929 --> 00:49:02,969
That have an agent that cannot be

1361
00:49:02,969 --> 00:49:03,478
updated.

1362
00:49:04,260 --> 00:49:06,300
And then on the right side we have the Legacy

1363
00:49:06,300 --> 00:49:08,449
M2M services, which is going end

1364
00:49:08,449 --> 00:49:09,159
of life.

1365
00:49:10,349 --> 00:49:11,829
We have to replace that

1366
00:49:12,320 --> 00:49:14,360
with a modern system, which we

1367
00:49:14,360 --> 00:49:16,958
have done, and many of our

1368
00:49:16,958 --> 00:49:18,958
existing systems were able to migrate

1369
00:49:18,958 --> 00:49:21,418
except for these 20,000 devices.

1370
00:49:23,750 --> 00:49:25,739
The main requirement was

1371
00:49:26,110 --> 00:49:27,849
we cannot touch the devices.

1372
00:49:28,570 --> 00:49:30,739
To connect to this modern systems. Now

1373
00:49:30,739 --> 00:49:31,539
how do we do?

1374
00:49:32,918 --> 00:49:35,269
That's where the bridge comes in and

1375
00:49:35,269 --> 00:49:37,739
Anand has been talking about RSGA bridge.

1376
00:49:38,039 --> 00:49:40,188
So let me walk you

1377
00:49:40,188 --> 00:49:41,099
through how.

1378
00:49:41,849 --> 00:49:44,050
The overall architecture has come through.

1379
00:49:45,260 --> 00:49:48,119
So the first thing that we had to do was

1380
00:49:48,659 --> 00:49:50,820
we had to run a workshop and there are 3

1381
00:49:50,820 --> 00:49:52,570
things that Anan talked about

1382
00:49:53,199 --> 00:49:54,199
understand your domain,

1383
00:49:54,860 --> 00:49:56,639
understand how your events are,

1384
00:49:57,260 --> 00:49:59,340
what patterns you can apply, and

1385
00:49:59,340 --> 00:50:01,458
how all of those things are going to come

1386
00:50:01,458 --> 00:50:03,550
together. So this,

1387
00:50:04,010 --> 00:50:06,208
um, right now, the, the

1388
00:50:06,208 --> 00:50:08,250
existing architecture, the flow that I'll talk

1389
00:50:08,250 --> 00:50:10,329
through is existing architecture. So we

1390
00:50:10,329 --> 00:50:12,679
have these medical devices connecting

1391
00:50:12,679 --> 00:50:13,668
into the

1392
00:50:14,090 --> 00:50:15,489
ERs private link.

1393
00:50:16,179 --> 00:50:18,320
Um, because we don't want any of our

1394
00:50:18,320 --> 00:50:20,539
healthcare data flowing out of

1395
00:50:20,539 --> 00:50:22,780
internet. It goes through a network load

1396
00:50:22,780 --> 00:50:25,239
balancer to an application load balancer

1397
00:50:25,239 --> 00:50:27,619
and into the legacy M2M backend.

1398
00:50:28,610 --> 00:50:30,668
This flow is important, and we had

1399
00:50:30,668 --> 00:50:31,909
to start here

1400
00:50:32,489 --> 00:50:34,769
because we want to understand how

1401
00:50:34,769 --> 00:50:36,610
these request responses were.

1402
00:50:37,449 --> 00:50:39,938
And this is where the domain driven design design

1403
00:50:39,938 --> 00:50:41,958
actually came into a

1404
00:50:42,139 --> 00:50:43,559
big help for us,

1405
00:50:43,938 --> 00:50:46,208
and we identified 5 core

1406
00:50:46,208 --> 00:50:48,579
domains. Um, there were more, but

1407
00:50:48,579 --> 00:50:50,809
for the purpose of this, uh,

1408
00:50:50,820 --> 00:50:51,378
talk,

1409
00:50:51,739 --> 00:50:53,949
we'll keep it very simple what Anand

1410
00:50:53,949 --> 00:50:55,050
was talking about

1411
00:50:55,378 --> 00:50:57,579
how the devices register into the

1412
00:50:57,579 --> 00:50:58,679
back end system,

1413
00:50:59,378 --> 00:51:02,159
how the devices upload the files.

1414
00:51:03,050 --> 00:51:05,398
What are the alerts that get generated,

1415
00:51:05,530 --> 00:51:07,610
either from the device or in the back

1416
00:51:07,610 --> 00:51:10,090
end? What is the heartbeat

1417
00:51:10,090 --> 00:51:12,128
that comes along to the back end

1418
00:51:12,128 --> 00:51:13,409
saying that Am I up?

1419
00:51:14,269 --> 00:51:15,159
And lastly,

1420
00:51:15,559 --> 00:51:17,679
to make the property updates

1421
00:51:17,679 --> 00:51:19,760
onto these devices, how can we push

1422
00:51:19,760 --> 00:51:22,269
those properties? So these are the core 5

1423
00:51:22,269 --> 00:51:24,139
core domains that we have identified.

1424
00:51:25,489 --> 00:51:27,489
And while identifying, I think there

1425
00:51:27,489 --> 00:51:29,829
are a couple of patterns that evolved,

1426
00:51:29,969 --> 00:51:32,079
and one of the pattern was for us

1427
00:51:32,079 --> 00:51:32,769
to say,

1428
00:51:33,090 --> 00:51:35,449
OK, within the bounded context

1429
00:51:35,449 --> 00:51:37,489
of this particular type of

1430
00:51:37,489 --> 00:51:38,070
events,

1431
00:51:38,648 --> 00:51:40,309
what should be the workload be

1432
00:51:40,610 --> 00:51:43,030
in some, because in case of registration,

1433
00:51:43,728 --> 00:51:46,079
it was no brainer. It happens only once.

1434
00:51:46,208 --> 00:51:48,688
It doesn't happen every day. You register once

1435
00:51:48,688 --> 00:51:49,769
and you're done with it.

1436
00:51:50,320 --> 00:51:52,349
So our choice was to

1437
00:51:52,349 --> 00:51:54,559
use a lambda service to

1438
00:51:54,559 --> 00:51:56,079
properly process those events.

1439
00:51:57,469 --> 00:51:59,469
Whereas when you try to upload

1440
00:51:59,469 --> 00:52:01,510
the files, these log files

1441
00:52:01,510 --> 00:52:02,289
are happening

1442
00:52:02,750 --> 00:52:04,789
every day. In some cases these devices

1443
00:52:04,789 --> 00:52:05,769
are large

1444
00:52:06,188 --> 00:52:08,188
because sometimes devices don't connect for

1445
00:52:08,188 --> 00:52:10,269
a couple of days and suddenly we see

1446
00:52:10,269 --> 00:52:12,349
burst of like 100 MB worth of

1447
00:52:12,349 --> 00:52:14,530
files and you can't process them

1448
00:52:14,530 --> 00:52:16,128
with the serverless.

1449
00:52:16,510 --> 00:52:18,628
So that's where we had to use

1450
00:52:18,628 --> 00:52:20,898
Amazon ECS Fargate

1451
00:52:21,389 --> 00:52:23,250
uh to process these long running

1452
00:52:23,550 --> 00:52:24,639
uh processes.

1453
00:52:25,679 --> 00:52:27,688
Wherein the files used to get stored

1454
00:52:27,688 --> 00:52:29,849
in uh Amazon Simple Storage

1455
00:52:29,849 --> 00:52:32,039
Service. Now once

1456
00:52:32,039 --> 00:52:34,458
we have a good understanding of

1457
00:52:34,458 --> 00:52:36,019
how the workloads are,

1458
00:52:36,579 --> 00:52:38,699
now the second pattern was, OK, we have

1459
00:52:38,699 --> 00:52:40,750
all these events. Now what do we do with these

1460
00:52:40,750 --> 00:52:41,269
events?

1461
00:52:41,820 --> 00:52:43,849
In some case, we had to

1462
00:52:43,849 --> 00:52:45,898
actually store them in, in

1463
00:52:45,898 --> 00:52:47,019
the Dynamo DB.

1464
00:52:48,079 --> 00:52:51,019
Um, we had actually Dynamo DB streams

1465
00:52:51,019 --> 00:52:53,340
enabled with the Kinesis adapter

1466
00:52:53,719 --> 00:52:55,840
so that we know where

1467
00:52:55,840 --> 00:52:57,978
this event has to be routed to

1468
00:52:58,438 --> 00:53:00,519
now, as Anand was also saying that

1469
00:53:00,519 --> 00:53:02,550
for us time was a constraint.

1470
00:53:02,878 --> 00:53:04,958
We had to put it in a

1471
00:53:04,958 --> 00:53:06,989
place in such a way that during the

1472
00:53:06,989 --> 00:53:09,199
migration period of a particular

1473
00:53:09,199 --> 00:53:09,719
device,

1474
00:53:10,159 --> 00:53:12,199
if something goes wrong we have to be able

1475
00:53:12,199 --> 00:53:13,208
to replay it.

1476
00:53:13,840 --> 00:53:16,119
So we had used the Amazon

1477
00:53:16,119 --> 00:53:17,320
event bridge pipe.

1478
00:53:17,909 --> 00:53:20,119
To filter these events, to be able

1479
00:53:20,119 --> 00:53:22,280
to know which route or which

1480
00:53:22,280 --> 00:53:24,539
service or which queue to go into,

1481
00:53:25,000 --> 00:53:25,519
and,

1482
00:53:26,849 --> 00:53:27,429
Um,

1483
00:53:27,820 --> 00:53:30,500
essentially the even bus is the one that is actually

1484
00:53:30,500 --> 00:53:31,728
processing this, so

1485
00:53:32,059 --> 00:53:34,219
the low code, no code kind

1486
00:53:34,219 --> 00:53:35,159
of capability,

1487
00:53:35,699 --> 00:53:37,860
uh, provided us the capability to

1488
00:53:37,860 --> 00:53:39,978
create these filters on the flight

1489
00:53:39,978 --> 00:53:40,728
when needed.

1490
00:53:41,099 --> 00:53:43,099
So some of the key takeaways

1491
00:53:43,099 --> 00:53:45,179
I would say is we have figured out what the

1492
00:53:45,179 --> 00:53:47,418
events are, what, where the events get

1493
00:53:47,418 --> 00:53:48,000
stored,

1494
00:53:48,309 --> 00:53:50,599
and how they would get routed

1495
00:53:51,219 --> 00:53:52,000
now the.

1496
00:53:52,418 --> 00:53:54,550
The fun part was, as I was

1497
00:53:54,550 --> 00:53:56,329
saying, this is all about

1498
00:53:56,750 --> 00:53:57,889
making the system

1499
00:53:58,628 --> 00:54:00,889
working during the migration time period.

1500
00:54:01,739 --> 00:54:03,820
So this is where we had to choose what

1501
00:54:03,820 --> 00:54:05,478
else can we actually

1502
00:54:06,239 --> 00:54:08,469
take from the tool set of the patterns

1503
00:54:08,469 --> 00:54:10,780
that are available to us from the event-driven.

1504
00:54:11,500 --> 00:54:13,659
So these events as they were

1505
00:54:13,659 --> 00:54:15,878
being processed in the event bridge,

1506
00:54:16,539 --> 00:54:18,539
we had defined the respective

1507
00:54:18,539 --> 00:54:20,699
cues in which where the events

1508
00:54:20,699 --> 00:54:21,559
can go in

1509
00:54:21,829 --> 00:54:23,978
and if, as I was saying, if at all we

1510
00:54:23,978 --> 00:54:26,340
had to replay, we could know what

1511
00:54:27,059 --> 00:54:29,139
what the, how the systems were behaving

1512
00:54:29,139 --> 00:54:31,139
this gave us like a good

1513
00:54:31,139 --> 00:54:32,079
view into

1514
00:54:32,539 --> 00:54:34,579
um how the events came into the

1515
00:54:34,579 --> 00:54:37,070
system, how they were being processed,

1516
00:54:37,579 --> 00:54:38,260
and

1517
00:54:38,539 --> 00:54:40,360
one of the complexity was.

1518
00:54:41,188 --> 00:54:43,389
We had to deal with

1519
00:54:43,389 --> 00:54:44,438
complex workflows.

1520
00:54:45,409 --> 00:54:47,530
In simple cases where

1521
00:54:47,530 --> 00:54:49,829
there is just a simple request response,

1522
00:54:49,969 --> 00:54:52,059
it was a very straightforward process

1523
00:54:52,469 --> 00:54:54,648
and given the time constraint that we were

1524
00:54:54,648 --> 00:54:56,699
dealing with step functions gave

1525
00:54:56,699 --> 00:54:58,929
us the best possible

1526
00:54:58,929 --> 00:55:00,128
implementation

1527
00:55:00,570 --> 00:55:02,789
where we could really see

1528
00:55:02,789 --> 00:55:04,969
and figure out how

1529
00:55:04,969 --> 00:55:07,349
each of the steps were being performed

1530
00:55:07,619 --> 00:55:08,208
and.

1531
00:55:08,809 --> 00:55:09,728
If need be,

1532
00:55:09,989 --> 00:55:12,019
if we have to go back and change

1533
00:55:12,019 --> 00:55:14,059
something, it was pretty easy for

1534
00:55:14,059 --> 00:55:15,829
us to go back and change,

1535
00:55:16,139 --> 00:55:18,280
and, and trust me, we did the migration,

1536
00:55:18,719 --> 00:55:21,139
um, over a period of 3 weeks

1537
00:55:21,139 --> 00:55:22,559
in the month of December,

1538
00:55:23,059 --> 00:55:25,519
and we were almost deploying

1539
00:55:25,610 --> 00:55:27,639
every day into the production

1540
00:55:28,099 --> 00:55:30,099
some other services, so the

1541
00:55:30,099 --> 00:55:32,139
microservices allowed us to

1542
00:55:32,139 --> 00:55:33,228
be able to,

1543
00:55:33,579 --> 00:55:35,398
uh, deploy the changes that we want.

1544
00:55:35,969 --> 00:55:38,458
Um, the, um, even,

1545
00:55:38,579 --> 00:55:40,610
uh, the even bridge, uh,

1546
00:55:40,619 --> 00:55:42,619
filtering allowed us to say, hey,

1547
00:55:42,699 --> 00:55:44,708
should we turn off this filter? Should we tweak

1548
00:55:44,708 --> 00:55:45,398
something,

1549
00:55:45,860 --> 00:55:46,550
and then

1550
00:55:46,820 --> 00:55:49,179
these services eventually talk to

1551
00:55:49,179 --> 00:55:49,719
the

1552
00:55:50,340 --> 00:55:52,378
more modern IOT system that we

1553
00:55:52,378 --> 00:55:53,019
are building.

1554
00:55:54,860 --> 00:55:56,699
So the outcomes were good.

1555
00:55:57,059 --> 00:55:58,599
That's why I'm on this stage.

1556
00:55:59,519 --> 00:56:01,530
Um, we were successfully able to

1557
00:56:01,530 --> 00:56:03,949
bridge those 20,000 devices

1558
00:56:04,168 --> 00:56:06,750
from the legacy system to the new IOT system,

1559
00:56:07,168 --> 00:56:08,739
all on the AWSRLS.

1560
00:56:09,889 --> 00:56:11,949
We also were able to do it

1561
00:56:12,668 --> 00:56:14,688
without the cost of that 20

1562
00:56:14,688 --> 00:56:16,708
million that we talked about earlier.

1563
00:56:17,878 --> 00:56:19,398
Avoiding the field trips.

1564
00:56:20,619 --> 00:56:21,800
And then of course

1565
00:56:22,059 --> 00:56:22,679
there was

1566
00:56:22,938 --> 00:56:24,119
no interruption

1567
00:56:24,559 --> 00:56:26,699
so we achieved zero touch

1568
00:56:27,019 --> 00:56:27,800
0 down,

1569
00:56:28,340 --> 00:56:29,628
fully compliant,

1570
00:56:29,938 --> 00:56:30,840
and

1571
00:56:31,219 --> 00:56:32,438
I felt like

1572
00:56:32,849 --> 00:56:35,139
whatever that we were doing was not short

1573
00:56:35,139 --> 00:56:37,289
term. It was not a bridge for a short term,

1574
00:56:37,340 --> 00:56:39,760
but it's a bridge for us to go into the future.

1575
00:56:40,800 --> 00:56:42,898
So in summary, I would say,

1576
00:56:42,918 --> 00:56:43,579
I think.

1577
00:56:44,478 --> 00:56:45,438
If you ask me,

1578
00:56:45,760 --> 00:56:47,878
Anand was exactly right. We have

1579
00:56:47,878 --> 00:56:49,978
to start with domain, and it's not

1580
00:56:49,978 --> 00:56:52,059
technology, and it is in this case,

1581
00:56:52,599 --> 00:56:55,079
our teams were very well versed

1582
00:56:55,079 --> 00:56:57,199
understanding what serviceability workflows looked

1583
00:56:57,199 --> 00:56:59,239
like, but still we had

1584
00:56:59,239 --> 00:57:01,360
to understand a system that we were

1585
00:57:01,360 --> 00:57:02,659
not aware of. So

1586
00:57:03,039 --> 00:57:05,039
even storming domain driven

1587
00:57:05,039 --> 00:57:07,340
design gave us the right severalless boundaries.

1588
00:57:08,938 --> 00:57:10,889
And I was also talking about how

1589
00:57:11,228 --> 00:57:14,128
loose coupling beats tight efficiency.

1590
00:57:14,590 --> 00:57:16,869
The architecture, which is

1591
00:57:16,869 --> 00:57:18,949
the human driven architecture, which is a mental model

1592
00:57:18,949 --> 00:57:21,269
for us, was to be able to adapt

1593
00:57:21,269 --> 00:57:24,079
to the API-driven microservices,

1594
00:57:24,418 --> 00:57:25,030
and

1595
00:57:25,469 --> 00:57:27,510
I would also say that we had to mix a little

1596
00:57:27,510 --> 00:57:29,590
bit of choreography and some type of

1597
00:57:29,590 --> 00:57:30,489
services.

1598
00:57:31,148 --> 00:57:33,228
And use orchestration within the

1599
00:57:33,228 --> 00:57:35,429
services so that we're able to

1600
00:57:35,429 --> 00:57:37,829
process them properly in a multi-step, uh,

1601
00:57:37,949 --> 00:57:39,208
multi-step, uh,

1602
00:57:39,708 --> 00:57:41,128
um, changes.

1603
00:57:42,458 --> 00:57:43,659
And then lastly

1604
00:57:44,000 --> 00:57:45,978
we think in platform

1605
00:57:46,239 --> 00:57:48,438
and we cannot think in just point

1606
00:57:48,438 --> 00:57:49,418
solutions because

1607
00:57:50,349 --> 00:57:52,378
once we have this platform

1608
00:57:52,378 --> 00:57:54,800
that is up and running it scales

1609
00:57:54,800 --> 00:57:57,378
and it scales across multiple devices,

1610
00:57:57,398 --> 00:57:58,510
multiple years

1611
00:57:58,840 --> 00:58:01,260
so this is what I would like to end with

1612
00:58:01,360 --> 00:58:01,918
the talk.

1613
00:58:02,239 --> 00:58:04,519
I hope we have given a good insight into

1614
00:58:04,519 --> 00:58:05,079
how.

1615
00:58:06,099 --> 00:58:08,099
What the Phillips journey was over

1616
00:58:08,099 --> 00:58:09,679
those last six months

1617
00:58:10,179 --> 00:58:13,398
before we get to that December 31st, 2024

1618
00:58:13,699 --> 00:58:14,340
and.

1619
00:58:15,148 --> 00:58:17,750
Uh, hopefully you know and resonate

1620
00:58:17,750 --> 00:58:19,829
this, um, uh, the

1621
00:58:19,829 --> 00:58:21,909
process that we went through. Hopefully you can apply

1622
00:58:21,909 --> 00:58:23,989
it on in your own journeys

1623
00:58:23,989 --> 00:58:26,070
where you have legacy systems that you deal

1624
00:58:26,070 --> 00:58:26,610
with.

1625
00:58:27,148 --> 00:58:27,688
Thank you.

1626
00:58:28,369 --> 00:58:29,820
Thanks, really, and, uh.

1627
00:58:31,119 --> 00:58:33,708
Thank you. And

1628
00:58:33,719 --> 00:58:35,958
you folks can also, you know, learn more

1629
00:58:35,958 --> 00:58:37,208
about the different,

1630
00:58:37,639 --> 00:58:39,978
even different architecture pattern from our

1631
00:58:40,119 --> 00:58:40,750
server slang.

1632
00:58:41,269 --> 00:58:43,438
So right, and you can scan the QR

1633
00:58:43,438 --> 00:58:45,438
code. It will lend you to the website and then

1634
00:58:45,599 --> 00:58:47,708
you will find much more pattern than what

1635
00:58:47,708 --> 00:58:50,360
we talked about and also the different type of implementation

1636
00:58:50,360 --> 00:58:52,360
of the some of the pattern which

1637
00:58:52,360 --> 00:58:54,478
we also covered as part of our talk

1638
00:58:54,478 --> 00:58:56,519
today. So with that, yeah, as I mentioned,

1639
00:58:56,599 --> 00:58:58,458
thank you. Thank you

