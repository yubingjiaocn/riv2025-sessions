# AWS re:Invent 2025 - 释放 Rust 在 AWS 上的潜力

## 会议概述

本次会议由 AWS 首席开发者倡导者 Darko 和 Datadog 资深工程师 AJ Stuyvenberg 共同主讲，深入探讨了 Rust 编程语言在 AWS 云平台上的应用实践。会议展示了 Rust 如何成为构建高性能、高可靠性云服务的关键技术选择。

Darko 首先介绍了 AWS 内部如何大规模使用 Rust，特别是新发布的 Amazon Aurora DSQL 数据库——一个完全用 Rust 编写的无服务器分布式 SQL 数据库。该项目最初使用 Kotlin/JVM 实现，但由于垃圾回收导致的延迟问题（从预期的1秒增加到10秒），团队决定尝试 Rust。结果令人震惊：即使没有进行任何优化，Rust 实现的性能也比 Kotlin 版本快了10倍。这一成功案例促使团队最终将整个项目（包括控制平面和数据平面）都迁移到了 Rust。

AJ 则分享了 Datadog 在三个主要领域使用 Rust 的经验：无服务器扩展、监控代理和后端分布式系统。在 Lambda 扩展方面，Datadog 将原有的 Go 实现替换为 Rust 后，冷启动时间从 700-800 毫秒降低到仅 80 毫秒，运行时开销从 60-140 毫秒降至 500 微秒。在后端时序数据库系统中，Rust 实现能够处理每秒 350 万个数据点，是 Go 版本的 60 倍。两位讲者强调，编写符合 Rust 惯用法的代码就能获得接近精心优化的 Go 代码的性能，这使得 Rust 成为追求高性能和成本效益的理想选择。

## 详细时间线

### 开场与介绍 (0:00 - 2:30)
- **0:00** - 会议开场，幽默地称这是"Rust ASMR"，模拟编译器的声音
- **0:30** - Darko 介绍会议主题："释放 Rust 在 AWS 上的潜力"
- **1:00** - 介绍演讲嘉宾：AJ Stuyvenberg，Datadog 资深工程师
- **1:30** - 会议议程预览：Rust 在 AWS 的规模化应用、Rust 的广泛适用性、Datadog 的 Rust 实践
- **2:00** - 现场调查：询问有多少人正在使用 Rust

### AWS 规模化使用 Rust (2:30 - 8:00)
- **2:30** - 介绍 Amazon Aurora DSQL：100% 用 Rust 编写的无服务器分布式 SQL 数据库
- **3:00** - 项目背景：最初使用 Kotlin/JVM 实现，性能约为每秒 2000-3000 次事务
- **3:30** - 遇到的问题：垃圾回收导致严重的尾部延迟，从预期的 1 秒增加到 10 秒
- **4:00** - 团队决定测试 Rust，首先在 Adjudicator 组件上实现
- **4:30** - 结果：Rust 实现比 Kotlin 快 10 倍
- **5:00** - 决策：将整个数据平面重写为 Rust
- **5:30** - 最终：连控制平面也迁移到 Rust，实现 100% Rust 代码库
- **6:00** - 性能提升：在零优化的情况下，速度提升 10 倍
- **6:30** - 推荐阅读：Werner Vogels 的 All Things Distributed 博客
- **7:00** - AWS 其他 Rust 项目：Bottlerocket 操作系统、Firecracker 微虚拟机
- **7:30** - 重要声明：AWS 所有新的数据平面项目默认使用 Rust

### Rust 的广泛适用性 (8:00 - 18:00)
- **8:00** - Rust 不仅适用于大型后端系统，也适用于各种场景
- **8:30** - 介绍 Cargo Lambda：社区工具，用于部署和管理 Rust Lambda 函数
- **9:00** - Rust Lambda 支持正式发布（GA）
- **9:30** - Cargo Lambda 命令演示：创建、启动、调用、构建和部署
- **10:00** - 基础设施即代码支持：CDK 和 SAM 集成
- **10:30** - 展示 CDK 中的 RustFunction 构造
- **11:00** - Rust + Lambda + HTMX：前端应用案例
- **11:30** - 现场演示：用 Rust 构建的链接缩短器
- **12:00** - 演示应用功能：实时创建短链接
- **12:30** - 技术栈说明：静态网站 + 数据库 + Lambda 函数，几乎无 JavaScript
- **13:00** - 代码展示：Lambda 函数入口点
- **13:30** - 类型安全的事件处理
- **14:00** - Kinesis 事件处理示例
- **14:30** - 处理 CloudFront 实时日志（TSV 格式）
- **15:00** - Lambda 性能数据：冷启动 1.2 秒，热启动 4 毫秒
- **15:30** - 内存使用：仅 29 MB
- **16:00** - 性能对比：仅次于 C++，ARM 架构上 Rust 比 x86 更快
- **16:30** - 观点：在 LLM 时代应该停止使用 Python
- **17:00** - 理由：编译型、类型安全的语言能更快发现错误
- **17:30** - 过渡到 Datadog 的 Rust 实践

### Datadog 的无服务器 Rust 应用 (18:00 - 28:00)
- **18:00** - AJ 开始演讲，介绍 Datadog 使用 Rust 的三个主要领域
- **18:30** - Lambda 扩展 API 背景介绍
- **19:00** - 扩展的工作原理：允许异步处理
- **19:30** - 扩展开发的三个关键点：作为父进程的风险
- **20:00** - 每个 Lambda 沙箱一次处理一个串行请求
- **20:30** - 原有 Go 实现的问题：冷启动时间 700-800 毫秒
- **21:00** - 性能图表展示：初始化时间过长
- **21:30** - 决定从 Go 迁移到 Rust 的原因
- **22:00** - 6 个月开发周期，团队之前没有 Rust 经验
- **22:30** - 新的 Rust 实现（代号 Bottlecap）
- **23:00** - 性能提升：冷启动降至约 80 毫秒
- **23:30** - 部署策略：Go 和 Rust 并行运行
- **24:00** - 自动检测配置并在需要时回退到 Go
- **24:30** - 逐步淘汰 Go 代码
- **25:00** - 运行时优化：后运行时持续时间大幅降低
- **25:30** - TCP keep-alive 优化策略
- **26:00** - "欺骗死亡"技术：在热函数中保持 TCP 流
- **26:30** - 性能结果：从 60-140 毫秒降至约 500 微秒
- **27:00** - 代码清理：删除了 53,000 行 Go 代码
- **27:30** - PR 需要 18 个审批

### Datadog Agent 的 Rust 重写 (28:00 - 35:00)
- **28:00** - 转向长期运行进程的讨论
- **28:30** - Datadog Agent 架构概述
- **29:00** - 重写核心指标数据平面为 Rust
- **29:30** - 控制平面保持 Go 实现
- **30:00** - 实验性项目：Rust 数据平面
- **30:30** - 性能提升：每个 Pod CPU 使用降低 25%
- **31:00** - 内存使用降低 33%
- **31:30** - 50-50 并行测试策略
- **32:00** - 指标系统的特点：时间序列数据
- **32:30** - 分配工厂问题：大量小对象分配
- **33:00** - Go 的内存管理挑战
- **33:30** - Rust 在处理分配密集型工作负载的优势
- **34:00** - Go 垃圾回收占用约 30% 的时间
- **34:30** - 过渡到后端分布式系统讨论

### Datadog 后端时序数据库 (35:00 - 45:00)
- **35:00** - Datadog 后端规模：每天处理数万亿数据点
- **35:30** - 介绍 Monle：基于 LSM 树架构的存储引擎
- **36:00** - LSM 树工作原理：内存表 + 磁盘分层
- **36:30** - 数据流：内存缓存 → 本地磁盘 → S3
- **37:00** - 后台压缩过程
- **37:30** - 生产环境架构：大规模节点集群
- **38:00** - 每核心一个线程的架构
- **38:30** - 每个核心运行独立的存储引擎实例
- **39:00** - 部署挑战：安全性和正确性验证
- **39:30** - LSM 树系统的特殊性：同时服务读写
- **40:00** - 实时查询需求：监控告警场景
- **40:30** - 性能测试结果展示
- **41:00** - 负载峰值：从 5,000 到 40,000-50,000 点/秒
- **41:30** - Go 版本在 60,000 点/秒时开始丢弃查询
- **42:00** - Rust 版本处理能力：每个 Pod 350 万点/秒
- **42:30** - 性能提升：60 倍于 Go 实现
- **43:00** - 代码对比：标签分组功能
- **43:30** - Rust 实现：简洁的惯用代码
- **44:00** - Go 实现：看似相似但存在分配问题
- **44:30** - 性能对比：Rust 快近 3 倍（C7i.xlarge 实例）

### Go vs Rust 讨论 (45:00 - 48:00)
- **45:00** - Darko 提问：Go 开发者如何适应 Rust
- **45:30** - AJ 回应：Go 可以使用堆外数据结构
- **46:00** - Datadog 曾使用 RocksDB 的堆外内存管理
- **46:30** - 迁移到 Rust 后性能提升不大，但可维护性大幅提高
- **47:00** - Go 堆外代码变得难以维护，无人愿意触碰
- **47:30** - 关键结论：惯用的 Rust 代码性能等同于精心优化的 Go 代码
- **48:00** - 对利益相关者的建议：如果性能和成本很重要，选择 Rust

### 生产环境最佳实践 (48:00 - 结束)
- **48:00** - Darko 回到舞台，准备分享生产环境技巧
- **48:30** - 强调 Rust 开箱即用的高性能特性
- **49:00** - 会议总结和要点回顾
- **49:30** - 问答环节准备

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━


注： 本摘要基于提供的字幕文本生成，涵盖了会议的主要技术内容和关键时间点。