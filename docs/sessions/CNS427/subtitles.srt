1
00:00:00,089 --> 00:00:02,220
Hello everyone, good afternoon. Uh,

2
00:00:02,369 --> 00:00:04,679
welcome to CNS 427, uh,

3
00:00:04,769 --> 00:00:07,009
supercharging the testing with

4
00:00:07,009 --> 00:00:09,028
Quiro. My name is Aarti.

5
00:00:09,169 --> 00:00:11,210
I am based in Singapore and I work with

6
00:00:11,210 --> 00:00:13,319
customers in Southeast Asia. I've got

7
00:00:13,319 --> 00:00:13,868
Thomas.

8
00:00:14,390 --> 00:00:15,500
Hi, I'm Thomas. I'm based,

9
00:00:16,048 --> 00:00:18,408
based in Sydney. I look after startups

10
00:00:18,408 --> 00:00:20,679
across OIPJ focusing on agentic coding.

11
00:00:21,750 --> 00:00:23,789
Alright, I hope you've all had a good Reinvent

12
00:00:23,789 --> 00:00:25,908
so far, um, almost the end of

13
00:00:25,908 --> 00:00:26,469
Reinvent.

14
00:00:27,039 --> 00:00:29,149
So in today's talk, we are gonna talk about

15
00:00:29,149 --> 00:00:31,149
how you can use Agentech AI

16
00:00:31,149 --> 00:00:33,348
across your surless development life cycle,

17
00:00:33,649 --> 00:00:35,450
specifically to simplify testing.

18
00:00:36,189 --> 00:00:38,228
Now testing is a vast topic. Uh,

19
00:00:38,310 --> 00:00:40,509
so today we will focus on automated

20
00:00:40,509 --> 00:00:42,668
functional tests for Servalli, which is unit

21
00:00:42,668 --> 00:00:44,700
tests, integration tests, and end to

22
00:00:44,700 --> 00:00:45,380
end tests.

23
00:00:45,990 --> 00:00:48,270
So this is a Level 400 talk, so we assume

24
00:00:48,270 --> 00:00:50,509
the audience is familiar with Servallis and also

25
00:00:50,509 --> 00:00:52,329
some of the basics of coding.

26
00:00:53,889 --> 00:00:56,090
So to first understand the challenges with Serveli,

27
00:00:56,250 --> 00:00:58,450
let's start with what's a bit different about

28
00:00:58,450 --> 00:01:00,079
Serveless applications.

29
00:01:00,609 --> 00:01:03,090
Um, Serveless applications are highly distributed

30
00:01:03,090 --> 00:01:05,370
or modular, uh, which means they have

31
00:01:05,370 --> 00:01:07,668
a larger number of integrations as opposed

32
00:01:07,668 --> 00:01:08,760
to traditional apps,

33
00:01:09,040 --> 00:01:11,409
and they also make use of a lot of cloud native

34
00:01:11,409 --> 00:01:12,308
services.

35
00:01:12,849 --> 00:01:15,049
Now this has implications for the testing

36
00:01:15,049 --> 00:01:17,129
process where it becomes important to test the

37
00:01:17,129 --> 00:01:18,668
integration layers as well.

38
00:01:19,150 --> 00:01:21,400
And one of the questions that comes up very often

39
00:01:21,400 --> 00:01:23,760
for automated tests is handling dependencies

40
00:01:23,760 --> 00:01:25,959
for isolated tests, that is, should you

41
00:01:25,959 --> 00:01:28,159
mock them or should you emulate them, or

42
00:01:28,159 --> 00:01:30,058
just use AWS services.

43
00:01:30,549 --> 00:01:31,370
And finally,

44
00:01:31,680 --> 00:01:33,900
your Lambda functions themselves may not be

45
00:01:33,900 --> 00:01:35,980
complex enough, so how do you think about things

46
00:01:35,980 --> 00:01:38,239
like coverage or where should you actually

47
00:01:38,239 --> 00:01:39,959
focus your testing efforts?

48
00:01:40,290 --> 00:01:42,359
So today we are going to see how Quiro can

49
00:01:42,359 --> 00:01:44,120
help us with each of this pillar,

50
00:01:44,558 --> 00:01:46,879
starting with how you should write your

51
00:01:46,879 --> 00:01:48,760
applications to make it easy to test,

52
00:01:49,159 --> 00:01:51,359
how you can use Agentic AI to generate the

53
00:01:51,359 --> 00:01:53,680
tests, and finally how you can combine

54
00:01:53,680 --> 00:01:55,799
the power of NCP servers with agents

55
00:01:55,799 --> 00:01:57,879
to kind of use historic data to

56
00:01:57,879 --> 00:02:00,040
continuously improve the quality of your

57
00:02:00,040 --> 00:02:02,370
applications. So

58
00:02:02,370 --> 00:02:02,909
because our

59
00:02:03,168 --> 00:02:05,528
focus is testing in today's talk, we've actually

60
00:02:05,528 --> 00:02:07,569
pre-built the application which is just a

61
00:02:07,569 --> 00:02:09,808
task management API that uses

62
00:02:09,808 --> 00:02:11,808
Amazon API gateway as a REST API,

63
00:02:12,300 --> 00:02:14,409
Lambda for processing, and Dynamo DB for

64
00:02:14,409 --> 00:02:15,588
the persistence layer.

65
00:02:15,969 --> 00:02:18,050
There is also an asynchronous component where

66
00:02:18,050 --> 00:02:20,490
any task events are published out to Amazon

67
00:02:20,490 --> 00:02:22,558
Event Bridge, and then they are consumed by

68
00:02:22,558 --> 00:02:24,110
a notification service.

69
00:02:24,758 --> 00:02:26,800
So throughout the next hour or so, we are

70
00:02:26,800 --> 00:02:29,199
going to evolve both the application and

71
00:02:29,199 --> 00:02:31,319
write the test for this application, for

72
00:02:31,319 --> 00:02:32,319
this task API.

73
00:02:33,038 --> 00:02:35,199
Uh, so with that, we are good to start and

74
00:02:35,199 --> 00:02:36,778
we're gonna switch to the IDE.

75
00:02:38,469 --> 00:02:46,088
I It's

76
00:02:46,088 --> 00:02:47,278
stopped mirroring, I think.

77
00:02:49,189 --> 00:02:50,169
It's not mirroring.

78
00:02:50,740 --> 00:02:51,949
It's not mirroring, sorry.

79
00:02:53,349 --> 00:02:54,490
Sorry, just give us a second.

80
00:02:54,788 --> 00:02:57,050
Um, so I'm gonna start off by taking

81
00:02:57,050 --> 00:02:59,270
you through a quick code walkthrough of

82
00:02:59,270 --> 00:03:00,659
the current application.

83
00:03:01,110 --> 00:03:03,429
Now, we have chosen Python in this particular

84
00:03:03,429 --> 00:03:05,508
case, but a lot of the best practices we talk

85
00:03:05,508 --> 00:03:07,588
about will apply for any other

86
00:03:07,588 --> 00:03:08,770
programming language as well.

87
00:03:09,270 --> 00:03:11,349
Now as we go through the code base, this is a slightly

88
00:03:11,349 --> 00:03:13,258
trimmed down version of the code.

89
00:03:13,629 --> 00:03:15,819
So we have published the full version of this

90
00:03:15,819 --> 00:03:17,909
application to GitHub and we'll be sharing the links with

91
00:03:17,909 --> 00:03:18,669
you later on.

92
00:03:19,118 --> 00:03:21,199
Uh, so for, for this talk, we just want you to

93
00:03:21,199 --> 00:03:23,319
focus more on how the code is

94
00:03:23,319 --> 00:03:25,319
structured and the actual flow

95
00:03:25,319 --> 00:03:26,860
and how we're gonna evolve it.

96
00:03:27,399 --> 00:03:29,520
Um, so real quick, if we

97
00:03:29,520 --> 00:03:31,599
look at the directory structure currently,

98
00:03:31,800 --> 00:03:33,800
um, we are just gonna focus on the

99
00:03:33,800 --> 00:03:35,960
task API behind API gateway.

100
00:03:36,360 --> 00:03:38,558
Uh, all of the code is in the task API folder

101
00:03:38,558 --> 00:03:40,758
and our tests are in the test folder, and we'll

102
00:03:40,758 --> 00:03:42,699
start with just the unit test for now.

103
00:03:43,479 --> 00:03:45,508
So, just a quick check. Can everybody see the

104
00:03:45,508 --> 00:03:47,099
code? Is it big enough?

105
00:03:47,639 --> 00:03:49,550
If not, just raise your hand. We'll, OK,

106
00:03:49,879 --> 00:03:52,028
cool. So let's start

107
00:03:52,028 --> 00:03:54,050
with our lambda handler first. Uh,

108
00:03:54,129 --> 00:03:56,409
so we are using power tools here to simplify

109
00:03:56,409 --> 00:03:58,409
implementing some of the serverless best

110
00:03:58,409 --> 00:03:59,118
practices.

111
00:04:00,558 --> 00:04:02,599
The handler itself, we've gone down,

112
00:04:02,758 --> 00:04:05,050
we've chosen to kind of combine all the task

113
00:04:05,050 --> 00:04:07,419
CRD operations into a single lambda function

114
00:04:07,419 --> 00:04:08,990
as against a micro lambda,

115
00:04:09,319 --> 00:04:11,479
but Power tools makes it really easy to route

116
00:04:11,479 --> 00:04:13,618
the request to the correct function. So for example,

117
00:04:13,719 --> 00:04:15,960
if you get a post on the slash slash task

118
00:04:15,960 --> 00:04:18,040
endpoint, it'll end up invoking our

119
00:04:18,040 --> 00:04:19,178
create task function.

120
00:04:19,670 --> 00:04:21,759
Uh, so it's fairly straightforward, we first parse

121
00:04:21,759 --> 00:04:23,838
the event to extract what we want, which

122
00:04:23,838 --> 00:04:25,548
is just our task details.

123
00:04:26,000 --> 00:04:27,298
We build the task object.

124
00:04:28,269 --> 00:04:30,389
Then we process the task to our database, in

125
00:04:30,389 --> 00:04:31,649
this case Dynamo DB.

126
00:04:32,309 --> 00:04:34,509
We publish the event and then we construct

127
00:04:34,509 --> 00:04:36,750
the response and there is some basic error handling

128
00:04:36,750 --> 00:04:39,040
here. Um, our task handler

129
00:04:39,040 --> 00:04:41,079
also enforces some of the business

130
00:04:41,079 --> 00:04:43,209
rules. So as an example, if you're updating

131
00:04:43,209 --> 00:04:45,399
a task and you're defining dependencies

132
00:04:45,399 --> 00:04:47,720
between the tasks, you don't want to end up with circular

133
00:04:47,720 --> 00:04:48,338
dependency.

134
00:04:49,000 --> 00:04:51,160
So in, in this case, when you update a task, there

135
00:04:51,160 --> 00:04:53,278
is a check here where we are, we've created

136
00:04:53,278 --> 00:04:55,759
a helper function that validates dependencies,

137
00:04:55,879 --> 00:04:57,920
but the rest of the flow is the same. You update

138
00:04:57,920 --> 00:05:00,000
the database, you publish the event, and then you

139
00:05:00,000 --> 00:05:01,259
construct your response.

140
00:05:02,420 --> 00:05:04,108
Um, our helper function here,

141
00:05:04,629 --> 00:05:06,670
given a task, it basically queries the

142
00:05:06,670 --> 00:05:09,088
database to build the existing dependency

143
00:05:09,088 --> 00:05:11,259
graph, and then it's going to

144
00:05:11,259 --> 00:05:13,350
just pass through the graph to identify if you're

145
00:05:13,350 --> 00:05:14,500
going to violate the rule or not.

146
00:05:16,209 --> 00:05:18,259
Model's file is pretty straightforward. This has

147
00:05:18,259 --> 00:05:19,629
just our data classes.

148
00:05:20,588 --> 00:05:22,838
Our domain logic has business rules. Again,

149
00:05:22,928 --> 00:05:25,149
in the real world scenario, you would have a lot more rules

150
00:05:25,149 --> 00:05:27,350
here, but to keep things simple, we will simply

151
00:05:27,350 --> 00:05:29,389
focus on the circular dependency check for

152
00:05:29,389 --> 00:05:30,269
the demo today.

153
00:05:30,629 --> 00:05:33,069
So the idea here is given a task, it's

154
00:05:33,069 --> 00:05:35,189
dependency and the dependency graph from the

155
00:05:35,189 --> 00:05:37,420
database, this is just doing a depth-first

156
00:05:37,420 --> 00:05:39,769
search to identify circular dependency.

157
00:05:40,350 --> 00:05:42,428
And then the very last file we have here is

158
00:05:42,428 --> 00:05:44,790
the integrations where we define the integration

159
00:05:44,790 --> 00:05:46,420
with AWS services.

160
00:05:46,750 --> 00:05:48,949
So you can see we've used Boto 3 initialized

161
00:05:48,949 --> 00:05:49,869
our clients here.

162
00:05:50,519 --> 00:05:52,838
And this is the class that, this is the module

163
00:05:52,838 --> 00:05:55,119
that has the implementation of the methods invoked

164
00:05:55,119 --> 00:05:55,879
from our handler.

165
00:05:56,319 --> 00:05:58,358
So our safe task to Dynamo DB ends up calling

166
00:05:58,358 --> 00:05:59,129
the put item

167
00:05:59,509 --> 00:06:01,678
API and likewise, uh, this is

168
00:06:01,678 --> 00:06:03,720
where we actually publish the event to event

169
00:06:03,720 --> 00:06:05,540
bridge. Um,

170
00:06:05,928 --> 00:06:07,928
let's take a very quick look at how we've

171
00:06:07,928 --> 00:06:10,309
written the unit test for our Task Handler.

172
00:06:10,889 --> 00:06:13,028
Now, because our task actually

173
00:06:13,028 --> 00:06:15,329
persists tasks to Dynamo DB and publishes

174
00:06:15,329 --> 00:06:17,329
events, if we have to unit test this, we

175
00:06:17,329 --> 00:06:19,269
have to mock out those dependencies.

176
00:06:19,809 --> 00:06:21,879
So in this particular case, currently we are using

177
00:06:21,879 --> 00:06:24,689
Moto. So Moto is a Python library

178
00:06:24,689 --> 00:06:26,928
specifically designed to kind of mock out

179
00:06:26,928 --> 00:06:27,569
BTO 3.

180
00:06:28,088 --> 00:06:30,088
So that makes our life a little bit easier in

181
00:06:30,088 --> 00:06:31,129
a couple of ways.

182
00:06:31,649 --> 00:06:33,928
So our P test fixtures are just the reusable

183
00:06:33,928 --> 00:06:35,579
setup and tear down for our tests.

184
00:06:35,928 --> 00:06:38,209
As a best practice, we have set set the AWS

185
00:06:38,209 --> 00:06:40,569
credentials to dummy values for our unit tests.

186
00:06:41,298 --> 00:06:43,298
So with Moto 3 you just need to use the

187
00:06:43,298 --> 00:06:45,238
mock AWS context Manager,

188
00:06:45,500 --> 00:06:47,619
and the advantage is because it's designed for

189
00:06:47,619 --> 00:06:49,738
Boto 3, you're still using the same Boto

190
00:06:49,738 --> 00:06:50,899
3 client calls.

191
00:06:51,660 --> 00:06:53,759
What this is also doing transparently

192
00:06:53,759 --> 00:06:55,858
is that it's monkey patching the Boto 3

193
00:06:55,858 --> 00:06:57,949
calls during runtime. Basically it'll

194
00:06:57,949 --> 00:07:00,048
intercept calls to Boto 3 at runtime

195
00:07:00,048 --> 00:07:01,738
and replace it with our mock.

196
00:07:02,480 --> 00:07:04,608
Uh, we also need to mock our event bridge. We

197
00:07:04,608 --> 00:07:06,959
have created a mock test context, and

198
00:07:06,959 --> 00:07:09,209
just a quick look at two tests. Our

199
00:07:09,209 --> 00:07:10,420
first test is a

200
00:07:10,928 --> 00:07:11,838
successful scenario where,

201
00:07:12,569 --> 00:07:14,699
given a task, we create the task

202
00:07:14,699 --> 00:07:16,250
successfully within the database.

203
00:07:17,230 --> 00:07:19,389
So we need to pass our our fixtures

204
00:07:19,389 --> 00:07:21,509
as arguments to the test case.

205
00:07:21,920 --> 00:07:23,170
We import the handler,

206
00:07:23,428 --> 00:07:24,910
we create our test event.

207
00:07:25,809 --> 00:07:27,850
We invoke the lambda handler with the event

208
00:07:27,850 --> 00:07:29,970
and the context, and that's that we validate

209
00:07:29,970 --> 00:07:32,369
the response, you can optionally test the mock

210
00:07:32,369 --> 00:07:33,230
state as well.

211
00:07:33,850 --> 00:07:36,160
And then let's take a look at another test case

212
00:07:36,160 --> 00:07:38,569
uh that enforces the circular dependency

213
00:07:38,569 --> 00:07:40,670
rule. This test is a little

214
00:07:40,670 --> 00:07:42,910
bit more involved than the first because

215
00:07:42,910 --> 00:07:44,980
this depends on the dependency graph

216
00:07:44,980 --> 00:07:47,028
existing in the database. So as part of

217
00:07:47,028 --> 00:07:48,108
setting up this test,

218
00:07:48,548 --> 00:07:50,699
we need to create a few tasks, in this case

219
00:07:50,699 --> 00:07:52,108
task one and task 2,

220
00:07:52,428 --> 00:07:54,790
and we persist these tasks to our mock

221
00:07:54,790 --> 00:07:56,119
Dynamo DB database.

222
00:07:56,509 --> 00:07:58,809
And the rest of the steps are pretty much the same.

223
00:07:58,949 --> 00:08:01,108
We create the test event, invoke the handler,

224
00:08:01,230 --> 00:08:03,350
only in this case we expect an error

225
00:08:03,350 --> 00:08:05,350
response. So I'm gonna run this

226
00:08:05,350 --> 00:08:07,350
test in a second to show what happens.

227
00:08:07,470 --> 00:08:09,509
Uh, but this is our current code base. So kind

228
00:08:09,509 --> 00:08:11,850
of the question here is, you know, let's say our

229
00:08:12,420 --> 00:08:14,040
Business rules change in the future,

230
00:08:14,379 --> 00:08:16,459
the needs change, and maybe we need to

231
00:08:16,459 --> 00:08:18,040
replace Dynamo DB with something else,

232
00:08:19,600 --> 00:08:21,649
maybe DocumentDB or maybe we need to replace EventBridge with

233
00:08:21,649 --> 00:08:22,399
something else.

234
00:08:22,778 --> 00:08:24,819
So can you think about the implications of

235
00:08:24,819 --> 00:08:27,139
this? So, of course, we'll have to update our integrations

236
00:08:27,139 --> 00:08:28,970
file to talk to the new services,

237
00:08:29,379 --> 00:08:31,619
but just from a testing or developer experience

238
00:08:31,619 --> 00:08:33,739
perspective, do you see any challenges with the way

239
00:08:33,739 --> 00:08:35,359
the code is written right now?

240
00:08:36,229 --> 00:08:38,447
You can just shout out the answers

241
00:08:38,707 --> 00:08:40,749
and I'll just run the test suite. How many of you

242
00:08:40,749 --> 00:08:43,028
ran into difficulties when you were trying to change

243
00:08:43,028 --> 00:08:45,308
the integration architecture and

244
00:08:45,308 --> 00:08:47,178
then you had to change all the testing,

245
00:08:47,749 --> 00:08:49,817
all the related code afterwards, just give us a raise of

246
00:08:49,817 --> 00:08:50,369
hands.

247
00:08:51,440 --> 00:08:52,178
There you go.

248
00:08:53,808 --> 00:08:55,879
Yeah, so, so just as we did the code

249
00:08:55,879 --> 00:08:56,808
walkthrough like you,

250
00:08:57,090 --> 00:08:59,369
so our test cases, for

251
00:08:59,369 --> 00:09:01,428
example, that's testing the handler code,

252
00:09:01,570 --> 00:09:03,849
and it's, you know, just basically testing

253
00:09:03,849 --> 00:09:05,229
the response status

254
00:09:05,558 --> 00:09:07,558
and the details of the response returned,

255
00:09:07,690 --> 00:09:09,729
that test will have to be updated because now

256
00:09:09,729 --> 00:09:11,769
the mock will have to be changed to work with the

257
00:09:11,769 --> 00:09:13,009
new services we pick.

258
00:09:13,629 --> 00:09:15,629
Um, so this kind of creates, so although you

259
00:09:15,629 --> 00:09:17,830
did not change the actual code that was

260
00:09:17,830 --> 00:09:20,099
tested by the test case, you need to rewrite

261
00:09:20,099 --> 00:09:22,090
all those tests. So this kind of,

262
00:09:22,469 --> 00:09:23,928
you know, creates extra work.

263
00:09:24,509 --> 00:09:26,849
So I have just run the test here. Um,

264
00:09:27,349 --> 00:09:29,389
so for those not familiar with Python,

265
00:09:29,428 --> 00:09:31,509
so poetry, it's just a library commonly used

266
00:09:31,509 --> 00:09:33,288
for packaging and dependency management,

267
00:09:33,750 --> 00:09:36,009
and PyTest is a really common testing framework

268
00:09:36,009 --> 00:09:36,590
in Python.

269
00:09:37,139 --> 00:09:39,200
So I've turned on the timing for our tests

270
00:09:39,200 --> 00:09:41,259
here. Um, so you can see that there is a

271
00:09:41,259 --> 00:09:43,918
slight overhead in our setup where we are initializing

272
00:09:43,918 --> 00:09:46,139
the mock functions and it varies

273
00:09:46,139 --> 00:09:48,239
between 400 to 500 milliseconds.

274
00:09:48,700 --> 00:09:51,219
Um, so in this case, we've only got 2

275
00:09:51,219 --> 00:09:52,009
tests, um,

276
00:09:52,460 --> 00:09:54,820
the actual runtime depends on whether the dependencies

277
00:09:54,820 --> 00:09:56,940
are cached or not, so we've run this a few times

278
00:09:56,940 --> 00:09:57,599
in our laptop,

279
00:09:58,019 --> 00:10:00,090
but there's kind of, you know, room to

280
00:10:00,090 --> 00:10:02,519
probably improve and make our tests a little bit faster.

281
00:10:03,139 --> 00:10:04,918
So just given this code base,

282
00:10:05,960 --> 00:10:08,200
Let's quickly summarize what we have seen.

283
00:10:10,658 --> 00:10:12,658
Um, currently, the way we've written the

284
00:10:12,658 --> 00:10:15,298
code, this is very tightly coupled to the infrastructure

285
00:10:15,298 --> 00:10:17,359
choices. So if you have to change anything

286
00:10:17,359 --> 00:10:19,700
on the AWS layer, you end up rewriting

287
00:10:19,700 --> 00:10:21,859
test, uh, that would, that should not really

288
00:10:21,859 --> 00:10:23,259
be affected by the change.

289
00:10:23,779 --> 00:10:25,820
There is a little bit of friction with the developer

290
00:10:25,820 --> 00:10:27,940
experience that you do need to know for mocking

291
00:10:27,940 --> 00:10:29,759
exactly how the services work.

292
00:10:30,750 --> 00:10:32,950
And then of course there, there's room to potentially

293
00:10:32,950 --> 00:10:35,649
improve our tests and make them faster.

294
00:10:36,269 --> 00:10:38,428
So now I'm gonna pass it over to Thomas to see

295
00:10:38,428 --> 00:10:40,590
how we should address these problems and what's

296
00:10:40,590 --> 00:10:42,298
the best way to write the tests.

297
00:10:42,590 --> 00:10:44,590
Thanks, Arie. Before we proceed, how many

298
00:10:44,590 --> 00:10:46,219
of you are Python developers?

299
00:10:46,590 --> 00:10:47,629
Just give us a raise of hands.

300
00:10:47,950 --> 00:10:49,989
Good number. For those of you that, that don't work with

301
00:10:49,989 --> 00:10:52,090
Python, don't worry, all these principles

302
00:10:52,590 --> 00:10:54,629
are applicable across the board for. We just picked

303
00:10:54,629 --> 00:10:56,460
Python just because we are familiar with it,

304
00:10:56,750 --> 00:10:58,450
but all the principles essentially can.

305
00:10:58,908 --> 00:11:01,239
Uh, be applied to anything and everything.

306
00:11:01,558 --> 00:11:03,979
Uh, just give me one second.

307
00:11:06,558 --> 00:11:07,080
Oops.

308
00:11:10,639 --> 00:11:11,239
All right.

309
00:11:11,719 --> 00:11:14,109
So. Arie walked us

310
00:11:14,109 --> 00:11:16,158
through our current architecture, uh,

311
00:11:16,269 --> 00:11:18,469
we saw some pitfalls in there. Uh, now

312
00:11:18,469 --> 00:11:19,009
let's

313
00:11:19,450 --> 00:11:21,168
have a look at how we're going to fix it.

314
00:11:21,668 --> 00:11:24,070
So what I'm going to do, I'm going to use

315
00:11:24,070 --> 00:11:26,090
Kro CLL for this particular task.

316
00:11:26,619 --> 00:11:28,750
Now just give me one second, I'll just fire

317
00:11:28,750 --> 00:11:29,408
it up.

318
00:11:33,489 --> 00:11:35,788
And You may notice

319
00:11:35,788 --> 00:11:37,288
that I'm not using the traditional

320
00:11:37,830 --> 00:11:39,950
uh invoke command for Kira CLI. I'm

321
00:11:39,950 --> 00:11:41,820
using something that's called custom agent,

322
00:11:42,190 --> 00:11:44,428
and I'll tell you what a custom agent is

323
00:11:44,428 --> 00:11:46,099
just in just a minute.

324
00:11:46,428 --> 00:11:48,509
I'm just going to pass a prompt which

325
00:11:48,509 --> 00:11:50,509
essentially is asking Kira to

326
00:11:50,509 --> 00:11:52,489
do a review of my current architecture

327
00:11:52,750 --> 00:11:54,879
and propose, uh,

328
00:11:55,109 --> 00:11:57,229
or suggest what are the problems and also

329
00:11:57,229 --> 00:11:58,479
propose how to fix them.

330
00:11:58,950 --> 00:12:01,070
So I'll just execute that and we'll get

331
00:12:01,070 --> 00:12:01,859
to that

332
00:12:02,149 --> 00:12:03,928
in a minute. I'll just leave it running.

333
00:12:04,619 --> 00:12:05,960
I just want to show you.

334
00:12:06,739 --> 00:12:09,099
What's under the hood. So if we go to a Kiro

335
00:12:09,779 --> 00:12:11,250
folder in our project folder,

336
00:12:11,700 --> 00:12:13,460
we'll have a section called agents.

337
00:12:14,259 --> 00:12:15,960
If I opened it up and I'll.

338
00:12:17,210 --> 00:12:18,889
Just remove this for a minute.

339
00:12:21,399 --> 00:12:22,509
And make this a little bit bigger.

340
00:12:23,509 --> 00:12:25,788
So this is essentially a configuration of a custom

341
00:12:25,788 --> 00:12:27,950
agent. Now, what a custom agent is,

342
00:12:28,070 --> 00:12:30,428
it's an instance of Kiro agent

343
00:12:30,428 --> 00:12:32,729
or Kiro CLR agent rather, that we can

344
00:12:32,908 --> 00:12:35,229
configure for a specific task. So you can notice

345
00:12:35,229 --> 00:12:36,048
that I have

346
00:12:36,389 --> 00:12:38,408
a specific set of MCP servers

347
00:12:39,149 --> 00:12:41,379
just for this particular operation, so,

348
00:12:41,629 --> 00:12:43,629
and I'm also passing a description and a

349
00:12:43,629 --> 00:12:44,210
prompt

350
00:12:44,788 --> 00:12:46,979
to uh the agent which is

351
00:12:46,979 --> 00:12:49,070
used alongside of my prompt that I passed

352
00:12:49,070 --> 00:12:51,168
to it. So this is think of it

353
00:12:51,168 --> 00:12:53,489
as a specialized agent for a particular task.

354
00:12:53,570 --> 00:12:56,129
So in our case it's going to be evaluating our architecture.

355
00:12:56,210 --> 00:12:57,469
You can have a specialized

356
00:12:58,048 --> 00:12:59,250
security auditing,

357
00:12:59,558 --> 00:13:01,918
uh, agents. You can have compliance agents, etc.

358
00:13:01,928 --> 00:13:03,038
agents, etc.

359
00:13:03,399 --> 00:13:05,408
So it depends on your use case, uh, that

360
00:13:05,408 --> 00:13:07,690
you would use. Uh, we also have a built-in

361
00:13:07,690 --> 00:13:09,690
agents that we released this week, agreement,

362
00:13:09,788 --> 00:13:11,808
uh, such as the, uh, AWS Security

363
00:13:11,808 --> 00:13:14,168
and AWS AWS DevOps agents

364
00:13:14,168 --> 00:13:14,859
which are

365
00:13:15,408 --> 00:13:16,750
on the side of Quiro. They're not

366
00:13:17,399 --> 00:13:18,590
inside of Quiro at the moment, but.

367
00:13:18,989 --> 00:13:21,070
Uh, these are capabilities that you can configure inside of

368
00:13:21,070 --> 00:13:22,548
the Kira or Kiro CLI brow.

369
00:13:23,190 --> 00:13:25,469
We also configure tools, uh, so

370
00:13:25,469 --> 00:13:27,788
it's, it's quite customizable. You can configure steering

371
00:13:27,788 --> 00:13:29,908
files that actually tweak how

372
00:13:29,908 --> 00:13:31,918
the agent operates and what kind of output it

373
00:13:31,918 --> 00:13:34,269
returns. So, with that said, let's

374
00:13:34,269 --> 00:13:36,649
go back to our terminal.

375
00:13:37,509 --> 00:13:39,678
And let's double check what the response is essentially.

376
00:13:40,158 --> 00:13:42,558
So we can see that Kiro on the scroll

377
00:13:42,558 --> 00:13:44,158
all the way up.

378
00:13:45,019 --> 00:13:47,080
Kiiro did a review and it

379
00:13:47,080 --> 00:13:48,058
did use.

380
00:13:49,229 --> 00:13:51,349
Uh, did read our whole project

381
00:13:51,349 --> 00:13:53,389
essentially, uh, at points here

382
00:13:53,389 --> 00:13:55,428
and there it used the MCP configuration just

383
00:13:55,428 --> 00:13:57,590
to enhance its answers and generated

384
00:13:57,590 --> 00:14:00,029
a full hexagonal, hexagonal architecture

385
00:14:00,029 --> 00:14:00,889
audit report,

386
00:14:01,548 --> 00:14:03,629
uh, that we can either read in this

387
00:14:03,629 --> 00:14:05,639
terminal format or we can read it in a

388
00:14:05,639 --> 00:14:07,609
proper MD format,

389
00:14:07,989 --> 00:14:10,029
uh, which I'll show you and it's probably

390
00:14:10,029 --> 00:14:11,009
easier to

391
00:14:11,788 --> 00:14:13,649
read. I'll just flip here.

392
00:14:15,048 --> 00:14:17,279
So there's a few sections

393
00:14:17,279 --> 00:14:19,649
there. I'm not gonna go through that in detail, but this

394
00:14:19,649 --> 00:14:22,070
just showcases how you can leverage agentic

395
00:14:22,070 --> 00:14:24,119
AI to help you with

396
00:14:24,119 --> 00:14:26,119
current review and kind of also

397
00:14:26,119 --> 00:14:28,269
look around corners because you know we are

398
00:14:28,269 --> 00:14:30,830
developers we know what we're doing, but

399
00:14:30,830 --> 00:14:32,759
sometimes we don't account for every single scenario.

400
00:14:33,529 --> 00:14:35,570
and we may not see everything that's related

401
00:14:35,570 --> 00:14:37,928
to our application that might be potentially needing

402
00:14:38,408 --> 00:14:40,668
updated updates or or being,

403
00:14:40,690 --> 00:14:42,048
uh, need to be improved

404
00:14:42,408 --> 00:14:44,408
so we can see already

405
00:14:44,408 --> 00:14:46,690
that it it asks us or it

406
00:14:46,690 --> 00:14:48,690
suggests us to fix, um, the domain logic

407
00:14:48,690 --> 00:14:49,590
dependencies.

408
00:14:50,168 --> 00:14:52,519
Uh, there's going to be more, uh,

409
00:14:52,529 --> 00:14:54,649
section essentially related to the pattern how

410
00:14:54,649 --> 00:14:57,000
we design the architecture of the

411
00:14:57,000 --> 00:14:57,729
application, etc.

412
00:14:58,269 --> 00:15:00,349
Uh, as I said, I'm not gonna go through this in a

413
00:15:00,349 --> 00:15:01,729
whole heap of detail,

414
00:15:02,070 --> 00:15:04,149
but, uh, you can see there's quite a

415
00:15:04,149 --> 00:15:04,690
bit of

416
00:15:05,469 --> 00:15:07,808
information there. Now, why is this useful?

417
00:15:08,509 --> 00:15:10,369
Because we can essentially

418
00:15:10,908 --> 00:15:13,308
go to Quiro and we can ask,

419
00:15:13,428 --> 00:15:14,649
ask it to.

420
00:15:15,158 --> 00:15:16,700
You can notice I mean a spec

421
00:15:17,119 --> 00:15:19,599
kind of uh spec uh flow

422
00:15:19,599 --> 00:15:20,379
which creates

423
00:15:20,769 --> 00:15:22,619
spec driven development essentially

424
00:15:22,879 --> 00:15:24,918
uh spec specs that we can use

425
00:15:24,918 --> 00:15:27,119
to quantify the requirements, design and

426
00:15:27,119 --> 00:15:29,320
implementation of individual tasks. It's

427
00:15:29,320 --> 00:15:31,340
particularly useful for for feature

428
00:15:31,340 --> 00:15:33,029
or general software development,

429
00:15:33,320 --> 00:15:35,609
but in our case we're going to use it

430
00:15:35,879 --> 00:15:37,139
to create a plan

431
00:15:37,558 --> 00:15:39,590
to integrate the changes that Kiiro

432
00:15:39,590 --> 00:15:41,298
actually suggested us to do.

433
00:15:42,080 --> 00:15:43,580
So I'll just reference the file.

434
00:15:44,440 --> 00:15:46,979
That has our.

435
00:15:48,788 --> 00:15:50,408
Evaluation our audit

436
00:15:51,038 --> 00:15:53,769
and I'll ask you to generate.

437
00:15:55,678 --> 00:15:57,960
It's just while Thomas is doing this, so,

438
00:15:58,038 --> 00:16:00,250
uh, I think he mentioned hexagonal architecture.

439
00:16:00,359 --> 00:16:02,529
So the thinking there was because our code base

440
00:16:02,529 --> 00:16:04,609
was kind of tightly coupled with the different

441
00:16:04,609 --> 00:16:06,609
concerns, so the idea was how do

442
00:16:06,609 --> 00:16:08,690
we decouple it, and hexagonal architecture

443
00:16:08,690 --> 00:16:10,759
is one way to do that. So the idea

444
00:16:10,759 --> 00:16:11,619
is you have got code

445
00:16:12,408 --> 00:16:14,820
or ports that only deal with the interfaces,

446
00:16:14,849 --> 00:16:16,889
and you've got the core business logic, and then

447
00:16:16,889 --> 00:16:19,048
you have a glue layer that connects the interface

448
00:16:19,048 --> 00:16:20,009
to the business logic.

449
00:16:20,288 --> 00:16:22,330
So we have kind of used that as a baseline

450
00:16:22,330 --> 00:16:24,149
to uh rearchitect the code.

451
00:16:24,849 --> 00:16:26,479
Exactly. So

452
00:16:27,029 --> 00:16:29,379
we can see that this was a little bit faster than usual

453
00:16:29,379 --> 00:16:31,859
just because I actually have a spec spec

454
00:16:31,859 --> 00:16:34,080
created just for the sake of time,

455
00:16:34,369 --> 00:16:36,460
but normally Kira would go in and

456
00:16:36,460 --> 00:16:38,538
create the whole spec from the ground up with

457
00:16:38,538 --> 00:16:40,580
requirements, design, and tasks, we can see

458
00:16:40,580 --> 00:16:42,200
those three files in here,

459
00:16:42,460 --> 00:16:44,570
referenced and actually gives us a description

460
00:16:44,570 --> 00:16:45,190
of what it

461
00:16:45,658 --> 00:16:47,779
did. Now, I'll show you how those

462
00:16:47,779 --> 00:16:49,080
files actually look like.

463
00:16:49,739 --> 00:16:52,210
So if I go back to my Kiro folder,

464
00:16:52,538 --> 00:16:54,019
I'll just minimize this.

465
00:16:54,479 --> 00:16:56,690
We have a folder called specs, and

466
00:16:56,690 --> 00:16:58,058
in there we have a

467
00:16:58,399 --> 00:16:59,460
hexagonal spec.

468
00:17:00,408 --> 00:17:02,529
If I open the requirements, I'll

469
00:17:02,529 --> 00:17:03,849
just get.

470
00:17:05,278 --> 00:17:07,019
This here and,

471
00:17:12,087 --> 00:17:12,968
Oops, sorry.

472
00:17:14,979 --> 00:17:15,578
Where am I?

473
00:17:16,368 --> 00:17:17,587
Here, OK,

474
00:17:18,167 --> 00:17:20,489
so, um, in the requirements

475
00:17:20,489 --> 00:17:22,749
file, oops see Daisy, hold on.

476
00:17:25,449 --> 00:17:27,078
There's always something with live demo.

477
00:17:29,479 --> 00:17:31,549
OK, let's minimize this. There we go.

478
00:17:31,689 --> 00:17:33,689
So this is our requirements file. You can see that we

479
00:17:33,689 --> 00:17:34,219
have

480
00:17:34,588 --> 00:17:36,848
introduction, we have glossary to kind of

481
00:17:36,848 --> 00:17:38,969
understand all the terms, and we have all the requirements and

482
00:17:38,969 --> 00:17:41,348
especially acceptance criteria that are needed

483
00:17:41,608 --> 00:17:42,400
for every single project,

484
00:17:42,809 --> 00:17:45,009
any single change that you're running to your

485
00:17:45,009 --> 00:17:47,410
project, be it a feature, be it architecture,

486
00:17:47,489 --> 00:17:49,489
be it anything essentially, it's very, very useful

487
00:17:49,489 --> 00:17:50,868
when working with AI especially.

488
00:17:51,400 --> 00:17:53,479
Now the next file that he created for

489
00:17:53,479 --> 00:17:55,759
us is design. So this is the full

490
00:17:55,759 --> 00:17:57,759
design of changes we can actually see

491
00:17:57,759 --> 00:18:00,239
the diagram of changes that it'll be implementing

492
00:18:00,239 --> 00:18:01,459
into into

493
00:18:01,989 --> 00:18:04,118
the process. This is the target architecture, how

494
00:18:04,118 --> 00:18:04,858
it's going to

495
00:18:05,400 --> 00:18:07,459
augmented or rather decouple, uh, uh,

496
00:18:07,469 --> 00:18:09,779
features to make them more flexible, more versatile,

497
00:18:10,160 --> 00:18:12,180
and, uh, easier to test as well.

498
00:18:12,400 --> 00:18:14,519
Uh, I'm not gonna go through all of this

499
00:18:14,519 --> 00:18:16,338
in detail. I just want to highlight the process.

500
00:18:17,239 --> 00:18:19,479
But the most important thing here is the task

501
00:18:19,479 --> 00:18:20,299
list. Now

502
00:18:20,880 --> 00:18:23,160
here we could go to Quiro and ask it to

503
00:18:23,160 --> 00:18:23,818
essentially

504
00:18:24,078 --> 00:18:25,358
start executing these either in,

505
00:18:25,828 --> 00:18:27,549
in sequence 11 by one,

506
00:18:28,219 --> 00:18:30,239
do the whole project ess essentially in one

507
00:18:30,239 --> 00:18:32,279
go. Depends how much time you have.

508
00:18:32,489 --> 00:18:34,799
Depends if you're doing something on the side, but you can essentially

509
00:18:34,799 --> 00:18:36,969
delegate this to Kiro to

510
00:18:36,969 --> 00:18:38,420
go through on its own.

511
00:18:39,479 --> 00:18:40,939
Observe it at some point,

512
00:18:41,239 --> 00:18:43,439
um, verify that it's doing the job that it's

513
00:18:43,439 --> 00:18:44,170
supposed to do,

514
00:18:44,479 --> 00:18:45,739
uh, but essentially

515
00:18:46,000 --> 00:18:48,358
do the migration or rather refactoring

516
00:18:48,358 --> 00:18:50,539
of the obligation on the go on its own.

517
00:18:52,118 --> 00:18:53,328
So, um,

518
00:18:53,959 --> 00:18:56,459
I'm gonna make it easy on myself, I'll just fast forward.

519
00:18:58,068 --> 00:19:00,078
Normally this would take a little bit of time, let me

520
00:19:00,078 --> 00:19:02,219
just. Make this a little

521
00:19:02,219 --> 00:19:04,699
bit bigger. I hope you can see everything now.

522
00:19:06,729 --> 00:19:07,900
Uh, OK.

523
00:19:09,598 --> 00:19:11,539
So, just to illustrate

524
00:19:11,959 --> 00:19:14,039
the original state that we had when

525
00:19:14,039 --> 00:19:15,858
Arti was going through the application,

526
00:19:16,400 --> 00:19:17,640
we had something like this.

527
00:19:18,390 --> 00:19:20,519
We had everything kind of coupled together. Yes, we had

528
00:19:20,519 --> 00:19:22,759
some files that were separate, but

529
00:19:22,759 --> 00:19:24,380
it was all kind of bundled together

530
00:19:24,920 --> 00:19:26,739
with tightly coupled references.

531
00:19:27,239 --> 00:19:29,400
So all the HTP passing, business logic

532
00:19:29,400 --> 00:19:31,259
and, and all the integration calls

533
00:19:31,719 --> 00:19:33,098
were kind of stuck together.

534
00:19:33,519 --> 00:19:35,939
Now, after the audit

535
00:19:36,160 --> 00:19:38,160
and the implementation of that, uh, of those

536
00:19:38,160 --> 00:19:39,019
findings of the audit,

537
00:19:39,598 --> 00:19:40,549
uh, we would use Quiro

538
00:19:41,199 --> 00:19:42,739
through Spector and approach

539
00:19:43,039 --> 00:19:43,618
to

540
00:19:44,029 --> 00:19:45,799
modify our architecture, refactor it.

541
00:19:46,519 --> 00:19:48,588
This is how it would look like. This is the current state

542
00:19:48,588 --> 00:19:49,529
of our architecture.

543
00:19:49,989 --> 00:19:52,390
So we can see we still have our handler, but

544
00:19:52,390 --> 00:19:54,150
it's much, much leaner.

545
00:19:54,459 --> 00:19:56,789
Uh, it's only processing HTTP requests. Then

546
00:19:56,789 --> 00:19:59,108
we have all the business logic kind of offloaded

547
00:19:59,309 --> 00:20:01,500
to our domain layer, and I'll go through this

548
00:20:01,500 --> 00:20:02,630
in more detail in a second.

549
00:20:03,588 --> 00:20:05,979
Uh, and then also through interfaces,

550
00:20:06,000 --> 00:20:08,680
uh, we are communicating with the, uh, adapters

551
00:20:08,680 --> 00:20:09,318
that are,

552
00:20:09,680 --> 00:20:12,160
uh, invoking our services, so the integration.

553
00:20:12,959 --> 00:20:14,618
Now how does this actually look like?

554
00:20:15,509 --> 00:20:17,509
If I go to the task handler again, and

555
00:20:17,509 --> 00:20:19,289
I'll just minimize this side.

556
00:20:22,000 --> 00:20:22,608
So,

557
00:20:23,118 --> 00:20:25,160
in our main handler, uh, we

558
00:20:25,160 --> 00:20:27,400
have a method called create task, right?

559
00:20:28,719 --> 00:20:30,838
So The important

560
00:20:30,838 --> 00:20:32,318
bit here is that

561
00:20:32,759 --> 00:20:34,920
we're no longer coupling anything, we're calling

562
00:20:34,920 --> 00:20:37,160
a delegated task service.

563
00:20:37,479 --> 00:20:39,039
Now if I scroll up here.

564
00:20:41,219 --> 00:20:42,469
And I go to the site,

565
00:20:43,130 --> 00:20:43,789
essentially,

566
00:20:44,088 --> 00:20:46,439
so. That action

567
00:20:46,439 --> 00:20:48,019
is calling the domain logic.

568
00:20:48,559 --> 00:20:50,588
If I flip to domain logic,

569
00:20:50,650 --> 00:20:53,199
essentially, and I'll go to

570
00:20:53,559 --> 00:20:55,380
the top of the task service.

571
00:20:56,930 --> 00:20:59,068
We can see that this particular service

572
00:20:59,068 --> 00:21:01,289
requires a repository

573
00:21:01,289 --> 00:21:03,289
and even publisher to be to process.

574
00:21:03,568 --> 00:21:05,779
So there's two kinds of streams that we, we see.

575
00:21:06,250 --> 00:21:07,430
Uh, we have.

576
00:21:08,189 --> 00:21:10,769
One way that one stream that essentially

577
00:21:11,068 --> 00:21:13,108
uh does an operation when we

578
00:21:13,108 --> 00:21:15,469
don't specify them, and I'll show you what that does,

579
00:21:15,789 --> 00:21:17,828
but if we if we do specify them we

580
00:21:17,828 --> 00:21:19,209
can point it to specific

581
00:21:19,670 --> 00:21:21,529
integration that we can manage.

582
00:21:22,209 --> 00:21:23,430
Now what does this mean?

583
00:21:23,969 --> 00:21:26,769
So if we would, uh,

584
00:21:27,469 --> 00:21:30,630
essentially not specify these these uh parameters,

585
00:21:30,689 --> 00:21:32,949
our application would default to

586
00:21:33,328 --> 00:21:35,368
what it has under the hood and we'll use

587
00:21:35,368 --> 00:21:36,368
interfaces.

588
00:21:37,420 --> 00:21:39,459
To use what we call protocols now

589
00:21:39,459 --> 00:21:41,709
protocols are specifically for Python, but what they

590
00:21:41,709 --> 00:21:42,430
essentially do,

591
00:21:42,739 --> 00:21:44,868
they create contracts without the need

592
00:21:44,868 --> 00:21:47,009
to, uh, set implementation,

593
00:21:47,309 --> 00:21:49,509
and this is what you can see here because the, the

594
00:21:49,509 --> 00:21:51,709
methods in our class for Tel repository

595
00:21:51,709 --> 00:21:53,750
protocol are pretty much empty. There's nothing

596
00:21:53,750 --> 00:21:54,930
really in there

597
00:21:55,430 --> 00:21:57,568
now. Why this is

598
00:21:57,568 --> 00:21:59,930
good, because we can point it to

599
00:21:59,930 --> 00:22:02,309
anything, right? But in our case,

600
00:22:03,549 --> 00:22:05,598
If we go back to the logic, essentially we can see

601
00:22:05,598 --> 00:22:06,219
that the

602
00:22:06,750 --> 00:22:08,900
repository in this case is set to

603
00:22:08,900 --> 00:22:10,930
none. Which

604
00:22:10,930 --> 00:22:13,729
means that we are calling integrations.

605
00:22:14,430 --> 00:22:15,910
And through integrations.

606
00:22:17,479 --> 00:22:19,969
If I go to integrations we are calling our integration

607
00:22:19,969 --> 00:22:22,259
to general MoDB or the even bridge,

608
00:22:22,709 --> 00:22:25,130
right? And we can manage this we can modify

609
00:22:25,130 --> 00:22:27,489
this we can point it to something else if

610
00:22:27,489 --> 00:22:28,338
we need to,

611
00:22:28,699 --> 00:22:30,890
uh, this is for the case where we did not

612
00:22:30,890 --> 00:22:32,630
specify the repository and the

613
00:22:32,890 --> 00:22:33,729
even publisher.

614
00:22:34,009 --> 00:22:36,039
If we do specify it, it depends on

615
00:22:36,039 --> 00:22:37,088
what we specify.

616
00:22:37,598 --> 00:22:39,650
The route will be different essentially, and this is

617
00:22:39,650 --> 00:22:40,390
particularly useful

618
00:22:40,729 --> 00:22:41,588
for tests,

619
00:22:41,930 --> 00:22:43,670
um, so back to

620
00:22:44,309 --> 00:22:46,229
our architecture, just wanna recap here.

621
00:22:46,769 --> 00:22:48,630
This is how the decoupling would work here.

622
00:22:50,029 --> 00:22:52,039
And in terms of what we covered essentially

623
00:22:52,039 --> 00:22:53,900
in this part of the the session,

624
00:22:54,199 --> 00:22:56,358
uh, we essentially uh showed

625
00:22:56,358 --> 00:22:58,598
how the handle performs the the validation.

626
00:22:58,959 --> 00:23:00,858
um I'll just take this off.

627
00:23:02,469 --> 00:23:04,630
Uh, we, we saw how the domain logic

628
00:23:04,630 --> 00:23:07,088
is essentially containing all the business

629
00:23:07,189 --> 00:23:08,750
logic and business functionality.

630
00:23:10,338 --> 00:23:11,479
We saw how the integration

631
00:23:11,828 --> 00:23:12,699
layer works.

632
00:23:13,519 --> 00:23:15,979
And then, uh, also

633
00:23:16,439 --> 00:23:18,838
we saw how the abstraction works with the handler

634
00:23:18,838 --> 00:23:20,989
its own, so we are obstructing the logic, the

635
00:23:20,989 --> 00:23:23,420
business logic and the integration from the handle itself,

636
00:23:23,750 --> 00:23:26,259
and we are relying on the domain

637
00:23:26,318 --> 00:23:28,519
to kind of interface to the repository or the

638
00:23:28,519 --> 00:23:30,259
publisher to create a contract

639
00:23:30,680 --> 00:23:31,818
and, um,

640
00:23:32,140 --> 00:23:34,539
afterwards the integration implements,

641
00:23:34,809 --> 00:23:36,729
uh, through the interface straight away services.

642
00:23:38,078 --> 00:23:40,189
And back to you. Yeah, I, I'll show

643
00:23:40,189 --> 00:23:42,259
you the test. So just to recap,

644
00:23:42,519 --> 00:23:43,140
the task,

645
00:23:43,400 --> 00:23:45,588
our domain logic just expects

646
00:23:45,588 --> 00:23:47,719
a task repository that offers the

647
00:23:47,719 --> 00:23:48,880
safe task method

648
00:23:49,318 --> 00:23:51,479
or a delete task method. It does not

649
00:23:51,479 --> 00:23:53,519
know whether it is implemented using Dynamo

650
00:23:53,519 --> 00:23:55,598
DB or Aurora or whatever might

651
00:23:55,598 --> 00:23:56,439
be the service,

652
00:23:56,759 --> 00:23:58,828
and the exact implementation logic is

653
00:23:58,828 --> 00:24:00,680
contained within our integration layer.

654
00:24:01,039 --> 00:24:03,078
So if you go back to the problem suite statement of

655
00:24:03,078 --> 00:24:05,078
swapping, say, Dynamo DB with something else,

656
00:24:05,199 --> 00:24:05,959
your integration.

657
00:24:06,344 --> 00:24:07,104
changes,

658
00:24:07,515 --> 00:24:10,035
but as long as the database is exposed

659
00:24:10,035 --> 00:24:12,223
through the same safe task method,

660
00:24:12,515 --> 00:24:14,713
we don't need to change the tests in our handler

661
00:24:14,713 --> 00:24:15,693
and the logic code.

662
00:24:16,125 --> 00:24:18,174
So I'm going to now actually code out

663
00:24:18,174 --> 00:24:20,334
the tests and then we'll see how

664
00:24:20,334 --> 00:24:22,473
that looks different or simpler than

665
00:24:22,473 --> 00:24:24,509
before. Now,

666
00:24:24,789 --> 00:24:26,848
we'll start with the task handler, uh

667
00:24:26,848 --> 00:24:28,588
sorry, the test for the task Handler.

668
00:24:30,180 --> 00:24:32,368
Before I move to the test, there's one thing I wanted to

669
00:24:32,368 --> 00:24:34,449
call out. So if you saw when Thomas

670
00:24:34,449 --> 00:24:36,449
walked us through the code, we did not

671
00:24:36,449 --> 00:24:38,489
directly initialize the task service

672
00:24:38,489 --> 00:24:39,309
and the handler.

673
00:24:39,689 --> 00:24:41,689
We actually used the get task

674
00:24:41,689 --> 00:24:43,189
service method. Um,

675
00:24:43,689 --> 00:24:45,890
so what we are doing here is setting up our

676
00:24:45,890 --> 00:24:48,009
code for dependency injection. I'm gonna

677
00:24:48,009 --> 00:24:50,130
talk a bit about why that makes testing

678
00:24:50,130 --> 00:24:52,289
easier. Again, those of you familiar with

679
00:24:52,289 --> 00:24:54,509
Java, this will probably seem intuitive,

680
00:24:54,608 --> 00:24:56,689
not so much in the Python world, but we'll see how we

681
00:24:56,689 --> 00:24:57,269
can do it.

682
00:24:57,660 --> 00:24:59,939
So if we actually look at the Get task service,

683
00:25:00,019 --> 00:25:02,160
um, it looks for a service level

684
00:25:02,160 --> 00:25:04,779
uh variable taskservice.

685
00:25:05,459 --> 00:25:07,618
If this is set, it's gonna return it as

686
00:25:07,618 --> 00:25:09,979
it is, but if it's not, it's going to initialize

687
00:25:09,979 --> 00:25:12,140
the task service, and this is the flow

688
00:25:12,140 --> 00:25:14,259
that would actually kick off when our lambda is

689
00:25:14,259 --> 00:25:15,568
actually invoked in production. So,

690
00:25:16,519 --> 00:25:17,949
The key thing I want to call is

691
00:25:18,209 --> 00:25:20,430
at runtime our application does not

692
00:25:20,430 --> 00:25:22,729
rely on dependency injection

693
00:25:22,729 --> 00:25:24,809
because we have provided default ways for the

694
00:25:24,809 --> 00:25:25,318
flows.

695
00:25:25,769 --> 00:25:28,170
So this piece of additional code was specifically

696
00:25:28,170 --> 00:25:30,209
written to simplify testing, and we'll

697
00:25:30,209 --> 00:25:32,108
see how that simplifies testing.

698
00:25:32,650 --> 00:25:33,709
So let's go back to our

699
00:25:33,969 --> 00:25:35,140
test task handler.

700
00:25:35,799 --> 00:25:37,799
At this point, our handler still relies on

701
00:25:37,799 --> 00:25:39,868
the domain logic or the task service,

702
00:25:40,160 --> 00:25:42,279
so we still need to mop that out to test this

703
00:25:42,279 --> 00:25:44,519
in isolation from the rest of the code base.

704
00:25:45,039 --> 00:25:46,479
So the way to do that would be.

705
00:25:47,189 --> 00:25:49,779
Let's say we start off by mocking,

706
00:25:49,828 --> 00:25:51,108
get tasked.

707
00:25:53,299 --> 00:25:55,299
All right, something like this. I'll, I'll

708
00:25:55,299 --> 00:25:57,500
accept this and I'll explain like what this is doing.

709
00:25:57,979 --> 00:26:00,140
So now to unit test our task handler,

710
00:26:00,180 --> 00:26:02,410
we need to mock out only the domain logic,

711
00:26:02,420 --> 00:26:04,858
so we are no longer concerned with the actual AWS

712
00:26:04,858 --> 00:26:05,900
services in use.

713
00:26:06,259 --> 00:26:08,338
We just want to validate that our task handler

714
00:26:08,338 --> 00:26:10,539
works well and returns the correct response

715
00:26:10,539 --> 00:26:11,858
code to our end client.

716
00:26:12,890 --> 00:26:14,689
So we need to do a couple of things.

717
00:26:14,979 --> 00:26:17,410
One is we are going to mock the Getar service

718
00:26:17,410 --> 00:26:18,910
to return a mock object.

719
00:26:19,969 --> 00:26:21,279
Um, so in this case,

720
00:26:21,680 --> 00:26:23,838
that service is called the MC task, MC

721
00:26:23,838 --> 00:26:24,858
Gta Service.

722
00:26:25,640 --> 00:26:27,838
If you remember when we spoke about motto for

723
00:26:27,838 --> 00:26:30,559
Boto 3, motto is automatically

724
00:26:30,559 --> 00:26:32,680
understands BTO 3 API calls, but in this

725
00:26:32,680 --> 00:26:34,759
case, this is a custom mock, so we

726
00:26:34,759 --> 00:26:37,000
need to configure the behavior of the mock task

727
00:26:37,000 --> 00:26:39,068
service. So within our test case,

728
00:26:39,150 --> 00:26:40,979
we will have to go ahead

729
00:26:41,479 --> 00:26:43,699
and say configure mock.

730
00:26:48,500 --> 00:26:50,539
So we, I'm gonna just keep

731
00:26:50,539 --> 00:26:52,939
this simple, but basically you will have to specify

732
00:26:52,939 --> 00:26:55,019
the return value. I won't accept this because

733
00:26:55,019 --> 00:26:57,160
we're gonna do the test a bit differently, but

734
00:26:57,578 --> 00:26:59,578
just to give you the picture, first, I need to

735
00:26:59,578 --> 00:27:01,818
create what the return value for a successful

736
00:27:01,818 --> 00:27:03,318
create task call looks like.

737
00:27:03,818 --> 00:27:05,979
And then we also need the monkey patching

738
00:27:05,979 --> 00:27:08,140
because the patch now has to be managed

739
00:27:08,140 --> 00:27:10,410
by our tests. So essentially every time get task

740
00:27:10,410 --> 00:27:12,500
Services call, we want to insert our mock

741
00:27:12,500 --> 00:27:13,199
into the picture.

742
00:27:13,618 --> 00:27:15,479
That's basically what this test is doing.

743
00:27:16,130 --> 00:27:18,150
Now the thing with this approach is,

744
00:27:18,430 --> 00:27:20,529
remember we just wrote two sample tests, but

745
00:27:20,529 --> 00:27:22,779
we are gonna write tests for all our different

746
00:27:22,779 --> 00:27:23,880
resources and methods,

747
00:27:24,170 --> 00:27:26,430
and at times we want to simulate the error.

748
00:27:26,848 --> 00:27:29,390
So depending upon the behavior we want to simulate,

749
00:27:29,529 --> 00:27:31,529
our mock will either have a return value

750
00:27:31,529 --> 00:27:33,729
or a side effect, which would simply be raising

751
00:27:33,729 --> 00:27:34,588
the exception.

752
00:27:35,059 --> 00:27:37,170
So what happens, it's all our test code

753
00:27:37,170 --> 00:27:39,328
is now riddled with a whole bunch of mock

754
00:27:39,328 --> 00:27:39,838
code,

755
00:27:40,170 --> 00:27:42,588
and we also need to patch the code at runtime.

756
00:27:43,140 --> 00:27:45,259
Now the tricky thing with patching at runtime

757
00:27:45,259 --> 00:27:47,338
is it it can get brittle because if

758
00:27:47,338 --> 00:27:49,459
we change the logic of the domain service, it

759
00:27:49,459 --> 00:27:51,348
can break in unexpected ways,

760
00:27:51,660 --> 00:27:53,818
and also patching can sometimes leak

761
00:27:53,818 --> 00:27:55,410
states across tests,

762
00:27:55,699 --> 00:27:58,059
and this is where we are going to use dependency injection.

763
00:27:58,848 --> 00:27:59,729
So I'm not,

764
00:28:00,049 --> 00:28:02,199
instead we are not going to use the mock service, so

765
00:28:02,199 --> 00:28:02,949
let's see how

766
00:28:03,449 --> 00:28:05,549
dependency injection simplifies our life.

767
00:28:06,009 --> 00:28:08,650
So the first thing is we want a highly configurable

768
00:28:08,650 --> 00:28:11,410
mock whose return value can be changed

769
00:28:11,410 --> 00:28:13,489
depending on the test we are running, whether it's

770
00:28:13,489 --> 00:28:15,328
an error or a success scenario.

771
00:28:15,809 --> 00:28:18,789
So what we really need is a configurable

772
00:28:19,568 --> 00:28:21,650
fake task service. Um, so

773
00:28:21,650 --> 00:28:23,769
this is just an in-memory fake at this point,

774
00:28:23,848 --> 00:28:25,019
this is not a mock.

775
00:28:25,598 --> 00:28:27,680
So what we have done is you can initialize the

776
00:28:27,680 --> 00:28:29,920
fake task service with a bunch of flags

777
00:28:29,920 --> 00:28:32,559
that tells whether the service raises an exception

778
00:28:32,559 --> 00:28:34,559
or just works as expected and follows

779
00:28:34,559 --> 00:28:35,348
the happy path.

780
00:28:35,719 --> 00:28:37,759
So for example, it has the same methods that

781
00:28:37,759 --> 00:28:39,160
our task service offers,

782
00:28:39,598 --> 00:28:41,759
but when we call create tasks, the first check

783
00:28:41,759 --> 00:28:44,078
we do in this in memory fake is to check

784
00:28:44,078 --> 00:28:45,959
whether the exception flag is set.

785
00:28:46,229 --> 00:28:48,338
If set, it'll raise an exception, if not,

786
00:28:48,400 --> 00:28:50,519
it'll go ahead and simply return the task

787
00:28:50,519 --> 00:28:52,578
object. So in scenarios

788
00:28:52,578 --> 00:28:54,699
where you want to highly customize

789
00:28:54,699 --> 00:28:55,410
the behavior of

790
00:28:55,900 --> 00:28:57,588
of your dependency,

791
00:28:58,019 --> 00:29:00,180
it is kind of easier to do that with

792
00:29:00,180 --> 00:29:02,098
in memory fakes rather than a mock.

793
00:29:02,420 --> 00:29:04,618
So the complexity of the mock configuration

794
00:29:04,618 --> 00:29:06,358
has now moved here, so we are not

795
00:29:06,858 --> 00:29:09,059
essentially writing additional code, but it's just

796
00:29:09,059 --> 00:29:11,299
where the complexity goes. It's now in the in-memory

797
00:29:11,299 --> 00:29:11,838
fake.

798
00:29:12,229 --> 00:29:14,348
Now this is the first step. Now we of course

799
00:29:14,348 --> 00:29:15,608
need a fixture again,

800
00:29:15,868 --> 00:29:18,219
uh, because the second step is we, we

801
00:29:18,219 --> 00:29:20,229
need to replace the original

802
00:29:20,229 --> 00:29:22,309
task service call with this mock. So how are we

803
00:29:22,309 --> 00:29:22,979
going to do that?

804
00:29:23,348 --> 00:29:25,430
We said patching is brittle, so what we

805
00:29:25,430 --> 00:29:26,828
are going to do instead

806
00:29:27,108 --> 00:29:29,309
is we are going to use dependency injection

807
00:29:29,309 --> 00:29:31,670
here. So within our pi test fixture

808
00:29:31,670 --> 00:29:33,868
now, we initialize the fake task service.

809
00:29:34,068 --> 00:29:36,328
Now if you remember, our get task service

810
00:29:36,328 --> 00:29:38,529
looks for the module level variable, whether it's

811
00:29:38,529 --> 00:29:39,269
set or not.

812
00:29:39,670 --> 00:29:41,949
So in our test, we are basically setting

813
00:29:41,949 --> 00:29:44,098
that module level variable to our fake task

814
00:29:44,098 --> 00:29:46,209
service, and we have basically injected

815
00:29:46,469 --> 00:29:48,489
our in-memory fake into the test.

816
00:29:49,108 --> 00:29:51,189
Um, and that's it, so anything before the yield is

817
00:29:51,189 --> 00:29:53,390
set up and after the yield statement is your tear

818
00:29:53,390 --> 00:29:54,250
down in Python.

819
00:29:54,680 --> 00:29:56,959
And contest is a file that PyTest

820
00:29:56,959 --> 00:29:59,318
automatically loads, it's just where your reusable

821
00:29:59,318 --> 00:29:59,979
code goes.

822
00:30:00,318 --> 00:30:02,318
So how does this actually make our test

823
00:30:02,318 --> 00:30:04,509
cleaner? So the first thing is

824
00:30:04,509 --> 00:30:06,348
we, we want to use our fake,

825
00:30:06,979 --> 00:30:07,500
all right,

826
00:30:07,779 --> 00:30:09,299
we will probably go to,

827
00:30:09,670 --> 00:30:11,650
we don't need this, this was generated.

828
00:30:12,189 --> 00:30:14,049
So I'll stick to the previous um

829
00:30:14,739 --> 00:30:16,789
structure we had for the test and let's see what

830
00:30:16,789 --> 00:30:17,410
changes.

831
00:30:18,068 --> 00:30:20,078
The first thing is we are now going to make

832
00:30:20,078 --> 00:30:21,828
use of the fake tasker,

833
00:30:22,309 --> 00:30:24,088
so we need to pass this as a variable.

834
00:30:25,068 --> 00:30:27,150
We still create our test event. Now

835
00:30:27,150 --> 00:30:29,150
remember, the behavior of our fake task

836
00:30:29,150 --> 00:30:31,229
service when the flag is not set

837
00:30:31,229 --> 00:30:33,670
is to just return a successful task

838
00:30:33,670 --> 00:30:34,189
response.

839
00:30:34,709 --> 00:30:37,049
So all we need to do to run our tests here.

840
00:30:39,358 --> 00:30:41,108
is we import our handler code.

841
00:30:43,650 --> 00:30:45,719
So this should actually look

842
00:30:45,719 --> 00:30:47,660
similar to what we were doing.

843
00:30:49,160 --> 00:30:50,380
In the old tests.

844
00:30:53,400 --> 00:30:55,019
I then invoke this.

845
00:30:58,459 --> 00:31:00,640
All right, the autocomplete is a bit

846
00:31:00,858 --> 00:31:01,420
laggy.

847
00:31:02,140 --> 00:31:04,338
But basically, we're going to do the same thing that we did

848
00:31:04,338 --> 00:31:06,699
before. I called the lambda handler directly

849
00:31:06,699 --> 00:31:09,358
with the event and the mock lambda context.

850
00:31:11,769 --> 00:31:13,449
And then all we need to do here,

851
00:31:13,848 --> 00:31:16,039
it's all right, it generated this time.

852
00:31:16,170 --> 00:31:18,328
Uh, we can optionally validate the response, but

853
00:31:18,328 --> 00:31:19,769
I'll keep it simple for the demo.

854
00:31:20,250 --> 00:31:22,449
So if you look at it, that's about it for

855
00:31:22,449 --> 00:31:24,608
testing the happy path for the test task

856
00:31:24,608 --> 00:31:27,269
handler. We have used the fake task service,

857
00:31:27,650 --> 00:31:29,729
which gets injected into our task

858
00:31:29,729 --> 00:31:31,930
domain and it is simulating all the different

859
00:31:31,930 --> 00:31:34,088
scenarios that our task service can

860
00:31:34,088 --> 00:31:36,239
raise. So as an example, now if we

861
00:31:36,239 --> 00:31:38,318
take the case for the circular dependency

862
00:31:38,318 --> 00:31:40,338
error. If you remember

863
00:31:40,338 --> 00:31:42,459
the previous code, we had all this logic

864
00:31:42,459 --> 00:31:44,459
to basically create the dependency

865
00:31:44,459 --> 00:31:46,368
map in the database and all of that.

866
00:31:46,818 --> 00:31:49,098
That goes away because now I can simulate

867
00:31:49,098 --> 00:31:50,920
an error simply by

868
00:31:51,920 --> 00:31:54,108
Configuring the should raise circular

869
00:31:54,108 --> 00:31:55,199
dependency flag

870
00:31:55,680 --> 00:31:57,920
here. The rest of the steps are gonna

871
00:31:57,920 --> 00:32:00,338
look similar to what we did

872
00:32:00,559 --> 00:32:02,199
uh with the previous test.

873
00:32:03,680 --> 00:32:05,759
So you can see here that our tests are now

874
00:32:05,759 --> 00:32:07,799
vastly simplified. So what this means

875
00:32:07,799 --> 00:32:09,799
as a developer in the future if our

876
00:32:09,799 --> 00:32:11,799
domain logic changes or you change the

877
00:32:11,799 --> 00:32:13,868
behavior of the task service, so this file is

878
00:32:13,868 --> 00:32:16,059
the only place where I need to make changes

879
00:32:16,358 --> 00:32:18,098
to get my unit test to work.

880
00:32:18,559 --> 00:32:20,880
So having said that, it doesn't mean that

881
00:32:20,880 --> 00:32:23,039
you should avoid mock at all costs. So for

882
00:32:23,039 --> 00:32:25,160
example, if we take our notification service

883
00:32:25,160 --> 00:32:27,019
that's processing things from the

884
00:32:27,598 --> 00:32:28,219
Event Bridge,

885
00:32:28,479 --> 00:32:30,838
let's say it is sending out an email when your task

886
00:32:30,838 --> 00:32:32,180
is due as a reminder.

887
00:32:32,699 --> 00:32:34,739
There, there's no need for me to fake

888
00:32:34,739 --> 00:32:37,170
an entire email server or an SES

889
00:32:37,170 --> 00:32:39,219
because that's a third party dependency. All

890
00:32:39,219 --> 00:32:41,380
I need to know for that test is that

891
00:32:41,380 --> 00:32:42,680
the send message method

892
00:32:43,059 --> 00:32:44,939
was actually invoked and I'm good.

893
00:32:45,459 --> 00:32:47,848
But for this particular case where we

894
00:32:47,848 --> 00:32:49,900
own the code for the domain logic and we want

895
00:32:49,900 --> 00:32:51,799
to highly customize the behavior

896
00:32:52,059 --> 00:32:54,660
in memory fake combined with dependency injection

897
00:32:54,660 --> 00:32:56,299
makes our code a lot cleaner.

898
00:32:56,729 --> 00:32:58,900
But then that leads to the question, what about our domain

899
00:32:58,900 --> 00:33:01,299
logic that actually validates that the circular

900
00:33:01,299 --> 00:33:02,650
dependency function works?

901
00:33:02,979 --> 00:33:05,140
So this becomes a whole lot simpler now

902
00:33:05,140 --> 00:33:07,259
because this is just a pure function that

903
00:33:07,259 --> 00:33:09,578
given a task and a dependency map, it

904
00:33:09,578 --> 00:33:11,739
is just going to check and return true

905
00:33:11,739 --> 00:33:13,900
if there is a circular dependency or false

906
00:33:13,900 --> 00:33:14,500
if not.

907
00:33:14,900 --> 00:33:17,279
So if we look at the test case for this, let's say.

908
00:33:18,108 --> 00:33:20,828
Uh, this is our current dependency, except

909
00:33:20,828 --> 00:33:21,390
I,

910
00:33:22,029 --> 00:33:24,108
task one depends on task 2, let's say,

911
00:33:24,229 --> 00:33:26,309
and task two has no dependency

912
00:33:26,309 --> 00:33:27,049
at the moment.

913
00:33:28,250 --> 00:33:30,489
I'm going to try to force a circular

914
00:33:30,489 --> 00:33:32,848
dependency by calling this has circular

915
00:33:32,848 --> 00:33:33,568
dependency,

916
00:33:34,009 --> 00:33:36,289
and I passed this mock dependency graph I've

917
00:33:36,289 --> 00:33:37,509
created, and all I need

918
00:33:37,890 --> 00:33:40,118
to know is that this is going to return true.

919
00:33:40,489 --> 00:33:42,828
The negative scenario is equally simple,

920
00:33:43,009 --> 00:33:45,088
um, so I now have an empty

921
00:33:45,088 --> 00:33:45,809
graph here.

922
00:33:46,680 --> 00:33:48,680
And at this time this should basically

923
00:33:48,680 --> 00:33:50,858
say that there is no circular dependency.

924
00:33:51,650 --> 00:33:52,390
So that's it,

925
00:33:52,729 --> 00:33:55,068
and these tests again, don't need to change.

926
00:33:55,828 --> 00:33:56,420
In the future,

927
00:33:56,719 --> 00:33:58,759
I mean, if you change the logic for how you

928
00:33:58,759 --> 00:34:00,789
calculate circular dependency, all you need to

929
00:34:00,789 --> 00:34:02,059
do is rerun the test.

930
00:34:02,439 --> 00:34:04,019
So the effort kind of goes down.

931
00:34:04,318 --> 00:34:06,549
And the third thing we called out was, um,

932
00:34:06,640 --> 00:34:08,760
what is the impact of this on

933
00:34:08,760 --> 00:34:10,699
the timing of the tests, so.

934
00:34:12,918 --> 00:34:14,967
Um, so both of these are in

935
00:34:14,967 --> 00:34:17,059
the unit folder, so we'll stick

936
00:34:17,059 --> 00:34:17,599
to this.

937
00:34:19,168 --> 00:34:21,389
So for, uh, so mock basically

938
00:34:21,389 --> 00:34:23,860
Moto 3 is a uh library

939
00:34:23,860 --> 00:34:25,929
that mocks all of the AWS services, so

940
00:34:25,929 --> 00:34:27,989
it has a slightly bigger overhead.

941
00:34:28,438 --> 00:34:30,530
But for our particular case, the in-memory

942
00:34:30,530 --> 00:34:33,010
fake, as you can see, is barely 120

943
00:34:33,010 --> 00:34:35,110
milliseconds, it's a lot more lightweight,

944
00:34:35,208 --> 00:34:37,478
and our tests are that much more cleaner.

945
00:34:38,050 --> 00:34:40,128
So we, we have now wrapped up our unit tests,

946
00:34:40,250 --> 00:34:42,289
but kind of this takes us to the next

947
00:34:42,289 --> 00:34:43,478
question. Um,

948
00:34:43,818 --> 00:34:45,838
when you're using agentic AI or spec driven

949
00:34:45,838 --> 00:34:48,137
development to build applications, uh, let's

950
00:34:48,137 --> 00:34:50,489
say you use the requirements, build the code,

951
00:34:50,938 --> 00:34:53,018
then you ask the agent to write the test

952
00:34:53,018 --> 00:34:54,398
for the generated code,

953
00:34:55,059 --> 00:34:57,378
um, and it might do a great job of comprehensive

954
00:34:57,378 --> 00:34:57,998
tests.

955
00:34:58,458 --> 00:35:00,858
But there is no way to validate that your

956
00:35:00,858 --> 00:35:02,898
requirements were correctly translated

957
00:35:02,898 --> 00:35:04,938
to the code in the first place. You know,

958
00:35:05,059 --> 00:35:07,378
your tests are validating the code that's generated.

959
00:35:07,938 --> 00:35:10,059
So how do you solve this problem, and Quiro

960
00:35:10,059 --> 00:35:12,389
recently introduced property-based tests

961
00:35:12,389 --> 00:35:13,070
to do that.

962
00:35:13,369 --> 00:35:15,530
So while Thomas explains that, I'm gonna run

963
00:35:15,530 --> 00:35:17,570
the test, but I'll explain what I'm doing after

964
00:35:17,570 --> 00:35:19,228
he's done to save time, yeah.

965
00:35:20,239 --> 00:35:22,289
Who has heard about the property-based testing

966
00:35:22,289 --> 00:35:23,389
in Quiro or in general?

967
00:35:24,789 --> 00:35:25,340
OK,

968
00:35:25,708 --> 00:35:27,909
uh, I'll use an analogy to kinda

969
00:35:27,909 --> 00:35:30,010
explain this. So think about a case where you're building

970
00:35:30,010 --> 00:35:32,519
your new tests. It's kind of like building a bridge,

971
00:35:33,070 --> 00:35:35,219
right? You build a bridge, you wanna test it, that

972
00:35:35,219 --> 00:35:37,269
it actually holds the, the load that it's supposed

973
00:35:37,269 --> 00:35:38,610
to be holding.

974
00:35:39,148 --> 00:35:39,668
Now,

975
00:35:40,188 --> 00:35:42,349
would you rather test it with your own

976
00:35:42,349 --> 00:35:43,148
car only,

977
00:35:43,628 --> 00:35:45,929
or would you rather test it with your car, my

978
00:35:45,929 --> 00:35:48,070
car, Arti's car, a truck, an

979
00:35:48,070 --> 00:35:48,648
ambulance?

980
00:35:49,539 --> 00:35:50,199
An elephant,

981
00:35:50,659 --> 00:35:52,840
right? So that's the difference between

982
00:35:52,840 --> 00:35:54,898
the traditional way of creating

983
00:35:54,898 --> 00:35:57,019
tests and the property-based testing.

984
00:35:57,378 --> 00:35:59,760
With property-based testing, you essentially define properties.

985
00:36:00,659 --> 00:36:02,199
And then the system

986
00:36:02,530 --> 00:36:04,039
runs not just one test.

987
00:36:04,809 --> 00:36:06,030
It can execute

988
00:36:06,478 --> 00:36:07,590
100 tests

989
00:36:08,010 --> 00:36:10,090
during the same execution, and Arthur is going to show

990
00:36:10,090 --> 00:36:11,478
you how that actually looks like,

991
00:36:11,809 --> 00:36:13,869
uh, using some menu modules,

992
00:36:14,128 --> 00:36:16,369
but it's, it simplifies the

993
00:36:16,369 --> 00:36:18,829
process because it makes it simple to define

994
00:36:18,829 --> 00:36:20,489
but also faster to execute.

995
00:36:21,688 --> 00:36:22,590
Yep, so,

996
00:36:23,208 --> 00:36:25,208
like, like Thomas said, it's great to kind

997
00:36:25,208 --> 00:36:27,289
of also detect edge cases in your

998
00:36:27,289 --> 00:36:29,289
business logic. So the idea here is

999
00:36:29,289 --> 00:36:31,289
we'll just see, I've, I've run this test and

1000
00:36:31,289 --> 00:36:33,250
I'll, uh, explain this in a minute.

1001
00:36:33,648 --> 00:36:35,849
I'll start with the scenario I'm trying to

1002
00:36:35,849 --> 00:36:38,208
explain. So if you think about a circular

1003
00:36:38,208 --> 00:36:40,369
dependency check, that's a good example where

1004
00:36:40,369 --> 00:36:42,478
property-based tests actually works well

1005
00:36:42,849 --> 00:36:45,280
because we just want to verify the algorithmic

1006
00:36:45,280 --> 00:36:47,289
correctness of that code and whether

1007
00:36:47,289 --> 00:36:49,719
it does what it is supposed to do. That's

1008
00:36:49,719 --> 00:36:50,250
really it.

1009
00:36:50,800 --> 00:36:53,019
So to do that, we are going

1010
00:36:53,019 --> 00:36:54,978
to kind of take a slightly

1011
00:36:56,340 --> 00:36:58,219
Um, all right, I.

1012
00:36:59,289 --> 00:37:01,289
Where is the code? I think I

1013
00:37:01,289 --> 00:37:03,369
might have the wrong file open. Hang on, just give me

1014
00:37:03,369 --> 00:37:03,889
a second.

1015
00:37:08,909 --> 00:37:10,909
OK, it's just doubled. Why

1016
00:37:10,909 --> 00:37:13,228
does it split it like that? Yeah, I think

1017
00:37:13,228 --> 00:37:14,228
I did that before.

1018
00:37:14,750 --> 00:37:16,750
All right, that's strange, so, OK, bear

1019
00:37:16,750 --> 00:37:19,688
with me. Yes,

1020
00:37:19,789 --> 00:37:21,889
so actually this is the first time Thomas and I are running

1021
00:37:21,889 --> 00:37:24,090
this together, so I'm not used to his laptop, so

1022
00:37:24,090 --> 00:37:26,398
please bear with me. So, all right, so

1023
00:37:26,398 --> 00:37:28,570
in this case, let's say this is the scenario we

1024
00:37:28,570 --> 00:37:30,889
want to test, OK, for algorithmic

1025
00:37:30,889 --> 00:37:31,510
correctness.

1026
00:37:32,208 --> 00:37:34,289
So, when you saw the unit test we

1027
00:37:34,289 --> 00:37:36,728
wrote for the domain logic, we created these simple

1028
00:37:36,728 --> 00:37:38,929
dependency graphs and we tested it, you know, like

1029
00:37:38,929 --> 00:37:40,688
we said, task one depends on task 2,

1030
00:37:41,050 --> 00:37:43,119
get task 2 to depend on task one, and it,

1031
00:37:43,128 --> 00:37:43,929
it should detect.

1032
00:37:44,398 --> 00:37:46,438
But let's say that there are complex kind of

1033
00:37:46,438 --> 00:37:48,639
dependencies that exist in our database

1034
00:37:48,639 --> 00:37:50,719
where, uh, you know, each of these nodes represents

1035
00:37:50,719 --> 00:37:51,909
a task essentially.

1036
00:37:52,360 --> 00:37:54,679
So let's say this task depends on 1, this

1037
00:37:54,679 --> 00:37:56,099
depends on 2, and so on.

1038
00:37:56,639 --> 00:37:58,878
Now, if I try to force this dependency

1039
00:37:58,878 --> 00:38:01,000
of this main 2 back to main zero,

1040
00:38:02,199 --> 00:38:04,199
now if there was a bug in the logic and let's say it

1041
00:38:04,199 --> 00:38:06,659
only travels the right side of this branch,

1042
00:38:07,398 --> 00:38:09,398
it might incorrectly conclude that, you know

1043
00:38:09,398 --> 00:38:11,398
what, this doesn't set up a circular dependency,

1044
00:38:11,438 --> 00:38:12,780
let's allow this to go through.

1045
00:38:13,329 --> 00:38:15,369
But if my logic is written correctly,

1046
00:38:15,378 --> 00:38:17,378
then it should test all branches

1047
00:38:17,378 --> 00:38:18,958
that it encounters on the way.

1048
00:38:19,300 --> 00:38:21,340
So this is a good use case where property-based

1049
00:38:21,340 --> 00:38:22,519
tests might help us.

1050
00:38:22,978 --> 00:38:25,360
So I've basically actually run the test.

1051
00:38:26,340 --> 00:38:27,478
So, a few quick

1052
00:38:28,019 --> 00:38:28,780
things to note.

1053
00:38:29,260 --> 00:38:31,619
So Python has a library called Hypothesis

1054
00:38:31,619 --> 00:38:34,010
that allows you to do property-based tests.

1055
00:38:34,378 --> 00:38:36,458
So obviously with property-based tests, instead of fixed

1056
00:38:36,458 --> 00:38:38,590
inputs, we are generating a large

1057
00:38:38,590 --> 00:38:40,860
number of inputs from a given problem

1058
00:38:40,860 --> 00:38:42,079
or input space.

1059
00:38:42,500 --> 00:38:44,519
However, the data is not completely random.

1060
00:38:44,659 --> 00:38:47,070
So in our case, task IDs are UU IDs,

1061
00:38:47,179 --> 00:38:49,179
so that's why I've used the strategies

1062
00:38:49,179 --> 00:38:51,349
here. In this case, to specify

1063
00:38:51,349 --> 00:38:53,378
that I want to create a bunch of UU IDs

1064
00:38:53,378 --> 00:38:55,469
for my testing because that's what I'm using for my

1065
00:38:55,469 --> 00:38:56,050
task.

1066
00:38:56,510 --> 00:38:58,849
Next, let's just focus on this branching test.

1067
00:38:59,469 --> 00:39:00,010
Um,

1068
00:39:00,590 --> 00:39:02,679
you see the given decorator here defines

1069
00:39:02,679 --> 00:39:04,708
the input space to be used to generate

1070
00:39:04,708 --> 00:39:05,429
the test.

1071
00:39:06,030 --> 00:39:08,188
So I'm just gonna refer to them as main chain

1072
00:39:08,188 --> 00:39:10,289
and branch chain as I showed you in the diagram.

1073
00:39:10,728 --> 00:39:12,889
I'm just generating a list of task

1074
00:39:12,889 --> 00:39:15,449
IDs. I've specified a few constraints

1075
00:39:15,449 --> 00:39:16,478
as to how many,

1076
00:39:16,809 --> 00:39:19,050
and the ID should be unique, because, of course, each

1077
00:39:19,050 --> 00:39:21,250
task is unique within our database.

1078
00:39:21,570 --> 00:39:23,809
Similarly for the branch chain, and then I'm also

1079
00:39:23,809 --> 00:39:25,969
specifying that we randomly choose a

1080
00:39:25,969 --> 00:39:27,969
point on the main chain where we want to create the

1081
00:39:27,969 --> 00:39:28,590
branch.

1082
00:39:29,090 --> 00:39:30,628
Now if you look at the test case.

1083
00:39:31,360 --> 00:39:33,639
We also define a few additional constraints.

1084
00:39:33,719 --> 00:39:35,878
For example, we don't want any overlap

1085
00:39:35,878 --> 00:39:36,780
between the two lists,

1086
00:39:37,119 --> 00:39:39,179
because we are using UU IDs there's a good chance,

1087
00:39:39,320 --> 00:39:41,039
we won't actually breach this constraint.

1088
00:39:42,159 --> 00:39:44,188
And the test itself is pretty simple. Basically

1089
00:39:44,188 --> 00:39:46,418
I'm looping over the list of task

1090
00:39:46,418 --> 00:39:48,429
IDs generated for the main chain and I'm

1091
00:39:48,429 --> 00:39:50,429
building this left side of the branch

1092
00:39:50,429 --> 00:39:52,668
first, and then I do the same

1093
00:39:52,668 --> 00:39:54,849
for the second set of the list and building this

1094
00:39:54,849 --> 00:39:56,489
right side of the branch first.

1095
00:39:56,909 --> 00:39:58,909
Then I actually pick the point where I want to

1096
00:39:58,909 --> 00:40:00,949
define the branch, so if there are any

1097
00:40:00,949 --> 00:40:03,079
existing dependencies there, I want to preserve the

1098
00:40:03,079 --> 00:40:05,320
dependency, and that, that's really it. I've built

1099
00:40:05,320 --> 00:40:05,969
at this point,

1100
00:40:06,510 --> 00:40:08,869
the dependency map, uh, in the database,

1101
00:40:09,309 --> 00:40:10,489
and that's it. I just.

1102
00:40:10,898 --> 00:40:12,898
You know, loop back the last node back to

1103
00:40:12,898 --> 00:40:14,978
the first node, and then I expect that it'll

1104
00:40:14,978 --> 00:40:17,179
detect the dependency every time. So the way

1105
00:40:17,179 --> 00:40:19,050
we have written the test has changed.

1106
00:40:19,659 --> 00:40:21,679
Second, I ran this test already

1107
00:40:21,679 --> 00:40:23,679
and. You can see

1108
00:40:23,679 --> 00:40:25,840
that for each of the tests there is about

1109
00:40:25,840 --> 00:40:27,840
0.34, 0.32. There is a

1110
00:40:27,840 --> 00:40:30,188
little bit of an overhead in running the test, although

1111
00:40:30,188 --> 00:40:31,590
these are still unit tests.

1112
00:40:32,079 --> 00:40:34,260
So what exactly is happening behind the scene?

1113
00:40:34,639 --> 00:40:36,719
So to understand that I've installed this

1114
00:40:36,719 --> 00:40:38,719
open source plug-in called

1115
00:40:38,719 --> 00:40:40,800
Tikiy. Sorry, I'm just gonna

1116
00:40:40,800 --> 00:40:42,978
have to run this again because.

1117
00:40:46,699 --> 00:40:48,478
All right, got it this time around.

1118
00:40:50,369 --> 00:40:52,590
So this, this plug-in makes it easy

1119
00:40:52,590 --> 00:40:54,648
to visualize what's happening under

1120
00:40:54,648 --> 00:40:56,659
the hoods with property-based tests,

1121
00:40:56,668 --> 00:40:58,728
specifically. So what this is showing us

1122
00:40:58,728 --> 00:41:01,090
is, I, I specifically chose just the

1123
00:41:01,090 --> 00:41:01,969
test that we did.

1124
00:41:02,688 --> 00:41:04,820
Uh, the important thing to note is it did not

1125
00:41:04,820 --> 00:41:06,889
run a single test for this function. It

1126
00:41:06,889 --> 00:41:09,059
ran 100 test cases, each

1127
00:41:09,059 --> 00:41:10,929
with a unique combination of inputs.

1128
00:41:11,219 --> 00:41:13,378
But you'll also see here that the generated number

1129
00:41:13,378 --> 00:41:15,039
of samples is 104.

1130
00:41:15,378 --> 00:41:17,458
That's because it created 104 sets

1131
00:41:17,458 --> 00:41:19,579
of inputs, but 4 of them were discarded

1132
00:41:19,579 --> 00:41:21,739
because it did not meet some of our constraints, and,

1133
00:41:21,849 --> 00:41:22,719
and that's OK.

1134
00:41:23,219 --> 00:41:25,219
Our test itself, actually each test

1135
00:41:25,219 --> 00:41:27,219
runs pretty fast, but it's just

1136
00:41:27,219 --> 00:41:29,219
that it's running 100 of them, so that's

1137
00:41:29,219 --> 00:41:30,500
what it's adding to the overhead.

1138
00:41:31,090 --> 00:41:33,239
Now this visualization in, in our case, the

1139
00:41:33,239 --> 00:41:35,449
good news is we wrote the logic correctly

1140
00:41:35,449 --> 00:41:37,610
and you can see all 100 of them passed and that's

1141
00:41:37,610 --> 00:41:40,090
good. But when you have failures

1142
00:41:40,090 --> 00:41:42,269
as a developer, it's good to look at what

1143
00:41:42,269 --> 00:41:44,289
was the input for which the thing failed,

1144
00:41:44,449 --> 00:41:45,800
so it's easy to troubleshoot,

1145
00:41:46,128 --> 00:41:48,250
and that's where this helps again because if you click

1146
00:41:48,250 --> 00:41:50,329
into this you can actually see every

1147
00:41:50,329 --> 00:41:52,648
single input. In this case, of course, everything was

1148
00:41:52,648 --> 00:41:53,188
successful,

1149
00:41:53,489 --> 00:41:55,570
but you can see what was the main chain, what is

1150
00:41:55,570 --> 00:41:57,489
the branch chain, what is the branch point.

1151
00:41:58,079 --> 00:42:00,059
It even tells you the actual code coverage,

1152
00:42:00,599 --> 00:42:02,599
what were the lines that were tested by this,

1153
00:42:02,619 --> 00:42:04,958
and it makes it easy for you to troubleshoot

1154
00:42:04,958 --> 00:42:07,039
things. So that kind of wrap wraps

1155
00:42:07,039 --> 00:42:09,239
this up. So kind of where this is useful is

1156
00:42:09,239 --> 00:42:11,559
anywhere algorithmic correctness or, you know, pure

1157
00:42:11,559 --> 00:42:12,820
functions, business logic,

1158
00:42:13,199 --> 00:42:15,429
really good, especially to catch edge cases.

1159
00:42:15,840 --> 00:42:18,000
But the moment you're thinking about say end to end

1160
00:42:18,000 --> 00:42:20,000
tests or so on, they're not so good because

1161
00:42:20,000 --> 00:42:22,039
for end to end tests you need specific inputs

1162
00:42:22,039 --> 00:42:22,599
that will

1163
00:42:22,878 --> 00:42:25,099
actually trigger your end to end workflow and

1164
00:42:25,099 --> 00:42:27,398
random data might not really help you there.

1165
00:42:27,958 --> 00:42:30,070
But that's a good way or even if you don't

1166
00:42:30,070 --> 00:42:32,148
run it as part of every CI, it's a good way

1167
00:42:32,148 --> 00:42:34,389
to validate correctness of core

1168
00:42:34,389 --> 00:42:36,510
kind of business critical business logic and whether

1169
00:42:36,510 --> 00:42:38,369
that works as expected.

1170
00:42:38,989 --> 00:42:40,989
All right, so that wraps up this one.

1171
00:42:41,050 --> 00:42:43,110
So we're actually good to move

1172
00:42:43,110 --> 00:42:45,349
on to the integration

1173
00:42:45,349 --> 00:42:47,610
test. So we've finished our unit test.

1174
00:42:49,199 --> 00:42:51,840
So for the integration test, the first one I wanna

1175
00:42:51,840 --> 00:42:53,989
uh discuss is just uh validating

1176
00:42:53,989 --> 00:42:56,090
the schema for asynchronous integration,

1177
00:42:56,148 --> 00:42:57,708
which is our event bridge part.

1178
00:42:58,228 --> 00:43:00,309
Uh, so what exactly does schema test do?

1179
00:43:00,378 --> 00:43:02,590
So the goal here is as a publisher of an

1180
00:43:02,590 --> 00:43:03,168
event,

1181
00:43:03,938 --> 00:43:06,228
if I modify my event such that

1182
00:43:06,228 --> 00:43:08,469
I maybe remove fields that my subscribers

1183
00:43:08,469 --> 00:43:10,750
depend on, I'm gonna break the logic of my downstream

1184
00:43:10,750 --> 00:43:11,418
subscribers.

1185
00:43:11,750 --> 00:43:13,829
So that's really what the schema test is for. So

1186
00:43:13,829 --> 00:43:16,148
if you have any breaking changes in your event schema,

1187
00:43:16,228 --> 00:43:17,530
it's going to pick this up.

1188
00:43:17,909 --> 00:43:19,909
Now our task API is super simple and I

1189
00:43:19,909 --> 00:43:22,110
think it's fair to assume that it's the same team

1190
00:43:22,110 --> 00:43:24,228
that owns both the code bases and maybe you can

1191
00:43:24,228 --> 00:43:25,378
coordinate the changes.

1192
00:43:25,750 --> 00:43:27,869
But the moment you have like a central event bus,

1193
00:43:28,000 --> 00:43:30,228
multiple publishers, multiple subscribers,

1194
00:43:30,269 --> 00:43:32,679
where publishers often don't even know who the subscribers

1195
00:43:32,679 --> 00:43:34,898
are, it becomes more and more important

1196
00:43:34,898 --> 00:43:37,110
to validate uh the contract of the test.

1197
00:43:37,668 --> 00:43:39,929
So again, there are a few different ways to write this.

1198
00:43:40,849 --> 00:43:42,898
It depends on how you're defining your event schema.

1199
00:43:42,978 --> 00:43:45,219
For example, Async API is one way to define

1200
00:43:45,219 --> 00:43:46,699
your schema or Open API,

1201
00:43:47,128 --> 00:43:49,260
then you can use tools specific to those.

1202
00:43:49,539 --> 00:43:51,860
But because we are in Python, we're gonna do it the Pythonic

1203
00:43:51,860 --> 00:43:53,938
way, and we're using Pedantic, which is just

1204
00:43:53,938 --> 00:43:55,438
a data validation library.

1205
00:43:55,860 --> 00:43:58,340
So defining a schema is as simple as inheriting

1206
00:43:58,340 --> 00:43:59,449
from the base model,

1207
00:43:59,780 --> 00:44:01,938
and I've basically defined what a task,

1208
00:44:02,099 --> 00:44:04,280
create event or update event will look like.

1209
00:44:04,840 --> 00:44:06,889
If the task is deleted, of course the schema will

1210
00:44:06,889 --> 00:44:07,869
just have the ID.

1211
00:44:08,168 --> 00:44:10,320
There's another important thing we are checking because we're

1212
00:44:10,320 --> 00:44:12,530
using EventBridge, and EventBridge expects

1213
00:44:12,530 --> 00:44:14,809
a few mandatory fields, otherwise you can't

1214
00:44:14,809 --> 00:44:17,010
publish to it. So we are also validating the

1215
00:44:17,010 --> 00:44:18,668
compliance to EventBridge schema.

1216
00:44:19,409 --> 00:44:21,449
Now actually running the test is easy. I've, I've

1217
00:44:21,449 --> 00:44:23,449
got a helper function here, so validating a

1218
00:44:23,449 --> 00:44:25,610
schema is as simple as just calling

1219
00:44:25,610 --> 00:44:26,849
the model validate

1220
00:44:27,168 --> 00:44:29,148
on the class with the event, and that's it.

1221
00:44:29,570 --> 00:44:31,688
So my actual test cases are generating

1222
00:44:31,688 --> 00:44:33,889
the create event, delete event, and so on, and

1223
00:44:33,889 --> 00:44:36,050
just calling this helper method, and, and we're

1224
00:44:36,050 --> 00:44:36,668
good to go.

1225
00:44:37,050 --> 00:44:39,128
There are a few advanced other ways to test this,

1226
00:44:39,208 --> 00:44:41,208
for example, consumer-driven contract tests

1227
00:44:41,208 --> 00:44:43,208
and so on. So but if you're interested, just find

1228
00:44:43,208 --> 00:44:45,369
us after this, after this talk, and we can

1229
00:44:45,369 --> 00:44:45,969
talk about it.

1230
00:44:47,228 --> 00:44:49,739
Now, let's come to just integration with actual

1231
00:44:49,739 --> 00:44:51,750
AWS services, um, which

1232
00:44:51,750 --> 00:44:53,789
is Dynamo Devi and EventBridge. So our

1233
00:44:53,789 --> 00:44:55,869
recommendation here is for AWS

1234
00:44:55,869 --> 00:44:56,389
services,

1235
00:44:57,110 --> 00:44:59,139
test against the actual services.

1236
00:44:59,628 --> 00:45:01,628
Uh, that way you also get to validate

1237
00:45:01,628 --> 00:45:03,628
the other integration properties such as, you know,

1238
00:45:03,699 --> 00:45:05,978
whether permissions are set up correctly or

1239
00:45:05,978 --> 00:45:07,728
networking is set up correctly, and so on.

1240
00:45:08,340 --> 00:45:10,610
Uh, the other thing to think about also is with mocking

1241
00:45:10,610 --> 00:45:12,780
libraries is whether the libraries fully

1242
00:45:12,780 --> 00:45:15,208
support those services. So as an example, Moto

1243
00:45:15,208 --> 00:45:17,559
that we, you know, used, uh, in the initial

1244
00:45:17,559 --> 00:45:19,820
version does not support global tables

1245
00:45:19,820 --> 00:45:21,320
for Dynamo DB out of the box.

1246
00:45:21,938 --> 00:45:23,949
Then you will have to manage that replication

1247
00:45:23,949 --> 00:45:24,708
within your code.

1248
00:45:24,978 --> 00:45:27,059
So that's another thing to think about if you are

1249
00:45:27,059 --> 00:45:28,250
relying on MOOCs.

1250
00:45:28,739 --> 00:45:30,938
Um, so let's quickly take a look at Dynamo DB.

1251
00:45:31,010 --> 00:45:33,059
Like we said, we are going to test this against the

1252
00:45:33,059 --> 00:45:34,478
real, uh, database.

1253
00:45:35,070 --> 00:45:37,070
So our test fixture is straightforward. So if you

1254
00:45:37,070 --> 00:45:39,030
remember the integration code that

1255
00:45:39,469 --> 00:45:41,559
uh Thomas walked you through, you initialize the task

1256
00:45:41,559 --> 00:45:43,559
repository with the actual table name.

1257
00:45:43,949 --> 00:45:45,750
We are going to modify the

1258
00:45:46,320 --> 00:45:48,550
UU ID because we don't want to leave the test data

1259
00:45:48,550 --> 00:45:50,559
around so that we can delete this. So

1260
00:45:50,559 --> 00:45:52,619
we are gonna fix what is the ID

1261
00:45:52,619 --> 00:45:53,418
of the task.

1262
00:45:53,989 --> 00:45:56,349
Uh, there's the cleanup that basically deletes the task.

1263
00:45:56,510 --> 00:45:58,550
Now there are two types of tests here. One is

1264
00:45:58,550 --> 00:46:00,329
the happy path scenario, you create,

1265
00:46:00,668 --> 00:46:02,809
you know, and you make sure that the tasks are persistent.

1266
00:46:03,309 --> 00:46:04,708
I create the task object.

1267
00:46:05,489 --> 00:46:06,760
I kind of use my

1268
00:46:07,280 --> 00:46:08,648
P test fixture task ID for it.

1269
00:46:08,938 --> 00:46:11,099
I simply call save task, if you remember the

1270
00:46:11,099 --> 00:46:13,260
protocol that he mentioned, save task allows

1271
00:46:13,260 --> 00:46:15,260
you to persist the task to the database,

1272
00:46:15,610 --> 00:46:17,820
and that's it. Then we retrieve the task from the database

1273
00:46:17,820 --> 00:46:18,719
and we're good to go.

1274
00:46:19,139 --> 00:46:21,418
So again, remember in the future, if you swap Dynamo

1275
00:46:21,418 --> 00:46:23,539
DV with something else, this test case actually does

1276
00:46:23,539 --> 00:46:24,688
not change at all.

1277
00:46:25,139 --> 00:46:27,260
You simply rewrite your integration code and run

1278
00:46:27,260 --> 00:46:28,800
this as is, and, and it should

1279
00:46:29,219 --> 00:46:31,349
work. Oh well, you

1280
00:46:31,349 --> 00:46:33,398
will have to rewrite the code to retrieve the

1281
00:46:33,398 --> 00:46:35,280
data based on the database you're using,

1282
00:46:35,708 --> 00:46:38,099
but a large part of the test remains unchanged.

1283
00:46:38,478 --> 00:46:40,519
Now, the more interesting part of this test is

1284
00:46:40,519 --> 00:46:42,679
actually the failure scenarios.

1285
00:46:43,909 --> 00:46:46,199
So the first thing to call out here is, again, we are simulating

1286
00:46:46,199 --> 00:46:47,780
errors with services. Once again,

1287
00:46:48,159 --> 00:46:50,159
in memory fake comes to our rescue, so we

1288
00:46:50,159 --> 00:46:52,378
have a fake class. I won't go through it, it's similar

1289
00:46:52,378 --> 00:46:53,929
to what we did with the unit test.

1290
00:46:54,398 --> 00:46:56,469
But the question here is, what exactly is it we

1291
00:46:56,469 --> 00:46:58,148
should be validating with failures?

1292
00:46:58,519 --> 00:47:00,639
So there are two things we should be uh checking

1293
00:47:00,639 --> 00:47:01,949
for. First is,

1294
00:47:02,239 --> 00:47:04,320
are we surfacing the correct error

1295
00:47:04,320 --> 00:47:06,360
code or exception code and message so

1296
00:47:06,360 --> 00:47:08,550
that the client knows what to do with it,

1297
00:47:08,840 --> 00:47:10,958
or are we just collapsing everything into a 500

1298
00:47:10,958 --> 00:47:12,539
and then troubleshooting becomes hard?

1299
00:47:12,978 --> 00:47:15,340
The second thing to test is does your

1300
00:47:15,340 --> 00:47:17,378
application behave as expected when these

1301
00:47:17,378 --> 00:47:18,938
error scenarios occur.

1302
00:47:19,378 --> 00:47:21,938
So to make it concrete, let's again go back to our

1303
00:47:21,938 --> 00:47:23,938
application, like, uh, let's say for our task app,

1304
00:47:23,978 --> 00:47:24,679
we have an

1305
00:47:25,059 --> 00:47:27,139
offline mode, so people can

1306
00:47:27,139 --> 00:47:28,579
work on tasks offline.

1307
00:47:28,978 --> 00:47:31,059
And probably when they come online, it's possible that

1308
00:47:31,059 --> 00:47:33,000
you might end up with conflicts in tasks.

1309
00:47:33,659 --> 00:47:35,849
So how are you going to resolve the conflict? So we have used

1310
00:47:35,849 --> 00:47:38,010
a simple strategy of first right wins.

1311
00:47:38,449 --> 00:47:40,519
So we have a version which is the Unix timestamp

1312
00:47:40,519 --> 00:47:42,610
of a record, so when a client reads it and

1313
00:47:42,610 --> 00:47:44,889
then they write back, if the timestamp is changed,

1314
00:47:45,208 --> 00:47:46,878
you know, the right will be rejected.

1315
00:47:47,289 --> 00:47:49,349
But the error message should convey enough,

1316
00:47:49,648 --> 00:47:51,269
so the client knows what to do with it.

1317
00:47:52,449 --> 00:47:54,510
So the way we're going to do this is um

1318
00:47:55,179 --> 00:47:57,418
In this case, we should return a 409 conflict

1319
00:47:57,418 --> 00:47:59,918
error. Um, so what we will do is,

1320
00:48:00,478 --> 00:48:02,719
now this is going to start to look similar

1321
00:48:02,719 --> 00:48:03,840
to the unit test.

1322
00:48:04,978 --> 00:48:07,030
So the question is, first, is this an integration

1323
00:48:07,030 --> 00:48:09,500
test because we're, we're just using uh MCs.

1324
00:48:09,820 --> 00:48:11,820
The second question is, are we repeating what we did with

1325
00:48:11,820 --> 00:48:12,760
the handler test?

1326
00:48:13,500 --> 00:48:15,628
So for the first question, in this case, we are

1327
00:48:15,628 --> 00:48:17,789
evaluating a failure with

1328
00:48:17,789 --> 00:48:19,869
the integration layer for Dynamo DB so it

1329
00:48:19,869 --> 00:48:21,989
logically kind of sits as part

1330
00:48:21,989 --> 00:48:24,090
of the Dynamo DB test validation.

1331
00:48:24,188 --> 00:48:26,628
So we have left it in here with the integration

1332
00:48:26,628 --> 00:48:28,708
test. The second thing is it's not

1333
00:48:28,708 --> 00:48:30,789
an exact repetition of

1334
00:48:30,789 --> 00:48:32,300
the handler test, um,

1335
00:48:32,668 --> 00:48:35,070
because if you remember in the handler, we mocked out the

1336
00:48:35,070 --> 00:48:37,389
entire task service logic layer, we injected

1337
00:48:37,389 --> 00:48:39,429
our fake there. So that part of the

1338
00:48:39,429 --> 00:48:40,668
code was never tested.

1339
00:48:41,000 --> 00:48:43,250
But if you look at the fake that we have created

1340
00:48:43,250 --> 00:48:46,869
here, So

1341
00:48:46,869 --> 00:48:48,909
the first thing we are doing is we are creating the task

1342
00:48:48,909 --> 00:48:50,938
repository, but we are using a fake. So

1343
00:48:50,938 --> 00:48:51,648
once again,

1344
00:48:52,030 --> 00:48:54,128
dependency injection, we injected the fake

1345
00:48:54,128 --> 00:48:55,889
database into task repository.

1346
00:48:56,510 --> 00:48:58,590
We are using a mock for the publisher. So

1347
00:48:58,590 --> 00:49:00,590
here again, mock is handy for us

1348
00:49:00,590 --> 00:49:02,590
because when I'm testing database failures,

1349
00:49:02,668 --> 00:49:04,869
I don't want to publish any events to EventBridge,

1350
00:49:04,949 --> 00:49:05,570
that's all.

1351
00:49:06,128 --> 00:49:08,559
I don't need to actually configure

1352
00:49:08,559 --> 00:49:10,648
the behavior of EventBridge, so here mock is

1353
00:49:10,648 --> 00:49:12,610
super handy for me just to prevent

1354
00:49:12,929 --> 00:49:14,909
events from being published to EventBridge.

1355
00:49:15,250 --> 00:49:17,639
And then I actually instantiate the task

1356
00:49:17,639 --> 00:49:19,789
service with the fake repo and fake publisher,

1357
00:49:19,889 --> 00:49:21,949
so we are testing all of the code

1358
00:49:22,250 --> 00:49:24,289
that has been written in the task service, so it's not a

1359
00:49:24,289 --> 00:49:25,188
repetition.

1360
00:49:26,079 --> 00:49:28,079
You could choose directly to validate the

1361
00:49:28,079 --> 00:49:30,110
task service and not call the handler.

1362
00:49:30,398 --> 00:49:32,840
The reason we chose the handler is that we are also

1363
00:49:32,840 --> 00:49:34,478
mapping some of the error codes.

1364
00:49:34,760 --> 00:49:36,800
That is, for example, when you have an IAM

1365
00:49:36,800 --> 00:49:38,340
error, which is a permission error,

1366
00:49:38,679 --> 00:49:40,840
and Lambda doesn't have permission to write to Dynamo DB,

1367
00:49:40,918 --> 00:49:43,070
this permission error has no meaning to your end

1368
00:49:43,070 --> 00:49:45,559
client. So here we actually

1369
00:49:45,559 --> 00:49:47,918
check that your error message does not

1370
00:49:47,918 --> 00:49:48,938
have, um,

1371
00:49:49,579 --> 00:49:51,219
oh, I'm looking at the wrong test case.

1372
00:49:54,289 --> 00:49:56,409
Right, that's the test case, sorry. So here we

1373
00:49:56,409 --> 00:49:58,469
actually check that your error message does

1374
00:49:58,469 --> 00:50:00,530
not have permission or access in the message

1375
00:50:00,530 --> 00:50:02,570
and you're basically surfacing IAM errors

1376
00:50:02,570 --> 00:50:03,728
as internal error.

1377
00:50:04,010 --> 00:50:05,909
So that's why we chose to test the handler.

1378
00:50:06,369 --> 00:50:07,429
And then the last one.

1379
00:50:08,550 --> 00:50:09,840
Uh, for EventBridge,

1380
00:50:10,389 --> 00:50:12,478
the main difference with the EventBridge test is unlike

1381
00:50:12,478 --> 00:50:15,000
Dynamo DB, you can't really query EventBridge

1382
00:50:15,000 --> 00:50:16,659
because you publish an event and it's gone,

1383
00:50:16,958 --> 00:50:18,429
unless there is a subscriber.

1384
00:50:19,000 --> 00:50:21,360
So testing EventBridge requires a little bit of extra

1385
00:50:21,360 --> 00:50:23,780
work where we are setting up a test harness,

1386
00:50:24,438 --> 00:50:26,559
which is just another lambda function that's

1387
00:50:26,559 --> 00:50:27,820
listening to test events.

1388
00:50:28,159 --> 00:50:30,280
It adds a bunch of metadata and persists

1389
00:50:30,280 --> 00:50:32,280
it to another Dynamo DB and then we just

1390
00:50:32,280 --> 00:50:33,559
read back from the Dynamo DB.

1391
00:50:34,159 --> 00:50:36,199
So if we look at the Happy Path case for

1392
00:50:36,199 --> 00:50:38,260
this, we initialize the publisher

1393
00:50:38,260 --> 00:50:39,530
with the real event buzz,

1394
00:50:39,878 --> 00:50:42,280
we create the event and we just call published task

1395
00:50:42,280 --> 00:50:43,179
event. Because

1396
00:50:43,800 --> 00:50:46,059
there is extra work in kind of lambda receiving

1397
00:50:46,059 --> 00:50:48,449
the event, processing and persisting it, we do

1398
00:50:48,449 --> 00:50:49,648
introduce a wait time here.

1399
00:50:50,449 --> 00:50:52,530
Uh, to allow for that, and then we basically query

1400
00:50:52,530 --> 00:50:54,530
the target database and we are, we are

1401
00:50:54,530 --> 00:50:56,780
done. So I'm

1402
00:50:56,929 --> 00:50:59,708
going to just run these tests, which actually

1403
00:50:59,708 --> 00:51:01,708
take a little bit time to run,

1404
00:51:02,110 --> 00:51:02,889
uh, but

1405
00:51:03,469 --> 00:51:05,449
we'll have this running and I'll pass it off

1406
00:51:05,809 --> 00:51:06,329
to

1407
00:51:06,628 --> 00:51:07,329
Thomas

1408
00:51:07,789 --> 00:51:09,349
to finish the last part.

1409
00:51:10,958 --> 00:51:11,909
Um,

1410
00:51:12,539 --> 00:51:14,269
so, OK, while that runs,

1411
00:51:14,809 --> 00:51:16,139
very quickly summarizing,

1412
00:51:16,878 --> 00:51:19,039
what we did for the test was MCs

1413
00:51:19,039 --> 00:51:21,079
are useful, but use them sparingly, and

1414
00:51:21,079 --> 00:51:23,280
we saw at least 2 or 3 places where we did use

1415
00:51:23,280 --> 00:51:23,820
the mock.

1416
00:51:25,030 --> 00:51:27,148
However, when you want to customize the behavior of

1417
00:51:27,148 --> 00:51:29,429
your domain logic, uh, in memory fakes

1418
00:51:29,429 --> 00:51:30,050
work better.

1419
00:51:30,829 --> 00:51:32,829
Dependency injection makes the code cleaner,

1420
00:51:32,909 --> 00:51:34,949
but remember at runtime we have provided

1421
00:51:34,949 --> 00:51:37,030
defaults, so the code at runtime does

1422
00:51:37,030 --> 00:51:39,309
not require dependency injection, so we're not

1423
00:51:39,628 --> 00:51:40,360
talking about,

1424
00:51:40,708 --> 00:51:42,769
you know, full dependency injection frameworks.

1425
00:51:43,030 --> 00:51:45,369
It's a good idea to validate your event schema.

1426
00:51:45,989 --> 00:51:48,369
Integration tests, run them against real services,

1427
00:51:48,500 --> 00:51:50,148
use fakes to simulate error.

1428
00:51:50,579 --> 00:51:53,000
And very important to validate the handling

1429
00:51:53,000 --> 00:51:55,349
of integration failures, like are you surfacing

1430
00:51:55,349 --> 00:51:57,579
the correct exception codes, messages, so

1431
00:51:57,579 --> 00:51:59,320
your client knows what to do with it.

1432
00:51:59,739 --> 00:52:01,860
And that actually wraps up our test section. We

1433
00:52:01,860 --> 00:52:02,500
have the last,

1434
00:52:02,918 --> 00:52:05,000
last part of, oh, the tests have.

1435
00:52:06,628 --> 00:52:08,628
OK, the tests have run, not surprisingly,

1436
00:52:08,668 --> 00:52:10,668
it's almost 17 seconds

1437
00:52:10,668 --> 00:52:12,829
because the wait time I specified for EventBridge

1438
00:52:12,829 --> 00:52:13,860
was 5 seconds.

1439
00:52:14,469 --> 00:52:16,590
So that kind of adds to it. So what

1440
00:52:16,590 --> 00:52:18,679
we recommend is unit tests should definitely

1441
00:52:18,679 --> 00:52:19,789
run on every commit,

1442
00:52:20,070 --> 00:52:22,349
but some of the long-running integration tests, good

1443
00:52:22,349 --> 00:52:24,550
idea, and only when you explicitly

1444
00:52:24,550 --> 00:52:26,659
change the logic or for major releases,

1445
00:52:26,668 --> 00:52:28,250
so you can optimize your build time.

1446
00:52:29,719 --> 00:52:30,559
All right,

1447
00:52:30,958 --> 00:52:33,280
so we're moving to the last part of our session. Let

1448
00:52:33,280 --> 00:52:35,039
me just flip to

1449
00:52:35,628 --> 00:52:36,389
another window,

1450
00:52:36,679 --> 00:52:37,898
make this a little bit bigger.

1451
00:52:39,449 --> 00:52:40,849
OK, um.

1452
00:52:46,519 --> 00:52:48,519
I'm sorry, uh, I missed the phone

1453
00:52:48,519 --> 00:52:49,418
here. There we go.

1454
00:52:50,260 --> 00:52:52,260
So We, you may have

1455
00:52:52,260 --> 00:52:53,559
noticed that we kind of

1456
00:52:54,179 --> 00:52:56,320
followed certain flow,

1457
00:52:56,329 --> 00:52:56,929
uh,

1458
00:52:57,409 --> 00:52:59,418
throughout the session. So first we had our application in

1459
00:52:59,418 --> 00:53:00,519
a certain state,

1460
00:53:00,898 --> 00:53:03,179
then we figure out what needs to be changed and modified.

1461
00:53:03,300 --> 00:53:05,010
Then we perform the migration using the AI

1462
00:53:05,938 --> 00:53:07,978
and, uh, afterwards we kind of drilled

1463
00:53:07,978 --> 00:53:10,378
deeper into things and kind of figure out how to modify

1464
00:53:10,378 --> 00:53:11,079
it even further.

1465
00:53:11,530 --> 00:53:13,719
So this kind of flows into

1466
00:53:13,719 --> 00:53:15,978
the traditional way of thinking of development

1467
00:53:15,978 --> 00:53:17,989
life cycle but powered by

1468
00:53:17,989 --> 00:53:20,000
AI and this can be elevated. We

1469
00:53:20,000 --> 00:53:22,039
were touching lightly, to be honest, on

1470
00:53:22,039 --> 00:53:23,019
AI in this case,

1471
00:53:23,349 --> 00:53:25,550
uh, most of this stuff you can use Kira or

1472
00:53:26,809 --> 00:53:28,378
or any other uh coding assistant essentially to help you out

1473
00:53:29,199 --> 00:53:30,250
analyze the code,

1474
00:53:30,628 --> 00:53:32,760
uh, but what I want to emphasize here

1475
00:53:32,760 --> 00:53:34,500
is that we followed

1476
00:53:35,239 --> 00:53:36,878
essentially the, the.

1477
00:53:37,449 --> 00:53:38,599
The thinking, uh,

1478
00:53:38,889 --> 00:53:41,300
approach that corresponds with the framework

1479
00:53:41,300 --> 00:53:43,418
that AWS just released a few months back, which

1480
00:53:43,418 --> 00:53:45,469
is AIDLC or, or the AI

1481
00:53:45,469 --> 00:53:47,469
AI driven development life cycle

1482
00:53:47,820 --> 00:53:48,918
which kind of brings

1483
00:53:49,300 --> 00:53:51,619
structure to the chaos. So if you've followed

1484
00:53:51,619 --> 00:53:53,079
the news for most of the year,

1485
00:53:53,418 --> 00:53:54,918
a lot of people talked about white coding.

1486
00:53:55,458 --> 00:53:57,519
Uh, I built this in 5 minutes. I build

1487
00:53:57,519 --> 00:53:59,760
that in 5 minutes, which is great. But once

1488
00:53:59,760 --> 00:54:01,780
you get to a higher level of

1489
00:54:01,780 --> 00:54:04,228
complexity in your application, especially in existing

1490
00:54:04,228 --> 00:54:06,260
applications. You can't just white coat

1491
00:54:06,260 --> 00:54:07,010
your way through stuff.

1492
00:54:08,429 --> 00:54:10,668
uh, this is where we kind of need structure and where

1493
00:54:10,668 --> 00:54:12,769
spectrum and development fits into the picture very,

1494
00:54:12,889 --> 00:54:13,728
very nicely,

1495
00:54:14,070 --> 00:54:16,168
but, uh, to kind of

1496
00:54:16,590 --> 00:54:18,750
bring that to the whole team

1497
00:54:18,750 --> 00:54:20,360
on a, on a larger spectrum,

1498
00:54:20,668 --> 00:54:22,909
this framework is particularly useful and it's, it's

1499
00:54:22,909 --> 00:54:24,503
very simple. To implement actually

1500
00:54:24,824 --> 00:54:26,684
it has 3 stages. So

1501
00:54:27,063 --> 00:54:27,644
as we

1502
00:54:27,945 --> 00:54:30,304
did ourselves, we kinda went through the inception

1503
00:54:30,304 --> 00:54:32,304
phase where we kind of thought about what we

1504
00:54:32,304 --> 00:54:33,043
can improve.

1505
00:54:33,425 --> 00:54:35,503
We had AI perform a review to give us

1506
00:54:35,503 --> 00:54:37,773
a list that we can follow, analyze, tweak,

1507
00:54:37,784 --> 00:54:39,784
modify, uh, or process

1508
00:54:39,784 --> 00:54:40,425
otherwise.

1509
00:54:41,054 --> 00:54:43,465
Then we went to the construction where we actually

1510
00:54:43,465 --> 00:54:45,934
performed the refactoring, uh, performed

1511
00:54:45,934 --> 00:54:47,744
additional changes, and then deployed.

1512
00:54:48,378 --> 00:54:49,320
And afterwards,

1513
00:54:50,289 --> 00:54:52,449
Now we're gonna cover a bit of

1514
00:54:52,449 --> 00:54:54,610
operation. So operation essentially is the part

1515
00:54:54,610 --> 00:54:55,119
where you

1516
00:54:55,378 --> 00:54:56,958
push the production or at least

1517
00:54:57,938 --> 00:55:00,340
some kind of uh traffic loaded environment

1518
00:55:00,340 --> 00:55:01,360
where you can monitor

1519
00:55:01,780 --> 00:55:03,978
and evaluate your application across the span of

1520
00:55:03,978 --> 00:55:06,300
time. So think about a case where we would,

1521
00:55:06,500 --> 00:55:08,628
um, essentially evaluate our

1522
00:55:08,628 --> 00:55:10,659
application, uh, for let's say 3 to 6

1523
00:55:10,659 --> 00:55:11,918
months. It's already running,

1524
00:55:12,300 --> 00:55:13,878
and we want to kind of collect,

1525
00:55:14,219 --> 00:55:16,349
uh, the, the, the bugs or the,

1526
00:55:16,378 --> 00:55:18,050
the issues essentially that we have,

1527
00:55:18,478 --> 00:55:20,869
um. So

1528
00:55:20,869 --> 00:55:22,188
what I'll do right now,

1529
00:55:22,469 --> 00:55:23,409
essentially

1530
00:55:24,110 --> 00:55:26,360
just run this prompt in

1531
00:55:26,360 --> 00:55:27,969
here. I'll tell you in a minute what it does.

1532
00:55:28,550 --> 00:55:31,648
4. So,

1533
00:55:31,699 --> 00:55:32,378
um,

1534
00:55:32,780 --> 00:55:34,320
we do have a list of bugs,

1535
00:55:34,579 --> 00:55:36,840
uh, let me just minimize this so it's visible,

1536
00:55:37,300 --> 00:55:39,519
uh, that we collected over time.

1537
00:55:40,329 --> 00:55:42,389
You can see it's in Jason format, um,

1538
00:55:42,570 --> 00:55:44,438
it's hard to read, it's hard to go through it,

1539
00:55:44,769 --> 00:55:46,659
you know, let's make it easier on ourselves,

1540
00:55:47,128 --> 00:55:49,208
so. What I'll

1541
00:55:49,208 --> 00:55:50,739
do, I'll run this again actually,

1542
00:55:51,280 --> 00:55:52,418
I'll just get a summary.

1543
00:55:53,340 --> 00:55:55,079
And let me fan this out a bit.

1544
00:55:55,860 --> 00:55:57,929
So this is the summary of the Jason file that we

1545
00:55:57,929 --> 00:55:59,929
have. So it essentially gave us

1546
00:55:59,929 --> 00:56:02,090
a total sum of the bugs. Uh, we

1547
00:56:02,090 --> 00:56:04,530
can see there's 1 critical 17 high severity

1548
00:56:04,530 --> 00:56:05,329
ones, etc.

1549
00:56:05,708 --> 00:56:07,769
We can see individual components. So

1550
00:56:07,769 --> 00:56:09,918
this is essentially from the decoupled perspective,

1551
00:56:10,329 --> 00:56:12,329
uh, that we already, uh, talked about. We

1552
00:56:12,329 --> 00:56:13,688
can see which file has,

1553
00:56:14,090 --> 00:56:15,628
uh, which, which problems,

1554
00:56:16,090 --> 00:56:18,168
uh, and we can go deeper. We can, we can see which

1555
00:56:18,168 --> 00:56:20,639
one relates to validation, uh, serialization,

1556
00:56:20,688 --> 00:56:21,269
etc.

1557
00:56:22,030 --> 00:56:24,030
Um, now, we asked Giro if

1558
00:56:24,030 --> 00:56:26,590
I scroll a bit higher, to actually analyze

1559
00:56:26,590 --> 00:56:27,289
our

1560
00:56:27,860 --> 00:56:30,188
application and create a, a risk heat map,

1561
00:56:30,708 --> 00:56:32,168
essentially for us to understand

1562
00:56:32,829 --> 00:56:35,409
which parts of the application need to be modified

1563
00:56:35,989 --> 00:56:36,639
and how.

1564
00:56:37,219 --> 00:56:39,260
Alright, we gave it some extra input

1565
00:56:39,260 --> 00:56:41,320
just to follow the hexagonal architecture,

1566
00:56:41,628 --> 00:56:43,260
essentially, and it's already working on it.

1567
00:56:43,539 --> 00:56:45,739
Uh, it's creating a heat map, uh, now

1568
00:56:45,739 --> 00:56:47,780
just for the sake of time because we have 3 minutes left,

1569
00:56:48,849 --> 00:56:49,519
I will use

1570
00:56:50,349 --> 00:56:52,619
the pre-created one, so let me just flip

1571
00:56:52,619 --> 00:56:53,250
to that one.

1572
00:56:55,860 --> 00:56:56,739
Uh, here.

1573
00:56:58,550 --> 00:57:00,668
It actually is modifying this precreator one, so

1574
00:57:00,668 --> 00:57:02,010
you can see it's flickering,

1575
00:57:02,510 --> 00:57:04,829
uh, it just modified it,

1576
00:57:05,208 --> 00:57:07,228
and let me just scroll all the way

1577
00:57:07,228 --> 00:57:08,849
up. So,

1578
00:57:09,188 --> 00:57:11,099
you can see it's been just, just updated,

1579
00:57:11,409 --> 00:57:13,539
Kira just finished updating it, uh, if

1580
00:57:13,539 --> 00:57:15,668
the the file wasn't existing, it'll create a new one, of

1581
00:57:15,668 --> 00:57:17,898
course. But this

1582
00:57:17,898 --> 00:57:19,938
is similar to that uh

1583
00:57:19,938 --> 00:57:21,978
evaluation that audit file that we created

1584
00:57:21,978 --> 00:57:24,000
before essentially we got a full report

1585
00:57:24,000 --> 00:57:26,340
about what's happening based on uh

1586
00:57:26,340 --> 00:57:28,639
based on our collective bugs or bug report.

1587
00:57:29,090 --> 00:57:31,128
It can be locks. It can be anything. It doesn't have to

1588
00:57:31,128 --> 00:57:33,159
be just in the simple form as, as we, as

1589
00:57:33,159 --> 00:57:35,489
we saw, but we can see the highest

1590
00:57:35,489 --> 00:57:37,570
pin points essentially. So this is quite graphical,

1591
00:57:37,889 --> 00:57:40,050
uh, and Quiro can do this in even

1592
00:57:40,050 --> 00:57:41,829
in a higher level depending on the configuration.

1593
00:57:42,168 --> 00:57:44,349
There's steering that we can use to kind of

1594
00:57:44,579 --> 00:57:46,800
fiddle with this and make it more granular, more,

1595
00:57:46,969 --> 00:57:48,250
uh, customized,

1596
00:57:48,648 --> 00:57:50,989
uh, and this kind of brings us back to the.

1597
00:57:52,000 --> 00:57:54,119
Uh, previous approach where

1598
00:57:54,119 --> 00:57:56,438
we right now imagine we are in

1599
00:57:56,438 --> 00:57:58,659
operation, right? So you would imagine that's the end of it

1600
00:57:58,958 --> 00:58:00,139
we'll just collect it and.

1601
00:58:01,090 --> 00:58:03,168
That's it, right? Now, we're gonna do something

1602
00:58:03,168 --> 00:58:04,510
with it. So we could

1603
00:58:04,769 --> 00:58:06,769
do the same thing that we did in

1604
00:58:06,769 --> 00:58:08,688
the inception phase where we took our

1605
00:58:09,369 --> 00:58:11,809
audit, created a spec, and

1606
00:58:11,809 --> 00:58:13,929
refractor application. So, in this case, we can take our

1607
00:58:13,929 --> 00:58:14,728
heat map again.

1608
00:58:16,179 --> 00:58:18,188
Have Cro analyze it even further if we want to

1609
00:58:18,188 --> 00:58:18,938
create our spec

1610
00:58:20,010 --> 00:58:22,110
and feed it back to the inception, so we're

1611
00:58:22,110 --> 00:58:24,510
essentially making a full circle from the

1612
00:58:24,510 --> 00:58:25,648
operations to inception,

1613
00:58:26,148 --> 00:58:28,619
then apply through construction, essentially apply our findings,

1614
00:58:28,978 --> 00:58:30,530
improve our architecture, improve our application,

1615
00:58:31,269 --> 00:58:33,389
eliminate or minimize or mitigate

1616
00:58:33,389 --> 00:58:34,898
those bugs that we're running into,

1617
00:58:35,188 --> 00:58:36,090
and, uh,

1618
00:58:36,829 --> 00:58:38,929
that essentially creates the full circle

1619
00:58:38,929 --> 00:58:41,050
of the uh AI driven development.

1620
00:58:44,550 --> 00:58:47,478
PPD. In

1621
00:58:47,478 --> 00:58:49,938
take Yep,

1622
00:58:50,059 --> 00:58:52,219
so just summarizing the things we covered

1623
00:58:52,219 --> 00:58:54,570
today, uh, we looked at how you can basically

1624
00:58:54,570 --> 00:58:56,619
use Gen AI throughout the development life

1625
00:58:56,619 --> 00:58:57,478
cycle. So

1626
00:58:58,019 --> 00:59:00,019
instead of approaching it just as writing tests

1627
00:59:00,019 --> 00:59:02,418
for Servalli, but how do you redesign to simplify

1628
00:59:02,418 --> 00:59:03,000
testing,

1629
00:59:03,378 --> 00:59:05,489
and then we saw, so just so you know, all of

1630
00:59:05,489 --> 00:59:07,728
the, including property-based tests and the

1631
00:59:07,728 --> 00:59:09,739
application itself, we built it using hero, a

1632
00:59:09,739 --> 00:59:11,478
lot of the spectrum and development.

1633
00:59:11,898 --> 00:59:13,978
And then of course, towards the end, Thomas showed how you

1634
00:59:13,978 --> 00:59:16,099
can continuously iterate, uh, based

1635
00:59:16,099 --> 00:59:18,699
on historic data to improve your

1636
00:59:18,699 --> 00:59:19,458
application. Uh,

1637
00:59:20,369 --> 00:59:22,030
so some quick resources.

1638
00:59:23,079 --> 00:59:25,478
The first one is a talk from 2023,

1639
00:59:25,519 --> 00:59:28,039
but it's a really good breakout that talks specifically

1640
00:59:28,039 --> 00:59:30,478
from a Python perspective, some of the best practices.

1641
00:59:31,119 --> 00:59:33,119
Uh, the second one is from this year, but this

1642
00:59:33,119 --> 00:59:34,199
is a recorded one.

1643
00:59:34,599 --> 00:59:36,889
we now have really good integrations to,

1644
00:59:37,079 --> 00:59:39,398
uh, debug functions live, uh, using

1645
00:59:39,398 --> 00:59:40,039
VS code.

1646
00:59:40,389 --> 00:59:42,519
And the last one is the completed version of

1647
00:59:42,519 --> 00:59:44,760
our task API that follows all of the best

1648
00:59:44,760 --> 00:59:47,110
practices that's published out to GitHub, and

1649
00:59:47,320 --> 00:59:49,139
you should be able to access it there.

1650
00:59:49,648 --> 00:59:52,188
Then really quick if you're looking for service and

1651
00:59:52,188 --> 00:59:54,349
advent resources this is the place to go

1652
00:59:54,969 --> 00:59:55,489
and

1653
00:59:55,889 --> 00:59:58,090
that was really it. We thank you for spending

1654
00:59:58,090 --> 01:00:00,208
time with us for spending your last

1655
01:00:00,208 --> 01:00:01,228
day agreement with us.

