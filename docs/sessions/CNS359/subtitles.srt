1
00:00:00,170 --> 00:00:02,309
Good morning everyone. Thank you for being here

2
00:00:02,450 --> 00:00:04,030
and uh happy to have you all

3
00:00:04,488 --> 00:00:06,269
for this session CNS 359.

4
00:00:06,730 --> 00:00:09,130
Uh, my name is Diraj Mapatra. I'm a principal

5
00:00:09,130 --> 00:00:11,228
specialist solutions architect at AWS,

6
00:00:11,608 --> 00:00:12,868
and with me I have

7
00:00:13,368 --> 00:00:15,890
my name is AJ Park. I'm also a solutions architect here at AWS

8
00:00:15,890 --> 00:00:16,879
covering, uh, generative AI.

9
00:00:18,269 --> 00:00:19,489
All right, so we're gonna kick it off today.

10
00:00:19,949 --> 00:00:21,989
Uh, hopefully you're excited. We're getting started here at

11
00:00:21,989 --> 00:00:22,559
Reinvent.

12
00:00:22,829 --> 00:00:24,829
Uh, we're gonna talk about building, deploying, and

13
00:00:24,829 --> 00:00:26,530
operating agentic applications

14
00:00:26,809 --> 00:00:28,750
using AWS Servius, and so

15
00:00:29,019 --> 00:00:31,138
we have a lot we wanna cover, so we're gonna dive right

16
00:00:31,138 --> 00:00:33,329
into it. Uh, this is just a quick overview

17
00:00:33,548 --> 00:00:35,630
of our agenda, but again we're gonna dive right into

18
00:00:35,630 --> 00:00:37,700
it. Just a couple of quick

19
00:00:37,700 --> 00:00:38,560
assumptions here.

20
00:00:39,298 --> 00:00:41,859
This is a 300 level session. There are some assumptions

21
00:00:41,859 --> 00:00:43,899
around some knowledge. We won't cover a lot of the

22
00:00:43,899 --> 00:00:44,899
basic definitions.

23
00:00:45,219 --> 00:00:47,289
We're going to make some of those assumptions. We're also

24
00:00:47,289 --> 00:00:49,478
going to start with some principles again as architects

25
00:00:49,478 --> 00:00:51,579
with your architect hat on here. We're going to want to

26
00:00:51,579 --> 00:00:54,000
talk about some of those principles and then we're going to apply

27
00:00:54,179 --> 00:00:56,340
some of the pragmatic deployment

28
00:00:56,340 --> 00:00:56,899
thinking here.

29
00:00:57,689 --> 00:00:59,779
OK, so the first thing that we wanna

30
00:00:59,779 --> 00:01:01,889
think through is as we think about designing

31
00:01:01,889 --> 00:01:04,480
single agent systems we're gonna then transition

32
00:01:04,480 --> 00:01:06,239
into multi-agent systems,

33
00:01:06,540 --> 00:01:08,668
but. Before we do that, why don't we

34
00:01:08,668 --> 00:01:10,668
start with a customer example, and we're

35
00:01:10,668 --> 00:01:11,808
going to use this example

36
00:01:12,469 --> 00:01:13,650
throughout this talk. So

37
00:01:13,948 --> 00:01:15,588
you imagine we just went through Black Friday.

38
00:01:16,500 --> 00:01:18,599
Your, uh, shopping, perhaps gift shopping.

39
00:01:19,058 --> 00:01:20,599
Uh, I was charged twice for my order.

40
00:01:21,180 --> 00:01:23,409
In fact, there should have been two items. I only received

41
00:01:23,409 --> 00:01:25,418
one, and I need it actually tomorrow

42
00:01:25,418 --> 00:01:27,500
for a gift, right? And so here is

43
00:01:27,500 --> 00:01:29,638
they were charged twice. Here's issue number 1

44
00:01:29,859 --> 00:01:32,138
that instead of being charged once, as you would

45
00:01:32,138 --> 00:01:34,480
expect, the payment system perhaps

46
00:01:34,579 --> 00:01:36,120
accidentally charged you twice for some reason.

47
00:01:36,808 --> 00:01:38,918
Also, there you did not receive all

48
00:01:38,918 --> 00:01:40,930
of the items in the order and then of course

49
00:01:40,930 --> 00:01:43,329
there is this rush, uh, this impending

50
00:01:43,329 --> 00:01:45,439
need to get it tomorrow because you need to actually

51
00:01:45,439 --> 00:01:47,329
give this as a gift. So we're gonna think through these,

52
00:01:47,609 --> 00:01:49,719
uh, problem statements throughout this, uh,

53
00:01:49,730 --> 00:01:52,079
talk. So for the servius

54
00:01:52,079 --> 00:01:54,209
aficionados here, we may build this with

55
00:01:54,209 --> 00:01:56,278
a servalus set of servalus APIs.

56
00:01:56,329 --> 00:01:57,388
This is your retail application.

57
00:01:58,150 --> 00:02:00,308
Uh, again, you can imagine using domain driven design

58
00:02:00,308 --> 00:02:02,388
we may have some different bounded context. You, you'll

59
00:02:02,388 --> 00:02:04,400
have a number of different APIs here, right?

60
00:02:04,549 --> 00:02:06,650
So maybe your order's API

61
00:02:06,870 --> 00:02:09,099
is going to manage the life cycle of that,

62
00:02:09,110 --> 00:02:10,710
uh, customer purchasing process.

63
00:02:11,028 --> 00:02:13,028
Uh, you might use inventory management to look

64
00:02:13,028 --> 00:02:15,149
in your warehouse, see what's available again. Maybe

65
00:02:15,149 --> 00:02:17,189
on Black Friday you may have sold out of some of

66
00:02:17,189 --> 00:02:19,455
those. So you want to be able to

67
00:02:19,455 --> 00:02:21,485
notify the front end that some of these

68
00:02:21,485 --> 00:02:23,883
items perhaps are not available. Again,

69
00:02:23,895 --> 00:02:26,274
similarly with payments, we want to maybe do direct payments

70
00:02:26,413 --> 00:02:28,514
or maybe even invoicing of your customers

71
00:02:28,735 --> 00:02:30,814
and then of course the support API for maybe your

72
00:02:30,814 --> 00:02:31,835
support organization

73
00:02:32,145 --> 00:02:34,365
when this request comes in, we can then use

74
00:02:34,365 --> 00:02:35,974
this to go and triage what perhaps went wrong.

75
00:02:37,729 --> 00:02:39,758
OK, so with this

76
00:02:39,819 --> 00:02:41,919
we think about this customer experience and what are we gonna

77
00:02:41,919 --> 00:02:43,939
try to solve for, right? These are some

78
00:02:43,939 --> 00:02:45,939
of the challenges that we're thinking through is as a

79
00:02:45,939 --> 00:02:47,219
customer support agent,

80
00:02:48,250 --> 00:02:50,300
maybe uh I have to respond to these and I have to

81
00:02:50,300 --> 00:02:52,419
look in multiple disparate systems. Maybe there's

82
00:02:52,419 --> 00:02:54,179
a payments portal internally.

83
00:02:54,469 --> 00:02:56,558
Maybe there's something around inventory management.

84
00:02:56,740 --> 00:02:58,740
You can imagine trying to build a dashboard or

85
00:02:58,740 --> 00:03:00,038
some type of support system

86
00:03:00,460 --> 00:03:02,860
that allows me to see all of these disparate

87
00:03:02,860 --> 00:03:04,000
sources of information

88
00:03:04,258 --> 00:03:05,319
all in one place.

89
00:03:06,189 --> 00:03:08,508
Furthermore, of course you want a good customer

90
00:03:08,508 --> 00:03:10,508
experience, so we don't want the customer to be sitting

91
00:03:10,508 --> 00:03:12,300
and waiting for a long period of time.

92
00:03:12,588 --> 00:03:14,770
So we want to be able to address this customer issue

93
00:03:14,909 --> 00:03:16,990
as quickly as possible and also

94
00:03:16,990 --> 00:03:18,729
you want to make sure that your support

95
00:03:19,050 --> 00:03:21,069
personnel that they get quick guidance as

96
00:03:21,069 --> 00:03:23,149
well so that you don't have your customer waiting

97
00:03:23,149 --> 00:03:24,849
for a long period of time

98
00:03:25,149 --> 00:03:27,219
before they get feedback of, hey, what's the

99
00:03:27,219 --> 00:03:28,588
next potential resolution.

100
00:03:29,649 --> 00:03:31,338
So can we do better? Can we do better?

101
00:03:31,860 --> 00:03:32,679
Now you're thinking,

102
00:03:33,179 --> 00:03:35,258
uh, I could probably do this just

103
00:03:35,258 --> 00:03:37,300
by having better, you know, unit test

104
00:03:37,300 --> 00:03:39,610
integration tests within my application itself,

105
00:03:40,179 --> 00:03:42,219
but even we were just talking with some

106
00:03:42,219 --> 00:03:43,719
folks in the in the front here

107
00:03:44,008 --> 00:03:46,399
that there are ways to perhaps get

108
00:03:46,399 --> 00:03:47,808
insight into data quicker

109
00:03:48,778 --> 00:03:50,719
using perhaps an LLM. So

110
00:03:50,979 --> 00:03:52,199
in this scenario, oops,

111
00:03:52,460 --> 00:03:54,819
in this scenario, perhaps you use you integrate

112
00:03:54,819 --> 00:03:56,599
an LLM. We're going to invoke a model

113
00:03:56,939 --> 00:03:58,399
provide it with some amount of data.

114
00:03:58,758 --> 00:04:00,868
And get some type of reasoning insight

115
00:04:00,868 --> 00:04:01,969
back from this model,

116
00:04:02,689 --> 00:04:04,949
right, and we're gonna talk a bunch about how do we uh

117
00:04:04,949 --> 00:04:07,099
do this in a way that makes sense for our

118
00:04:07,099 --> 00:04:09,189
application. So the quick naive way we

119
00:04:09,189 --> 00:04:11,409
wanna think about it is we wanna provide context

120
00:04:11,788 --> 00:04:13,879
to this application and to this LLM.

121
00:04:14,069 --> 00:04:16,100
The first way we may think about doing that is

122
00:04:16,100 --> 00:04:16,649
through this

123
00:04:16,910 --> 00:04:17,670
idea of search.

124
00:04:18,189 --> 00:04:20,259
Here the key thing is you're gonna have a prompt, so

125
00:04:20,259 --> 00:04:22,309
maybe you have an application, you're gonna construct

126
00:04:22,309 --> 00:04:23,970
a prompt through this application.

127
00:04:24,660 --> 00:04:26,670
You will then perhaps go and get some

128
00:04:26,670 --> 00:04:29,209
information out of a knowledge source, so this could be some type of semantic

129
00:04:29,209 --> 00:04:30,000
knowledge store

130
00:04:30,298 --> 00:04:32,338
and maybe this is a prior

131
00:04:32,338 --> 00:04:34,459
history with this customer, maybe this

132
00:04:34,459 --> 00:04:36,459
is the inventory, uh, data

133
00:04:36,459 --> 00:04:38,819
warehouse, and maybe this is a uh

134
00:04:38,819 --> 00:04:40,238
finance payments API.

135
00:04:40,980 --> 00:04:43,319
We're gonna then go and extract that knowledge

136
00:04:43,660 --> 00:04:46,259
and uh then submit an enhanced

137
00:04:46,259 --> 00:04:47,540
prompt to the LOM.

138
00:04:47,879 --> 00:04:50,028
The key thing that you you wanna think about here

139
00:04:50,028 --> 00:04:52,329
is the fact that the application

140
00:04:52,588 --> 00:04:54,949
is orchestrating the the flow

141
00:04:54,949 --> 00:04:56,189
of information retrieval.

142
00:04:56,470 --> 00:04:58,738
So it is the application that is gonna parse the prompt.

143
00:04:58,949 --> 00:05:01,108
It is gonna go and say, OK, we need to get some

144
00:05:01,108 --> 00:05:03,309
set of data, uh, out of this knowledge

145
00:05:03,309 --> 00:05:05,379
source and then submit that to the LLM.

146
00:05:05,449 --> 00:05:07,858
So as a developer building this type of

147
00:05:07,858 --> 00:05:10,028
application, the developer needs to write

148
00:05:10,028 --> 00:05:12,009
and orchestrate all of this, uh, logic.

149
00:05:13,500 --> 00:05:15,579
Perhaps you may also think maybe we want to do this

150
00:05:15,579 --> 00:05:17,670
a little bit more dynamically. Maybe as a developer

151
00:05:17,670 --> 00:05:19,509
I don't know the actual workflow,

152
00:05:19,949 --> 00:05:22,028
so perhaps there's a way we can do this where we can

153
00:05:22,028 --> 00:05:23,009
have the LLM

154
00:05:23,269 --> 00:05:25,428
make a determination of what the next step is without

155
00:05:25,428 --> 00:05:27,588
writing imperative code.

156
00:05:27,829 --> 00:05:29,910
So here you have that same prompt, the same

157
00:05:29,910 --> 00:05:31,928
application. And what we're gonna now do as

158
00:05:31,928 --> 00:05:34,459
part of this prompt is to submit

159
00:05:34,459 --> 00:05:36,269
a list of available tools

160
00:05:36,528 --> 00:05:38,889
that this LLM can then make a decision about.

161
00:05:39,178 --> 00:05:41,500
The LLM can then come back and say, hey, I like,

162
00:05:41,608 --> 00:05:42,850
you know, tool A and B.

163
00:05:43,129 --> 00:05:45,269
I'm gonna go make a request. Can you

164
00:05:45,269 --> 00:05:47,399
application go and fetch this data on my

165
00:05:47,399 --> 00:05:47,949
behalf?

166
00:05:48,720 --> 00:05:50,980
Now the application on behalf of the LLM

167
00:05:51,160 --> 00:05:53,619
will go and fetch the data from that same knowledge source

168
00:05:53,959 --> 00:05:56,028
and then we'll submit that enhanced prompt.

169
00:05:56,230 --> 00:05:58,738
So the key difference here is maybe as a developer

170
00:05:58,879 --> 00:06:00,879
I've actually simplified the type of

171
00:06:00,879 --> 00:06:02,920
code that I'm writing or the amount of code that

172
00:06:02,920 --> 00:06:05,319
I'm writing and offloading that logic

173
00:06:05,319 --> 00:06:07,439
to the LLM because maybe this is something we want to do a little

174
00:06:07,439 --> 00:06:08,420
bit more dynamically.

175
00:06:09,129 --> 00:06:10,600
OK, so we talked a little bit about

176
00:06:10,858 --> 00:06:13,139
this enhanced prompt, and you may be wondering what is that,

177
00:06:13,298 --> 00:06:15,250
what exactly is that enhanced prompt?

178
00:06:15,540 --> 00:06:17,699
Well, great question. Here's perhaps a JSON

179
00:06:17,699 --> 00:06:18,358
document

180
00:06:18,738 --> 00:06:21,129
that shows examples of, uh,

181
00:06:21,139 --> 00:06:23,178
pieces of information that may be in this prompt.

182
00:06:23,459 --> 00:06:25,678
So of course there, there's a system prompt

183
00:06:25,928 --> 00:06:28,178
that then defines here is the persona,

184
00:06:28,459 --> 00:06:30,459
the set of capabilities, and maybe

185
00:06:30,459 --> 00:06:32,639
some boundary, uh, behaviors

186
00:06:32,819 --> 00:06:34,660
that we have for this particular agent.

187
00:06:35,108 --> 00:06:37,230
So and then of course at the bottom then is

188
00:06:37,230 --> 00:06:39,309
the human prompt that was submitted, but the key thing

189
00:06:39,309 --> 00:06:40,009
here is

190
00:06:40,350 --> 00:06:42,608
all of this additional context at the top

191
00:06:42,798 --> 00:06:45,189
is something that the application is gonna

192
00:06:45,189 --> 00:06:47,189
provide in addition to the human

193
00:06:47,189 --> 00:06:49,298
prompt. So these are all things that are perhaps hidden from the

194
00:06:49,298 --> 00:06:49,899
user,

195
00:06:50,309 --> 00:06:52,649
maybe in our case the customer support representative,

196
00:06:53,350 --> 00:06:55,588
but that these are all included as part of that enhanced

197
00:06:55,588 --> 00:06:57,829
prompt. And the key thing here then is

198
00:06:57,829 --> 00:07:00,108
this list of tools. So we, we, uh

199
00:07:00,108 --> 00:07:01,250
talked before about

200
00:07:01,548 --> 00:07:03,629
there's this list of tools that we're going to submit to the

201
00:07:03,629 --> 00:07:05,639
LLM. To then give it an

202
00:07:05,639 --> 00:07:08,079
opportunity to make a decision about what additional

203
00:07:08,079 --> 00:07:10,189
information the LLM believes it needs in order

204
00:07:10,189 --> 00:07:12,319
to make a better uh choice or

205
00:07:12,319 --> 00:07:13,980
a better, um, you know,

206
00:07:14,759 --> 00:07:16,678
insight into the data that we wanna have.

207
00:07:17,079 --> 00:07:19,139
OK, so if we then bring this back

208
00:07:19,238 --> 00:07:20,920
to our traditional retail application.

209
00:07:21,730 --> 00:07:23,149
We then have this application

210
00:07:23,449 --> 00:07:25,608
that can go and make these tool calls.

211
00:07:26,129 --> 00:07:28,410
We can then essentially wrap our serverless

212
00:07:28,410 --> 00:07:30,750
APIs as tool calls

213
00:07:31,048 --> 00:07:33,209
in order to then uh provide these enhanced prompts

214
00:07:33,209 --> 00:07:35,730
to the LLM. So this traditional retail

215
00:07:35,730 --> 00:07:38,028
application is gonna recursively make calls to the LLM.

216
00:07:38,410 --> 00:07:40,540
The LLM maybe requests data,

217
00:07:41,170 --> 00:07:43,170
then makes these tool calls, and then kind of has

218
00:07:43,170 --> 00:07:45,410
this iterative loop. This is something that the developer

219
00:07:45,410 --> 00:07:47,559
is going to write this recursive loop

220
00:07:47,559 --> 00:07:50,009
for until it comes to some type of base

221
00:07:50,009 --> 00:07:52,088
condition that says we are complete and

222
00:07:52,088 --> 00:07:53,670
we are good to then return

223
00:07:54,048 --> 00:07:55,689
some type of response back to the end user.

224
00:07:57,040 --> 00:07:57,988
OK, so

225
00:07:59,069 --> 00:08:01,678
Of course this is now we're talking about agentic

226
00:08:01,678 --> 00:08:03,759
applications and what is the difference between what we

227
00:08:03,759 --> 00:08:05,759
did before and perhaps what is

228
00:08:05,759 --> 00:08:07,838
an agent today and the key difference

229
00:08:07,838 --> 00:08:09,899
here is you'll see at the top there is this

230
00:08:09,899 --> 00:08:10,980
agentic loop

231
00:08:11,759 --> 00:08:13,139
where it repeats as needed. So

232
00:08:13,519 --> 00:08:14,500
what does that look like?

233
00:08:14,809 --> 00:08:16,838
So again we have this prompt, we

234
00:08:16,838 --> 00:08:18,920
have our agent now where it invokes

235
00:08:18,920 --> 00:08:19,619
this model.

236
00:08:20,199 --> 00:08:21,819
Again with that list of tools,

237
00:08:22,079 --> 00:08:24,119
it gets that response back again we went through

238
00:08:24,119 --> 00:08:26,278
this, we execute a tool, we get that

239
00:08:26,278 --> 00:08:28,220
result, and then of course we repeat

240
00:08:28,569 --> 00:08:30,629
as as frequently as needed,

241
00:08:30,838 --> 00:08:32,840
right? And so it is now the agentic framework that

242
00:08:32,840 --> 00:08:33,739
is going to be handling

243
00:08:34,418 --> 00:08:36,719
what, how many times do I actually need to loop. Maybe

244
00:08:36,719 --> 00:08:38,719
I need to do this once or maybe I need to do this 3

245
00:08:38,719 --> 00:08:39,590
times. Um,

246
00:08:40,379 --> 00:08:42,538
so this is something where we're going to think through this

247
00:08:42,538 --> 00:08:45,158
tool execution. So we're going to be continuously

248
00:08:45,158 --> 00:08:46,590
retrieving context

249
00:08:47,058 --> 00:08:49,058
from our different knowledge sources via

250
00:08:49,058 --> 00:08:51,739
these tool calls so that the LLM has

251
00:08:51,739 --> 00:08:53,859
sufficient amount of information or data

252
00:08:53,859 --> 00:08:56,288
or context in order to make a

253
00:08:56,288 --> 00:08:56,820
good decision.

254
00:08:58,239 --> 00:09:00,479
OK, and then of course we then return that final

255
00:09:00,479 --> 00:09:02,590
result. So one thing that we may

256
00:09:02,590 --> 00:09:04,590
want to think through then is we had that

257
00:09:04,590 --> 00:09:05,580
servius API,

258
00:09:06,080 --> 00:09:08,200
uh, we perhaps built it as a

259
00:09:08,200 --> 00:09:09,779
single monolithic agent,

260
00:09:10,038 --> 00:09:11,399
which is OK to start with,

261
00:09:11,690 --> 00:09:13,719
but may, we may also want to start thinking about do we

262
00:09:13,719 --> 00:09:15,798
want to potentially decompose that similar to

263
00:09:15,798 --> 00:09:17,099
what we had done before

264
00:09:17,359 --> 00:09:19,940
when we had monolithic APIs, monolithic,

265
00:09:19,989 --> 00:09:21,418
uh, large services

266
00:09:21,719 --> 00:09:23,719
which again in this audience you probably know all

267
00:09:23,719 --> 00:09:25,908
of the challenges around scaling, around deployment,

268
00:09:26,070 --> 00:09:26,798
around agility.

269
00:09:27,288 --> 00:09:29,769
We can start to apply some of those same principles

270
00:09:29,769 --> 00:09:31,769
as you start to think about agents. It's OK

271
00:09:31,769 --> 00:09:33,408
to start with a monolithic agent,

272
00:09:33,729 --> 00:09:35,928
but maybe as you start to build out the use case, maybe

273
00:09:35,928 --> 00:09:37,330
you want to start to decompose it

274
00:09:37,690 --> 00:09:39,729
again, maybe into agentic microservices.

275
00:09:40,048 --> 00:09:42,408
And here you see we take each of those servius

276
00:09:42,408 --> 00:09:43,590
APIs that we had before,

277
00:09:44,129 --> 00:09:46,129
which again you had done that decomposition previously,

278
00:09:47,168 --> 00:09:49,210
and now we start to wrap them around with

279
00:09:49,210 --> 00:09:49,869
agents.

280
00:09:50,408 --> 00:09:51,629
Now you may be thinking, OK,

281
00:09:52,090 --> 00:09:54,168
kind of makes sense, but why might we want to do

282
00:09:54,168 --> 00:09:55,279
that? So

283
00:09:55,580 --> 00:09:57,479
one reason you may want to think through is

284
00:09:57,779 --> 00:09:59,899
as you build these domain agents you can imagine

285
00:09:59,899 --> 00:10:02,099
you're gonna have lots of uh the business

286
00:10:02,099 --> 00:10:04,259
coming back and saying we want additional capabilities.

287
00:10:04,298 --> 00:10:06,479
Maybe developers realize we can extend

288
00:10:06,899 --> 00:10:09,178
the capabilities and provide better customer

289
00:10:09,178 --> 00:10:09,798
value

290
00:10:10,099 --> 00:10:12,178
with these different domain level agents and so

291
00:10:12,178 --> 00:10:13,038
here we have.

292
00:10:13,489 --> 00:10:15,538
Uh, the inventory agent that

293
00:10:15,538 --> 00:10:18,070
is using that server as inventory API,

294
00:10:18,418 --> 00:10:20,979
but now we start to extend it and say, can we add

295
00:10:20,979 --> 00:10:22,058
additional capability?

296
00:10:22,379 --> 00:10:25,168
Maybe we're gonna add things like find alternative

297
00:10:25,168 --> 00:10:26,399
product recommendations

298
00:10:26,739 --> 00:10:28,918
based on the information that this domain agent

299
00:10:28,918 --> 00:10:29,580
already has.

300
00:10:29,899 --> 00:10:32,000
So this is where you can start to build out additional

301
00:10:32,000 --> 00:10:32,960
capabilities

302
00:10:33,940 --> 00:10:35,668
within a certain scope of, uh,

303
00:10:36,298 --> 00:10:39,038
let's say back office or line of business capabilities.

304
00:10:39,899 --> 00:10:41,080
OK, so

305
00:10:41,500 --> 00:10:42,960
with that, I'm gonna

306
00:10:43,259 --> 00:10:44,119
hand it over.

307
00:10:46,558 --> 00:10:47,548
To Draj

308
00:10:48,729 --> 00:10:49,330
Thank you, Iggy.

309
00:10:50,029 --> 00:10:52,399
So In a nutshell, the,

310
00:10:52,529 --> 00:10:54,529
the principles that Higgy talked about

311
00:10:54,529 --> 00:10:55,950
actually is the

312
00:10:56,250 --> 00:10:58,288
foundational of how you should think about agent and

313
00:10:58,288 --> 00:10:59,599
how it has evolved.

314
00:11:00,168 --> 00:11:01,879
So we started with LLM inferencing,

315
00:11:02,250 --> 00:11:04,710
something like RAG, which provides context.

316
00:11:05,109 --> 00:11:06,928
Then we talked about tool use

317
00:11:07,389 --> 00:11:09,710
where uh you can imperatively call

318
00:11:09,710 --> 00:11:12,009
different tools, and then we talked about agents.

319
00:11:12,308 --> 00:11:13,928
Now my goal here is to show

320
00:11:14,469 --> 00:11:16,538
how this is implemented and how you,

321
00:11:16,629 --> 00:11:18,690
you can see that this evolution going

322
00:11:18,690 --> 00:11:20,048
from like basics

323
00:11:20,308 --> 00:11:22,590
to actually using an agent and developing an agent.

324
00:11:23,109 --> 00:11:25,489
So let's go back to an example that Higgy

325
00:11:25,649 --> 00:11:26,269
talked about.

326
00:11:26,548 --> 00:11:27,599
You have a surveillance application,

327
00:11:27,869 --> 00:11:29,969
you're talking to, let's say, Bedrock models,

328
00:11:29,979 --> 00:11:31,048
and the user is calling

329
00:11:31,548 --> 00:11:33,369
for the same problem that Higgy brought up.

330
00:11:33,969 --> 00:11:35,599
He was charged twice for

331
00:11:36,479 --> 00:11:37,178
The order.

332
00:11:37,678 --> 00:11:40,000
So how an agent or how do you applicate

333
00:11:40,000 --> 00:11:41,899
how your application will handle it today?

334
00:11:42,668 --> 00:11:43,460
Think about

335
00:11:43,759 --> 00:11:45,840
calling an LLM. You have to provide

336
00:11:45,840 --> 00:11:47,119
all the context like

337
00:11:47,479 --> 00:11:49,719
you are an order assistant. These are the tools

338
00:11:49,719 --> 00:11:51,759
that you have at your disposal, and this is

339
00:11:51,759 --> 00:11:54,058
the question of the user problem that the user has.

340
00:11:54,119 --> 00:11:55,619
Now you have to go and solve this.

341
00:11:56,038 --> 00:11:57,719
That's where the LLM figures out

342
00:11:58,119 --> 00:12:00,399
based on the information that you have provided

343
00:12:00,399 --> 00:12:01,330
on the order.

344
00:12:01,719 --> 00:12:03,918
First I have to go and get the order details,

345
00:12:04,239 --> 00:12:06,479
right? And it's the ownership

346
00:12:06,479 --> 00:12:08,599
of the application, the sur application

347
00:12:08,599 --> 00:12:09,219
to go and

348
00:12:09,558 --> 00:12:11,279
somehow fetch the ownership details.

349
00:12:11,668 --> 00:12:13,320
It can go and call an API

350
00:12:13,750 --> 00:12:15,099
invoke a lambda function,

351
00:12:15,479 --> 00:12:17,408
and get that res responses back,

352
00:12:17,719 --> 00:12:20,440
and the main part here is once the responses

353
00:12:20,440 --> 00:12:22,479
received, it has to be fed

354
00:12:22,479 --> 00:12:24,798
back to the LLM as an additional context.

355
00:12:25,239 --> 00:12:27,320
That's how the LLM gets additional context

356
00:12:27,320 --> 00:12:27,879
and

357
00:12:28,178 --> 00:12:30,019
can work on the next steps.

358
00:12:30,359 --> 00:12:32,479
So as the next steps, it can go and say, OK, I have

359
00:12:32,479 --> 00:12:35,109
the information now I have to go and get the invoices,

360
00:12:35,558 --> 00:12:37,599
and once you got the invoice, the results, and

361
00:12:37,599 --> 00:12:39,908
it has to feed that information back to,

362
00:12:40,239 --> 00:12:41,000
uh, the LLM.

363
00:12:41,408 --> 00:12:42,308
And finally,

364
00:12:43,129 --> 00:12:45,210
once all of those things are are figured

365
00:12:45,210 --> 00:12:47,308
out, then it can start the refund process.

366
00:12:47,849 --> 00:12:49,668
Once the refund process is complete,

367
00:12:50,168 --> 00:12:52,119
the final response will be sent to the,

368
00:12:52,408 --> 00:12:54,489
the, the user saying that, OK, the refund was

369
00:12:54,489 --> 00:12:55,009
applied.

370
00:12:55,408 --> 00:12:57,969
So you see that, uh, the agenttic loop

371
00:12:57,969 --> 00:12:59,899
that Haggy was talking about,

372
00:13:00,450 --> 00:13:02,529
without using an agent, we are already talking

373
00:13:02,529 --> 00:13:03,428
about a loop here.

374
00:13:03,769 --> 00:13:06,210
So there is a loop where uh your

375
00:13:06,210 --> 00:13:07,369
application has to talk to LLM.

376
00:13:07,889 --> 00:13:09,940
And LLM has to respond and you have to

377
00:13:09,940 --> 00:13:10,879
feed or

378
00:13:11,279 --> 00:13:12,519
update new context.

379
00:13:13,058 --> 00:13:15,158
Now, I, I heard

380
00:13:15,158 --> 00:13:17,359
about step functions. Like if you can do this in

381
00:13:17,359 --> 00:13:18,779
step functions, right, in a workflow.

382
00:13:19,200 --> 00:13:21,349
In a workflow, if you want to build this, these are

383
00:13:21,349 --> 00:13:22,308
multiple steps.

384
00:13:22,599 --> 00:13:25,019
The most important part is the

385
00:13:25,200 --> 00:13:27,139
choice state here, if you can see

386
00:13:27,519 --> 00:13:28,379
the choice state.

387
00:13:29,129 --> 00:13:31,239
So every time a tool is executed, you

388
00:13:31,239 --> 00:13:33,080
have to figure out in the choice state,

389
00:13:33,418 --> 00:13:34,308
like which

390
00:13:34,609 --> 00:13:36,889
uh tool to use and programmatically

391
00:13:36,889 --> 00:13:38,489
you have to go and execute that tool,

392
00:13:38,889 --> 00:13:40,349
feed that information back

393
00:13:40,710 --> 00:13:42,729
to the model so that loop continues

394
00:13:42,729 --> 00:13:43,710
in a recursive manner,

395
00:13:44,168 --> 00:13:46,168
right? So we

396
00:13:46,168 --> 00:13:47,229
see this as a pattern.

397
00:13:48,259 --> 00:13:50,460
Right, you can do the same thing with lambda functions also

398
00:13:50,460 --> 00:13:51,889
instead of using a step function,

399
00:13:52,219 --> 00:13:54,340
if you want to write that code in a lambda function, you can

400
00:13:54,340 --> 00:13:56,500
do that, uh, but overall we

401
00:13:56,500 --> 00:13:58,879
see this pattern that we have

402
00:13:59,129 --> 00:14:01,538
lambda functions, step functions, or your

403
00:14:01,538 --> 00:14:03,729
application code that is running in,

404
00:14:03,739 --> 00:14:05,519
uh, Fargate or EKS.

405
00:14:05,899 --> 00:14:07,899
It has to follow the same pattern like calling

406
00:14:07,899 --> 00:14:10,158
LLM, calling tools, and it has to go in a loop,

407
00:14:10,580 --> 00:14:12,700
right? So that is the pattern that

408
00:14:12,700 --> 00:14:14,029
we have to build on top of it.

409
00:14:14,418 --> 00:14:16,460
But let's see what are the benefits of this pattern.

410
00:14:17,250 --> 00:14:19,340
If you go with this tool use with lambda

411
00:14:19,340 --> 00:14:20,700
functions or step functions,

412
00:14:21,219 --> 00:14:23,239
you can call the existing APIs.

413
00:14:23,259 --> 00:14:24,609
If you take Amazon Bedrock,

414
00:14:25,058 --> 00:14:27,580
you can call Converse API, invoke API

415
00:14:27,580 --> 00:14:29,739
from those uh services

416
00:14:29,739 --> 00:14:31,779
like lambda functions, and step functions

417
00:14:31,779 --> 00:14:34,190
as native integrations with Bedrock API.

418
00:14:35,548 --> 00:14:37,629
But the important part is the choice

419
00:14:37,629 --> 00:14:38,690
state that I highlighted.

420
00:14:39,580 --> 00:14:41,918
You have to imperatively write the code

421
00:14:42,460 --> 00:14:44,558
to actually figure out which tool to use,

422
00:14:44,820 --> 00:14:46,239
right? So that's

423
00:14:46,739 --> 00:14:47,820
a thing to remember here.

424
00:14:48,759 --> 00:14:50,759
That allows you to

425
00:14:50,759 --> 00:14:53,219
build predefined paths for execution,

426
00:14:53,440 --> 00:14:55,509
so. In, in

427
00:14:55,509 --> 00:14:57,989
most of the cases you'll, you'll have to create a workflow

428
00:14:57,989 --> 00:15:00,070
to create the predefined paths. But what

429
00:15:00,070 --> 00:15:00,729
if you want,

430
00:15:01,308 --> 00:15:03,859
uh, a workflow or a, or a

431
00:15:03,869 --> 00:15:04,969
process or a loop where

432
00:15:05,308 --> 00:15:07,308
things can change dynamically based

433
00:15:07,308 --> 00:15:08,450
on the new context,

434
00:15:08,869 --> 00:15:11,070
right? In this case, if you have to change

435
00:15:11,070 --> 00:15:13,349
anything in the step function, you have to add a new branch

436
00:15:13,349 --> 00:15:14,450
to the choice state

437
00:15:14,750 --> 00:15:16,469
and build,

438
00:15:16,788 --> 00:15:17,769
develop, uh,

439
00:15:18,058 --> 00:15:20,109
test and then deploy and then make the changes,

440
00:15:20,190 --> 00:15:22,509
right? So that's a key thing to remember.

441
00:15:23,080 --> 00:15:25,440
Is there a better way to handle this tight

442
00:15:25,440 --> 00:15:27,759
coupling? So if you think about it, there is a tight coupling,

443
00:15:27,879 --> 00:15:30,080
right? You, whatever branches

444
00:15:30,080 --> 00:15:32,158
you have from Choice State, those are the ones that

445
00:15:32,158 --> 00:15:33,000
will be executed,

446
00:15:33,359 --> 00:15:35,639
and that is how much you are limited with the LLMC

447
00:15:35,639 --> 00:15:36,168
users.

448
00:15:36,759 --> 00:15:38,960
So how can we make it better so that you don't

449
00:15:38,960 --> 00:15:40,200
have the tight coupling,

450
00:15:40,599 --> 00:15:41,149
but

451
00:15:41,719 --> 00:15:44,460
automatically that code execution happens

452
00:15:44,798 --> 00:15:46,840
based on which is the right tool that LLM

453
00:15:46,840 --> 00:15:47,639
talks about,

454
00:15:48,000 --> 00:15:50,000
right? That's where agents

455
00:15:50,000 --> 00:15:50,798
come into the picture.

456
00:15:51,820 --> 00:15:54,369
So the, the drastic difference between

457
00:15:54,369 --> 00:15:56,070
you writing the imperative code.

458
00:15:57,298 --> 00:15:59,359
Compared to what an agent can do,

459
00:15:59,700 --> 00:16:01,739
is the agent has the innate capability

460
00:16:01,739 --> 00:16:03,918
of figuring out which tool to invoke without

461
00:16:03,918 --> 00:16:04,940
you writing the choice date.

462
00:16:05,918 --> 00:16:08,000
So, here is an agent example

463
00:16:08,000 --> 00:16:09,168
where we use strands agent.

464
00:16:09,840 --> 00:16:11,619
Anybody using strands agent yet?

465
00:16:12,080 --> 00:16:12,639
OK, cool.

466
00:16:12,979 --> 00:16:15,119
Strands agent is uh open source

467
00:16:15,119 --> 00:16:16,609
uh strand agent SDK

468
00:16:17,229 --> 00:16:19,139
which we announced a couple of months ago.

469
00:16:19,969 --> 00:16:22,119
Uh, and, uh, that's an easy way to get

470
00:16:22,119 --> 00:16:23,710
started and we'll see how it works.

471
00:16:24,210 --> 00:16:26,450
So now the question is, how should I develop an agent?

472
00:16:27,250 --> 00:16:29,288
Right, we talk, we know how to build lambda functions,

473
00:16:29,408 --> 00:16:30,129
the functions,

474
00:16:30,489 --> 00:16:31,928
but how should I develop an agent?

475
00:16:32,369 --> 00:16:34,710
It's as simple as running another library.

476
00:16:34,849 --> 00:16:37,000
You want to run in a lambda function or

477
00:16:37,000 --> 00:16:37,928
any other compute.

478
00:16:38,489 --> 00:16:39,859
So strands agent is a,

479
00:16:40,168 --> 00:16:42,649
it's a very lightweight open source SDK

480
00:16:42,649 --> 00:16:43,658
to build agents,

481
00:16:44,048 --> 00:16:46,070
and the most important part

482
00:16:46,330 --> 00:16:48,609
that is critical to SRN's agent

483
00:16:48,609 --> 00:16:50,619
is it is model driven

484
00:16:51,009 --> 00:16:53,250
and it relies on the agentic loop capability

485
00:16:53,250 --> 00:16:55,308
that he and I have been talking about.

486
00:16:55,570 --> 00:16:56,548
We'll see how it works.

487
00:16:57,080 --> 00:16:58,469
But how to get started?

488
00:16:58,849 --> 00:17:00,849
With strands agent, you get started very

489
00:17:00,849 --> 00:17:02,928
simple and in a couple of lines. This is

490
00:17:02,928 --> 00:17:03,869
a Python code

491
00:17:04,328 --> 00:17:06,410
where you import strands agent as the library.

492
00:17:07,088 --> 00:17:09,289
You import some tools. There are some

493
00:17:09,289 --> 00:17:11,039
predefined tools that you can import.

494
00:17:11,489 --> 00:17:13,608
You can define an agent like it is

495
00:17:13,608 --> 00:17:15,229
done here, and you can

496
00:17:15,689 --> 00:17:17,750
uh provide a prompt to the agent.

497
00:17:18,250 --> 00:17:20,608
Now, one thing that you don't see here is I have not mentioned

498
00:17:20,608 --> 00:17:21,630
about the LLM.

499
00:17:22,660 --> 00:17:25,259
So Strans agent has this opinionated

500
00:17:25,259 --> 00:17:26,039
way of using

501
00:17:26,539 --> 00:17:28,799
a particular LLM on Bedrock.

502
00:17:29,299 --> 00:17:31,380
If you don't provide that, if you want to experiment, you

503
00:17:31,380 --> 00:17:32,989
can easily start with this,

504
00:17:33,338 --> 00:17:35,479
and it uses a particular model. I think it uses

505
00:17:35,479 --> 00:17:37,689
clots on it 4.5 right now on

506
00:17:37,689 --> 00:17:38,199
Bedrock,

507
00:17:38,500 --> 00:17:40,578
but this is an executable code right now. If

508
00:17:40,578 --> 00:17:42,699
I want to run this as a Python class, it'll

509
00:17:42,699 --> 00:17:43,939
run and give me a response.

510
00:17:45,299 --> 00:17:47,140
Now, how would the order agent look like?

511
00:17:47,500 --> 00:17:48,719
So I showed the

512
00:17:49,469 --> 00:17:51,838
step functions, uh, workflow that was the order agent,

513
00:17:51,910 --> 00:17:54,059
uh sorry, order, orders workflow.

514
00:17:54,539 --> 00:17:56,689
If I want to run the same thing in, uh,

515
00:17:56,699 --> 00:17:58,779
strands agent STK for orders, this is

516
00:17:58,779 --> 00:18:01,098
how it would look like in a single Python class.

517
00:18:02,309 --> 00:18:04,390
First, you import the standards agent from

518
00:18:04,390 --> 00:18:06,390
the SDK. And then if

519
00:18:06,390 --> 00:18:08,390
you see, the most important part here is I

520
00:18:08,390 --> 00:18:10,239
have just Python methods here,

521
00:18:10,750 --> 00:18:12,828
and they are decorated with tools.

522
00:18:13,818 --> 00:18:16,309
And that decorator is from StransAgen,

523
00:18:16,699 --> 00:18:17,618
which means

524
00:18:17,939 --> 00:18:20,250
you can make any of your Python

525
00:18:20,250 --> 00:18:22,459
methods act as tools when

526
00:18:22,459 --> 00:18:23,588
you're working with Stran's agent,

527
00:18:24,380 --> 00:18:26,719
right? And then you create a

528
00:18:26,719 --> 00:18:27,549
voter session,

529
00:18:28,150 --> 00:18:30,430
define which uh region you want to operate

530
00:18:30,709 --> 00:18:32,529
or use, define the model.

531
00:18:32,989 --> 00:18:35,039
In this case, I'm going one step ahead instead of

532
00:18:35,039 --> 00:18:37,189
relying on the default model selection

533
00:18:37,189 --> 00:18:39,348
that stands as, I want to go and use cloud

534
00:18:39,348 --> 00:18:40,309
Haiku 4.5.

535
00:18:41,059 --> 00:18:43,059
And I define the token counts, I defined

536
00:18:43,059 --> 00:18:43,779
the session,

537
00:18:44,140 --> 00:18:45,318
and now I have everything.

538
00:18:45,618 --> 00:18:48,868
I create the agent and if you see line number 111,

539
00:18:49,180 --> 00:18:51,259
I'm providing all the tools which are

540
00:18:51,259 --> 00:18:52,959
just the method names that I have

541
00:18:53,410 --> 00:18:54,680
defined up above,

542
00:18:55,059 --> 00:18:56,338
and then I call the agent.

543
00:18:57,328 --> 00:18:57,848
So,

544
00:18:58,170 --> 00:19:00,170
the drastic difference between the workflow

545
00:19:00,170 --> 00:19:01,368
and this one

546
00:19:01,769 --> 00:19:03,890
is in nowhere in this

547
00:19:03,890 --> 00:19:04,890
code I have

548
00:19:05,209 --> 00:19:07,328
written an if then else logic or a switch

549
00:19:07,328 --> 00:19:09,608
statement. Which means

550
00:19:10,269 --> 00:19:10,848
when

551
00:19:11,150 --> 00:19:13,309
the new context comes or the responses

552
00:19:13,309 --> 00:19:14,588
come from LLM,

553
00:19:15,118 --> 00:19:17,189
the agent's responsibility is to figure

554
00:19:17,189 --> 00:19:19,608
out whether it has to call, get orders detail

555
00:19:20,108 --> 00:19:22,309
or get invoice or start refund

556
00:19:22,309 --> 00:19:23,729
process in whichever order

557
00:19:24,068 --> 00:19:25,150
it has to be invoked,

558
00:19:25,630 --> 00:19:27,630
so there is no imperative code. So we

559
00:19:27,630 --> 00:19:29,650
move from writing imperative code

560
00:19:29,989 --> 00:19:31,368
to actually agent

561
00:19:32,140 --> 00:19:33,650
working in a declarative manner

562
00:19:33,910 --> 00:19:34,868
and getting things done.

563
00:19:36,549 --> 00:19:37,108
So

564
00:19:37,880 --> 00:19:39,709
That's one of the major benefits.

565
00:19:40,009 --> 00:19:40,930
Let's see what else.

566
00:19:41,650 --> 00:19:43,390
Uh, you get in-built error handling.

567
00:19:43,969 --> 00:19:46,049
All the best practices of how agents should

568
00:19:46,049 --> 00:19:48,209
work is available in strands agent

569
00:19:48,209 --> 00:19:50,439
STK, and this is not limited to strands

570
00:19:50,439 --> 00:19:52,519
agent. You can experiment with

571
00:19:52,519 --> 00:19:54,848
any agentic framework, but strands agent,

572
00:19:54,969 --> 00:19:56,108
uh, is something that

573
00:19:56,449 --> 00:19:58,789
I love to work with. It's very lightweight, so

574
00:19:58,930 --> 00:20:00,430
it's, it's very easy to work with,

575
00:20:01,049 --> 00:20:03,130
uh, and then most important part is

576
00:20:03,130 --> 00:20:05,289
model and compute agnostic, which

577
00:20:05,289 --> 00:20:07,318
means. I used Bedrock

578
00:20:07,318 --> 00:20:09,400
model, but strands allows you

579
00:20:09,400 --> 00:20:10,029
to

580
00:20:10,410 --> 00:20:12,410
work with any model provider, not

581
00:20:12,410 --> 00:20:13,910
just Bedrock. It can be

582
00:20:14,289 --> 00:20:16,328
anthropic directly, it can be OpenAI

583
00:20:16,328 --> 00:20:18,489
directly, it can be a model that is running

584
00:20:18,489 --> 00:20:19,568
on Sagemaker as well.

585
00:20:20,699 --> 00:20:23,269
Plus, since it is just an SDK

586
00:20:23,269 --> 00:20:24,809
you can run it in any compute.

587
00:20:25,088 --> 00:20:27,368
It can be a lambda function, it can be

588
00:20:27,368 --> 00:20:29,400
uh Fargate, it can be EKs,

589
00:20:29,410 --> 00:20:31,348
or it can be on your EC2s.

590
00:20:32,150 --> 00:20:34,209
So, that is the important part.

591
00:20:34,588 --> 00:20:36,709
Finally, as I mentioned earlier, the major

592
00:20:36,709 --> 00:20:37,469
comparison

593
00:20:37,920 --> 00:20:40,739
is instead of writing imperative workflows,

594
00:20:41,108 --> 00:20:43,189
which are kind of tightly coupled based on

595
00:20:43,189 --> 00:20:44,049
the use case,

596
00:20:45,009 --> 00:20:47,430
This is much more declarative. So you can define

597
00:20:47,430 --> 00:20:49,509
a new tool by writing a new method

598
00:20:49,509 --> 00:20:50,588
and provide that

599
00:20:51,049 --> 00:20:53,118
tool in the agent uh array, tools

600
00:20:53,118 --> 00:20:55,358
array, and then you're done. And the LLM

601
00:20:55,358 --> 00:20:57,509
and agent will work together to figure out which

602
00:20:57,509 --> 00:20:59,269
tool to invoke in which order.

603
00:21:00,170 --> 00:21:02,289
So now that we have a good understanding

604
00:21:02,289 --> 00:21:04,509
of how a single agent as a unit

605
00:21:05,269 --> 00:21:06,549
of work can be built,

606
00:21:06,848 --> 00:21:08,779
we have to figure out how can you run

607
00:21:09,328 --> 00:21:10,670
those agents at scale

608
00:21:11,170 --> 00:21:13,170
because at the end of the day when you run it in production,

609
00:21:13,250 --> 00:21:14,449
it will not be one

610
00:21:14,719 --> 00:21:16,029
agent running in your machine,

611
00:21:16,358 --> 00:21:18,368
it has to be multiple agents and multiple

612
00:21:18,368 --> 00:21:19,348
tools. So

613
00:21:19,729 --> 00:21:21,809
when you want to run agents and tools at

614
00:21:21,809 --> 00:21:22,430
scale,

615
00:21:23,130 --> 00:21:25,410
this kind of chaos is what you will aim

616
00:21:25,410 --> 00:21:26,269
for or look for,

617
00:21:26,529 --> 00:21:28,650
right? Uh, the reason I say

618
00:21:28,650 --> 00:21:30,848
chaos is because we have

619
00:21:30,848 --> 00:21:33,328
seen the world when it comes from monolithic to microservices,

620
00:21:33,338 --> 00:21:34,789
and we found a way how to build

621
00:21:35,328 --> 00:21:36,689
and operate microservices.

622
00:21:37,539 --> 00:21:39,539
So, there will be agents in

623
00:21:39,539 --> 00:21:41,549
your department, your agents, there'll be

624
00:21:41,549 --> 00:21:43,660
tools that you want to use, which are

625
00:21:43,660 --> 00:21:44,680
very local to you.

626
00:21:45,608 --> 00:21:47,750
There will be agents and tools in your organization.

627
00:21:48,640 --> 00:21:50,680
And there will be agents and tools that

628
00:21:50,680 --> 00:21:52,430
are externally available

629
00:21:52,969 --> 00:21:55,039
at the end of the day you don't want to repeat yourself,

630
00:21:55,108 --> 00:21:57,279
right? If you have tools that are working for you,

631
00:21:57,489 --> 00:21:59,910
your agents should be able to invoke those tools

632
00:22:00,400 --> 00:22:02,689
instead of you creating those uh tools again.

633
00:22:03,088 --> 00:22:05,088
So this is how a production, uh, set

634
00:22:05,088 --> 00:22:06,789
up would look like. Our goal is to

635
00:22:07,088 --> 00:22:07,868
be here

636
00:22:08,130 --> 00:22:09,469
and then run at scale.

637
00:22:09,890 --> 00:22:12,118
So for that we have some standards

638
00:22:12,118 --> 00:22:13,449
that we can rely on

639
00:22:13,818 --> 00:22:16,199
and make agents work with tools and,

640
00:22:16,209 --> 00:22:18,130
uh, other agents, uh.

641
00:22:19,049 --> 00:22:19,650
Seamlessly.

642
00:22:20,338 --> 00:22:21,068
So let's see.

643
00:22:21,799 --> 00:22:23,140
Again, going back to this,

644
00:22:23,439 --> 00:22:25,479
my agent can call a tool

645
00:22:25,479 --> 00:22:26,680
that is inside the department.

646
00:22:27,348 --> 00:22:29,430
Uh, my agent would also need to call a tool

647
00:22:29,430 --> 00:22:30,338
in the organization,

648
00:22:30,828 --> 00:22:32,868
and it can also call, it should be

649
00:22:32,868 --> 00:22:34,868
able to call an external tool. So how do

650
00:22:34,868 --> 00:22:35,969
we make this work?

651
00:22:36,549 --> 00:22:38,549
If we don't use any standards, the

652
00:22:38,549 --> 00:22:40,719
agent and tool integration would look like

653
00:22:40,719 --> 00:22:42,489
this. You have agents.

654
00:22:43,338 --> 00:22:44,838
And if I have to

655
00:22:45,098 --> 00:22:45,838
use

656
00:22:46,779 --> 00:22:48,900
a tool that is supported only

657
00:22:48,900 --> 00:22:49,739
for SQL

658
00:22:50,059 --> 00:22:51,729
or it's a database-specific tool,

659
00:22:51,989 --> 00:22:54,019
then the agent has to write a SQL or has

660
00:22:54,019 --> 00:22:55,019
to support SQL.

661
00:22:55,459 --> 00:22:57,809
And that's the standard of the protocol that has to

662
00:22:57,809 --> 00:22:59,539
be used to integrate with the database.

663
00:23:00,568 --> 00:23:02,959
If the agent has to work with a graphQL

664
00:23:02,959 --> 00:23:05,059
endpoint, then agent has to learn how

665
00:23:05,059 --> 00:23:06,439
what graphQL is

666
00:23:06,900 --> 00:23:09,150
and has to integrate with the graphQL endpoint.

667
00:23:09,420 --> 00:23:10,959
Same with restful endpoints.

668
00:23:11,459 --> 00:23:13,500
So now you can see what is happening. So

669
00:23:13,500 --> 00:23:15,568
agent builders who are building agents,

670
00:23:15,939 --> 00:23:18,019
they are responsible for supporting all those

671
00:23:18,019 --> 00:23:19,078
different protocols,

672
00:23:19,390 --> 00:23:21,459
right? And on the tool side,

673
00:23:21,529 --> 00:23:23,160
whoever is building tools,

674
00:23:23,539 --> 00:23:24,400
they are restricted

675
00:23:24,779 --> 00:23:26,779
to the scope of tool vendors. So if a vendor

676
00:23:26,779 --> 00:23:29,279
is only specifically working on databases.

677
00:23:30,019 --> 00:23:31,598
They have to now think about

678
00:23:32,140 --> 00:23:34,410
their user user bases to grow, their agent,

679
00:23:34,650 --> 00:23:36,910
uh, clients to grow. They have to support

680
00:23:36,910 --> 00:23:38,039
GraphQL or,

681
00:23:38,338 --> 00:23:40,479
uh, Rest Endpoint, whatever. So

682
00:23:40,739 --> 00:23:42,939
it, you can see there is a tight coupling

683
00:23:42,939 --> 00:23:45,630
happening when you think about different protocols

684
00:23:46,059 --> 00:23:48,219
and where agents have to work with

685
00:23:48,219 --> 00:23:49,029
different tools.

686
00:23:49,500 --> 00:23:51,660
Those different, uh, entities, the agent

687
00:23:51,660 --> 00:23:53,900
builders and the tool builders have to

688
00:23:53,900 --> 00:23:55,989
support different ways of communicating, and

689
00:23:55,989 --> 00:23:56,880
that's how they can.

690
00:23:57,650 --> 00:23:58,449
Operate together.

691
00:23:59,229 --> 00:24:00,338
So that's a tight coupling.

692
00:24:01,108 --> 00:24:02,328
And that's where

693
00:24:02,910 --> 00:24:03,608
anthropic.

694
00:24:04,549 --> 00:24:05,809
Came up with MCP.

695
00:24:06,890 --> 00:24:08,368
Has anybody heard about MCP

696
00:24:09,088 --> 00:24:10,170
Model context protocol?

697
00:24:10,848 --> 00:24:12,689
So what it does, it

698
00:24:13,049 --> 00:24:15,250
actually unifies all of those different

699
00:24:15,250 --> 00:24:17,400
standards and says, OK, you don't have to use different

700
00:24:17,400 --> 00:24:19,068
standards when you want to have agent

701
00:24:19,368 --> 00:24:20,108
to tool

702
00:24:20,529 --> 00:24:21,568
uh integration

703
00:24:21,930 --> 00:24:23,868
we'll use MCP as the protocol.

704
00:24:24,729 --> 00:24:26,809
For that you need an MCP client which will be

705
00:24:26,809 --> 00:24:27,848
used by the agent

706
00:24:28,170 --> 00:24:30,170
and an MCP server that has to be hosted by

707
00:24:30,170 --> 00:24:31,568
the tool provider.

708
00:24:32,328 --> 00:24:33,630
So now what happens,

709
00:24:34,118 --> 00:24:36,410
the agent builders will only need to support a single

710
00:24:36,410 --> 00:24:37,549
standard, that is MCP.

711
00:24:38,420 --> 00:24:40,588
And the tool builders or the tool providers

712
00:24:40,588 --> 00:24:41,868
will have to make sure

713
00:24:42,189 --> 00:24:44,180
that whatever capability they have

714
00:24:44,588 --> 00:24:46,890
is exposed as an MCP server

715
00:24:47,000 --> 00:24:48,348
or MCP capability,

716
00:24:48,630 --> 00:24:50,630
right? So how does it look like in

717
00:24:50,630 --> 00:24:51,568
the agency loop

718
00:24:51,949 --> 00:24:54,380
whenever you have agents calling tools,

719
00:24:54,868 --> 00:24:56,809
the agent will work as an MCP client

720
00:24:57,509 --> 00:24:59,618
and the tool providers will have, uh,

721
00:24:59,630 --> 00:25:02,009
will call it as, uh, will be the MCP servers.

722
00:25:03,519 --> 00:25:04,608
So a single

723
00:25:05,068 --> 00:25:07,489
MCP client, a simple MCP client

724
00:25:07,489 --> 00:25:09,709
using Strand's agent would look like this.

725
00:25:11,209 --> 00:25:13,400
Now, if you see here, I have uh imported

726
00:25:13,400 --> 00:25:15,410
strands agent and MCP client

727
00:25:15,410 --> 00:25:16,279
from strands agent

728
00:25:16,930 --> 00:25:19,088
because strands Agent supports MCP client

729
00:25:19,088 --> 00:25:19,618
uh

730
00:25:20,009 --> 00:25:20,868
like natively.

731
00:25:21,588 --> 00:25:23,289
And if you see line number 5,

732
00:25:23,549 --> 00:25:25,549
actually I'm calling an external

733
00:25:25,549 --> 00:25:27,789
or remote MCP server.

734
00:25:28,618 --> 00:25:29,959
Whose job is to go and

735
00:25:30,259 --> 00:25:32,348
uh scrape the web. It's a

736
00:25:32,348 --> 00:25:34,500
web crawler and it should give some

737
00:25:34,500 --> 00:25:35,318
responses back.

738
00:25:35,818 --> 00:25:38,160
And then I get all the tools that the

739
00:25:38,259 --> 00:25:39,680
MCP server has to offer.

740
00:25:40,180 --> 00:25:42,219
I provide that tool to the agent and I ask

741
00:25:42,219 --> 00:25:43,279
a simple question

742
00:25:43,739 --> 00:25:45,858
like what are the top 5 best rated cities

743
00:25:45,858 --> 00:25:48,019
in the USA group by breweries?

744
00:25:49,068 --> 00:25:51,078
And provide the answer in a tabular form.

745
00:25:51,439 --> 00:25:52,578
Anybody from Denver here?

746
00:25:54,009 --> 00:25:54,549
No one?

747
00:25:55,130 --> 00:25:57,170
OK. Because Denver always comes up in

748
00:25:57,170 --> 00:25:57,750
the top,

749
00:25:58,549 --> 00:25:59,868
in the, when it comes to

750
00:26:00,160 --> 00:26:01,289
uh top 5 breweries.

751
00:26:02,029 --> 00:26:04,118
OK, so this is the answer, and I

752
00:26:04,118 --> 00:26:06,019
executed this as just a Python,

753
00:26:06,318 --> 00:26:07,519
ah, class.

754
00:26:08,259 --> 00:26:09,358
And uh

755
00:26:09,818 --> 00:26:12,259
you can see where I've highlighted it executed

756
00:26:12,259 --> 00:26:14,489
the tool that is provided by the remote MCP

757
00:26:14,489 --> 00:26:15,000
server

758
00:26:15,699 --> 00:26:17,818
and it provided the response. It's

759
00:26:17,818 --> 00:26:19,809
scraped through different uh pages

760
00:26:20,259 --> 00:26:22,269
provided the response in a table or format.

761
00:26:22,500 --> 00:26:24,660
So this is a simple example of invoking remote

762
00:26:24,660 --> 00:26:25,858
MCP servers.

763
00:26:26,809 --> 00:26:29,189
Now, if you are building MCP servers,

764
00:26:29,848 --> 00:26:30,509
excuse me,

765
00:26:31,130 --> 00:26:33,170
how would it look like from a MCP server

766
00:26:33,170 --> 00:26:34,410
or a tool provider side?

767
00:26:35,309 --> 00:26:37,719
Uh, the easy way to start building an MCP

768
00:26:37,719 --> 00:26:39,529
server is using fast MCP.

769
00:26:40,380 --> 00:26:41,269
You can import

770
00:26:41,598 --> 00:26:44,150
fast MCP and create a basic

771
00:26:44,420 --> 00:26:46,420
uh fast MCP server. In, in this

772
00:26:46,420 --> 00:26:48,420
case, I'm just creating a math server which

773
00:26:48,420 --> 00:26:50,799
just does the addition of two numbers,

774
00:26:51,259 --> 00:26:53,118
and I've defined these are the tools.

775
00:26:53,400 --> 00:26:55,559
One of the tools is adding two numbers,

776
00:26:56,219 --> 00:26:58,479
and I've decorated that as MCP tool

777
00:26:59,019 --> 00:27:01,358
and I'm just running that MCP server

778
00:27:02,199 --> 00:27:04,098
uh at port 8000.

779
00:27:05,410 --> 00:27:07,229
And when I try to run this up, the

780
00:27:07,568 --> 00:27:09,868
server comes up, it's uh up and ready,

781
00:27:10,049 --> 00:27:12,239
and it should be able to take calls from MCP

782
00:27:12,239 --> 00:27:15,039
clients. OK,

783
00:27:15,229 --> 00:27:17,348
so now we saw from the MCP client side

784
00:27:17,348 --> 00:27:19,750
how should you be building MCP clients, the MCP

785
00:27:19,750 --> 00:27:20,549
server side

786
00:27:21,500 --> 00:27:23,868
where uh the tool providers should be uh building MCP

787
00:27:23,868 --> 00:27:24,469
servers.

788
00:27:24,868 --> 00:27:27,630
So coming back to the same, uh,

789
00:27:27,750 --> 00:27:29,449
uh, running at scale in production,

790
00:27:30,019 --> 00:27:32,170
this is how we ended up with any tool

791
00:27:32,170 --> 00:27:33,910
communication that happens from agent.

792
00:27:34,969 --> 00:27:37,269
Will be over MCP as a protocol,

793
00:27:37,449 --> 00:27:38,068
a standard.

794
00:27:38,969 --> 00:27:39,959
But what if

795
00:27:40,279 --> 00:27:42,039
an agent wants to talk to an agent?

796
00:27:43,250 --> 00:27:45,289
Right? So there can be

797
00:27:45,289 --> 00:27:47,539
a case where agents will try to communicate

798
00:27:47,539 --> 00:27:48,410
with an agent

799
00:27:48,809 --> 00:27:49,719
instead of a tool.

800
00:27:50,098 --> 00:27:52,299
Let's see what happens if we do the same thing

801
00:27:52,299 --> 00:27:53,068
without a standard.

802
00:27:54,160 --> 00:27:56,160
And go from there. So let's go back to the

803
00:27:56,160 --> 00:27:57,900
same use case. Like I was charged twice.

804
00:27:58,828 --> 00:28:01,459
And I have an order agent that is run on strands,

805
00:28:01,559 --> 00:28:02,799
which is an MCP client.

806
00:28:03,118 --> 00:28:05,189
It has its own tool. It talks to its

807
00:28:05,189 --> 00:28:07,390
LLM. It is an agentic loop.

808
00:28:07,588 --> 00:28:09,709
Think of that orange dotted boundary.

809
00:28:09,759 --> 00:28:10,500
It's the,

810
00:28:10,890 --> 00:28:13,160
uh, is the bounded context of orders

811
00:28:13,160 --> 00:28:13,939
agent, right?

812
00:28:14,640 --> 00:28:16,828
Now, in order to get a proper refund

813
00:28:16,828 --> 00:28:18,868
or payments or has to work with the payment

814
00:28:18,868 --> 00:28:21,039
domain. That has the same

815
00:28:21,039 --> 00:28:23,140
setup. Or a similar setup

816
00:28:23,140 --> 00:28:24,000
with an agent

817
00:28:24,459 --> 00:28:26,578
talking to an LLM and a bunch of

818
00:28:26,578 --> 00:28:28,209
tools that are specific to payments.

819
00:28:28,699 --> 00:28:30,880
Now, if I don't use any standard, then

820
00:28:30,880 --> 00:28:33,019
the order agent has to directly talk to the

821
00:28:33,019 --> 00:28:34,239
tools that it is in the

822
00:28:34,779 --> 00:28:35,759
payments domain,

823
00:28:36,338 --> 00:28:37,199
which means

824
00:28:39,130 --> 00:28:40,430
We see a scope creep.

825
00:28:41,049 --> 00:28:42,949
Now the order agent has to understand

826
00:28:43,368 --> 00:28:45,368
what are the tools available in payments domain. So if

827
00:28:45,368 --> 00:28:46,358
you think about it,

828
00:28:46,769 --> 00:28:49,049
this is the same, we are, we are back to square

829
00:28:49,049 --> 00:28:51,088
one when we think about domain-driven design and

830
00:28:51,088 --> 00:28:53,088
building microservices. I think everybody here

831
00:28:53,088 --> 00:28:54,150
will be aware of,

832
00:28:54,729 --> 00:28:56,769
uh, domain-driven design and why should we think about

833
00:28:56,769 --> 00:28:58,439
bounding bounded context.

834
00:28:58,729 --> 00:28:59,650
So there is a scope creep.

835
00:29:01,209 --> 00:29:03,209
You run tools from different domains, so you don't

836
00:29:03,209 --> 00:29:05,328
know. Our order agent will not know

837
00:29:05,328 --> 00:29:07,328
what tools it has to get from payments

838
00:29:07,328 --> 00:29:09,568
domain, what are the authentication and authorization

839
00:29:09,568 --> 00:29:10,818
requirements it has to work through.

840
00:29:11,818 --> 00:29:14,130
There is an ownership leakage because payments

841
00:29:14,130 --> 00:29:16,380
domain has to own its tool

842
00:29:16,380 --> 00:29:17,559
and somehow has to

843
00:29:17,979 --> 00:29:20,019
make sure that it is exposed to other agents

844
00:29:20,019 --> 00:29:20,680
in a way

845
00:29:21,098 --> 00:29:21,680
without,

846
00:29:22,098 --> 00:29:24,459
uh, without other agents directly invoking

847
00:29:24,459 --> 00:29:25,739
the tools, if you think about it.

848
00:29:26,578 --> 00:29:29,078
Last but not the least, if payments agent

849
00:29:29,078 --> 00:29:30,039
is actually

850
00:29:30,328 --> 00:29:32,449
continuously revising its tools or how to

851
00:29:32,449 --> 00:29:33,289
work with tools,

852
00:29:33,618 --> 00:29:35,759
then the order agent has to keep up. Otherwise,

853
00:29:36,750 --> 00:29:38,029
It it might fail.

854
00:29:39,469 --> 00:29:41,469
So how would it look like if we

855
00:29:41,469 --> 00:29:43,949
go one step up and do interagent communication

856
00:29:43,949 --> 00:29:46,269
with MCP because we figured out MCP

857
00:29:46,269 --> 00:29:47,170
is a standard

858
00:29:47,588 --> 00:29:49,630
and an agent can talk to tools,

859
00:29:50,068 --> 00:29:52,068
why not the payment agent work as a

860
00:29:52,068 --> 00:29:53,309
tool for orders agent?

861
00:29:54,309 --> 00:29:56,430
Right? That's doable. It's

862
00:29:56,430 --> 00:29:57,949
better than not having a standard.

863
00:29:59,559 --> 00:30:01,559
Because it relies on MCP as

864
00:30:01,559 --> 00:30:02,338
the protocol.

865
00:30:03,390 --> 00:30:05,509
But the payment agent is used as a

866
00:30:05,509 --> 00:30:07,729
tool. Which means

867
00:30:07,910 --> 00:30:09,880
the audit agent has to discover

868
00:30:10,309 --> 00:30:12,449
what this agent is capable of

869
00:30:12,828 --> 00:30:14,828
or what are the tools that are available

870
00:30:14,828 --> 00:30:17,068
for this agent, and the agent should

871
00:30:17,068 --> 00:30:19,189
somehow be able to figure out, hey, I

872
00:30:19,189 --> 00:30:21,410
have tools A, B, C to work with.

873
00:30:22,029 --> 00:30:24,489
Reach out to me using MCP and I'll have to delegate

874
00:30:24,989 --> 00:30:26,890
all of my MCP calls to my tools.

875
00:30:28,180 --> 00:30:28,920
And then,

876
00:30:29,818 --> 00:30:30,568
if you look at it,

877
00:30:30,858 --> 00:30:31,630
the MCP,

878
00:30:31,930 --> 00:30:34,299
uh, sorry, payments agent must act as an MCP

879
00:30:34,299 --> 00:30:36,180
server for orders agent,

880
00:30:36,578 --> 00:30:38,699
and it has to act as an MCP client for its

881
00:30:38,699 --> 00:30:39,598
own tools,

882
00:30:40,140 --> 00:30:42,150
right? Can we do it better?

883
00:30:43,039 --> 00:30:45,269
That's where Google came up with agent to agent,

884
00:30:45,358 --> 00:30:46,029
which is A2A.

885
00:30:46,789 --> 00:30:49,130
It's a standardized protocol for AI agents.

886
00:30:50,019 --> 00:30:52,059
To discover capabilities of existing

887
00:30:52,059 --> 00:30:54,098
or other agents, exchange

888
00:30:54,098 --> 00:30:56,809
task, and collaborate on complex workflows.

889
00:30:57,279 --> 00:30:59,338
We'll see how it would look like, uh, if you want to

890
00:30:59,338 --> 00:31:00,279
start building with

891
00:31:00,539 --> 00:31:02,809
8W. If you take orders agent

892
00:31:02,809 --> 00:31:03,739
and payments agent,

893
00:31:05,068 --> 00:31:07,289
The first thing that the order agent will ask payment

894
00:31:07,289 --> 00:31:07,910
agent,

895
00:31:08,430 --> 00:31:10,289
uh, if payment agent is the A2A server,

896
00:31:10,868 --> 00:31:13,380
is give me your capabilities, give me your agent

897
00:31:13,380 --> 00:31:13,890
card,

898
00:31:14,309 --> 00:31:16,469
and the agent card will have all the details, the

899
00:31:16,469 --> 00:31:18,769
name, the version, the description of the agent,

900
00:31:19,269 --> 00:31:20,449
and the skills.

901
00:31:20,868 --> 00:31:23,049
The agent will have skills and capabilities,

902
00:31:23,229 --> 00:31:24,088
and that

903
00:31:24,390 --> 00:31:26,709
is kind of abstracting of how this agent

904
00:31:26,709 --> 00:31:28,229
works with its own tools.

905
00:31:28,930 --> 00:31:30,650
From those skills and capabilities,

906
00:31:30,930 --> 00:31:33,098
capabilities and what are the supported mo

907
00:31:33,098 --> 00:31:34,439
modalities,

908
00:31:34,890 --> 00:31:37,130
what are the ways to authenticate and

909
00:31:37,130 --> 00:31:37,709
authorize,

910
00:31:38,088 --> 00:31:40,150
all of those will be present in the model card.

911
00:31:41,160 --> 00:31:43,479
Now the order agent has the model card. It

912
00:31:43,479 --> 00:31:45,789
can figure out how to work with the agent.

913
00:31:46,199 --> 00:31:48,439
It'll create a task for the payments

914
00:31:48,439 --> 00:31:50,779
agent. And then it'll

915
00:31:50,779 --> 00:31:52,930
process the task. In the meantime,

916
00:31:53,390 --> 00:31:55,539
if there is more information required from

917
00:31:55,539 --> 00:31:58,098
the payments agent as an A2A server or

918
00:31:58,098 --> 00:32:00,170
from the order agent as an A2A client,

919
00:32:00,578 --> 00:32:01,920
they'll be able to communicate.

920
00:32:02,858 --> 00:32:03,799
And finally,

921
00:32:04,098 --> 00:32:06,209
the results will be returned back to the order

922
00:32:06,209 --> 00:32:06,739
agent.

923
00:32:07,789 --> 00:32:10,199
OK So now evolving

924
00:32:10,199 --> 00:32:11,019
from just using

925
00:32:11,439 --> 00:32:12,420
MCP

926
00:32:13,078 --> 00:32:15,098
this is how it will look like if you

927
00:32:15,108 --> 00:32:15,900
use A2A.

928
00:32:16,838 --> 00:32:19,118
So it's similar to the concept of

929
00:32:19,890 --> 00:32:22,269
Uh, using choreography for

930
00:32:22,769 --> 00:32:25,009
in between domains and orchestration

931
00:32:25,009 --> 00:32:26,848
inside your domain, so

932
00:32:27,250 --> 00:32:29,250
it has MCP you're using MCP when

933
00:32:29,250 --> 00:32:31,068
the agent has to talk to a tool

934
00:32:31,650 --> 00:32:33,650
and you're using A2A when the

935
00:32:33,650 --> 00:32:35,368
agent has to talk to an agent.

936
00:32:35,809 --> 00:32:36,890
So what are the improvements?

937
00:32:37,608 --> 00:32:39,660
Now your payments agent has,

938
00:32:39,670 --> 00:32:41,358
uh, it's like it is,

939
00:32:41,729 --> 00:32:44,410
it is a specialized agent and it has capabilities

940
00:32:44,410 --> 00:32:46,269
to do everything that it has to do

941
00:32:46,608 --> 00:32:48,650
related to uh payments and

942
00:32:48,650 --> 00:32:50,088
exposes an agent card.

943
00:32:51,088 --> 00:32:53,239
Now, the payment agent doesn't leak the

944
00:32:53,239 --> 00:32:54,309
domain knowledge

945
00:32:54,969 --> 00:32:57,170
because the agent card is taking

946
00:32:57,170 --> 00:32:57,789
care of how

947
00:32:58,368 --> 00:33:00,729
external agents should be interacting with payments agent.

948
00:33:01,549 --> 00:33:02,219
And then

949
00:33:02,559 --> 00:33:03,269
the A2A

950
00:33:03,559 --> 00:33:05,618
as a as a standard as a protocol,

951
00:33:05,920 --> 00:33:07,739
it supports both sync

952
00:33:08,000 --> 00:33:10,088
and async communications

953
00:33:10,519 --> 00:33:12,098
so it can happen where

954
00:33:12,479 --> 00:33:15,019
the payments agent can asynchronously

955
00:33:15,019 --> 00:33:17,318
call or send some responses and

956
00:33:17,318 --> 00:33:18,439
order agent can

957
00:33:18,959 --> 00:33:20,959
provide a web hook or something and it can

958
00:33:20,959 --> 00:33:23,000
get that information back without waiting

959
00:33:23,000 --> 00:33:24,500
on payments agent response.

960
00:33:25,000 --> 00:33:27,039
OK, so this is an overall picture of

961
00:33:27,039 --> 00:33:28,838
how agent to agent will work.

962
00:33:29,299 --> 00:33:32,000
Now can we go one level up? Can we bring

963
00:33:32,420 --> 00:33:34,739
event driven with A2A and MCP?

964
00:33:35,670 --> 00:33:36,890
I'll go back to the same

965
00:33:37,838 --> 00:33:39,578
Uh, example, like

966
00:33:39,930 --> 00:33:40,699
you have.

967
00:33:41,489 --> 00:33:43,608
This is where we left off in the previous slide, like

968
00:33:43,608 --> 00:33:45,709
the agentic loop of orders agent and payments

969
00:33:45,709 --> 00:33:46,250
agent

970
00:33:46,729 --> 00:33:49,509
and A2A for interagent communication

971
00:33:49,848 --> 00:33:51,969
and MCP for communication

972
00:33:51,969 --> 00:33:53,299
inside the domain,

973
00:33:53,608 --> 00:33:55,650
and we have this, uh, request coming

974
00:33:55,650 --> 00:33:57,670
in that I was charged twice for my order.

975
00:33:58,049 --> 00:34:00,150
Can we use event driven architecture? I

976
00:34:00,608 --> 00:34:01,549
believe we can.

977
00:34:02,239 --> 00:34:04,289
And that will allow you to

978
00:34:04,289 --> 00:34:05,449
get more benefits.

979
00:34:05,809 --> 00:34:06,449
What if

980
00:34:06,769 --> 00:34:08,769
that request comes as an API

981
00:34:08,769 --> 00:34:11,050
call and you have an event

982
00:34:11,050 --> 00:34:13,070
producer that accepts that API call

983
00:34:13,688 --> 00:34:15,639
with a standpoint and lambda functions

984
00:34:16,250 --> 00:34:18,500
and then they emit events to even broker

985
00:34:18,500 --> 00:34:19,369
like even Bridge.

986
00:34:20,179 --> 00:34:22,458
Now you have an event going to

987
00:34:22,458 --> 00:34:24,519
orders agent saying that order support

988
00:34:24,519 --> 00:34:26,659
placed. Order

989
00:34:26,659 --> 00:34:28,938
agent can work with payments agent

990
00:34:28,938 --> 00:34:30,969
using A2A

991
00:34:31,418 --> 00:34:33,349
and using MCP for its own

992
00:34:33,860 --> 00:34:35,898
work and then ultimately send an event

993
00:34:35,898 --> 00:34:38,059
back saying that the order support is completed.

994
00:34:39,329 --> 00:34:41,369
Now that event can be captured by the

995
00:34:41,369 --> 00:34:43,628
broker again, and now I have

996
00:34:44,050 --> 00:34:46,309
another event consumer whose work

997
00:34:46,648 --> 00:34:48,898
is to notify the end user,

998
00:34:49,369 --> 00:34:51,389
which can use WebSocket and Lambda and then

999
00:34:51,389 --> 00:34:53,550
ultimately notify the end user.

1000
00:34:54,958 --> 00:34:57,188
So, what is the benefit of using this?

1001
00:34:57,280 --> 00:34:59,590
We talked about MCP, we talked about A2L

1002
00:34:59,590 --> 00:35:01,269
standard, but why EDA?

1003
00:35:02,219 --> 00:35:03,619
Why even driven architecture?

1004
00:35:04,139 --> 00:35:06,269
So the main benefits is that

1005
00:35:06,418 --> 00:35:08,619
it applies to every application that we built

1006
00:35:08,619 --> 00:35:09,300
using EDA.

1007
00:35:10,070 --> 00:35:11,489
It's loose coupling.

1008
00:35:12,148 --> 00:35:14,550
So when you bring loose coupling with intelligent

1009
00:35:14,550 --> 00:35:15,489
coordination,

1010
00:35:15,989 --> 00:35:17,849
you build something really powerful.

1011
00:35:18,739 --> 00:35:20,599
The agent is autonomously working

1012
00:35:20,938 --> 00:35:22,478
and it is doing its work

1013
00:35:22,938 --> 00:35:25,199
and at the same time you have

1014
00:35:25,418 --> 00:35:27,449
the capability of emitting events to

1015
00:35:27,449 --> 00:35:29,619
the agent and not wait for the agent to

1016
00:35:29,619 --> 00:35:30,780
send responses back,

1017
00:35:31,219 --> 00:35:33,079
which means you can scale

1018
00:35:33,500 --> 00:35:34,280
really well

1019
00:35:34,659 --> 00:35:36,938
without depending on or failing

1020
00:35:36,938 --> 00:35:37,860
when the agent fails.

1021
00:35:39,438 --> 00:35:41,639
You can get context of event handling.

1022
00:35:41,719 --> 00:35:43,800
So MCP provides a standardized way for

1023
00:35:43,800 --> 00:35:44,780
agents to access

1024
00:35:45,239 --> 00:35:46,639
contextual information

1025
00:35:46,958 --> 00:35:49,500
when it comes to databases, APIs, etc.

1026
00:35:50,000 --> 00:35:52,478
but an agent receiving a, a

1027
00:35:52,478 --> 00:35:53,760
customer inquiry event

1028
00:35:54,059 --> 00:35:56,530
can automatically fetch those contexts,

1029
00:35:56,840 --> 00:35:57,898
and it can work

1030
00:35:58,398 --> 00:35:59,938
independently of other agents.

1031
00:36:00,559 --> 00:36:02,579
As I mentioned, you can scale agents,

1032
00:36:02,628 --> 00:36:03,820
uh, because

1033
00:36:04,519 --> 00:36:06,739
the event that we talked about order,

1034
00:36:06,840 --> 00:36:08,659
uh, placed, order support placed.

1035
00:36:09,168 --> 00:36:11,510
I just showed you the order agent

1036
00:36:11,510 --> 00:36:13,849
working, but what if there are different

1037
00:36:13,849 --> 00:36:16,128
other agents that are actually working on that

1038
00:36:16,128 --> 00:36:18,309
event? They can start working

1039
00:36:18,309 --> 00:36:20,309
on that particular event type

1040
00:36:20,889 --> 00:36:21,429
without

1041
00:36:21,849 --> 00:36:23,958
touching on order agent or without.

1042
00:36:25,000 --> 00:36:27,148
Doing anything with agents, so you can parallel

1043
00:36:27,148 --> 00:36:28,659
invoke different agents

1044
00:36:29,039 --> 00:36:31,000
when it comes to event-driven architecture.

1045
00:36:32,389 --> 00:36:34,628
The other important aspect is the asynchronous

1046
00:36:34,628 --> 00:36:35,889
intelligence. So

1047
00:36:36,590 --> 00:36:38,750
when something happened in your inside your

1048
00:36:38,750 --> 00:36:39,610
system, when

1049
00:36:40,269 --> 00:36:42,429
something happens in this, for example, let's

1050
00:36:42,429 --> 00:36:44,369
say a support ticket was created

1051
00:36:44,708 --> 00:36:47,148
or a payment was asked or

1052
00:36:47,148 --> 00:36:48,809
a misplaced order,

1053
00:36:49,309 --> 00:36:50,969
when you convert that to an event.

1054
00:36:51,869 --> 00:36:53,929
You don't have to invoke an agent

1055
00:36:54,019 --> 00:36:56,389
synchronously anymore because now that

1056
00:36:56,389 --> 00:36:58,429
event will be actually invoking

1057
00:36:58,429 --> 00:36:59,409
or the agent will

1058
00:36:59,750 --> 00:37:01,969
come back to life when the event is received.

1059
00:37:02,478 --> 00:37:04,510
So it can work asynchronously and do

1060
00:37:04,510 --> 00:37:06,668
some lot of intelligent automation for you.

1061
00:37:08,449 --> 00:37:09,269
Overall,

1062
00:37:09,969 --> 00:37:12,128
you get observability and auditability

1063
00:37:12,128 --> 00:37:14,369
because when you use an event broker, you are capturing

1064
00:37:14,369 --> 00:37:16,340
all the events that are going to the broker.

1065
00:37:16,929 --> 00:37:18,550
And if an agent fails,

1066
00:37:18,969 --> 00:37:20,969
you can replay those events and you

1067
00:37:20,969 --> 00:37:23,030
can retrigger those agents and make it

1068
00:37:23,030 --> 00:37:25,469
work. So that's another capability.

1069
00:37:25,769 --> 00:37:28,289
And it's resilient because uh

1070
00:37:28,289 --> 00:37:29,610
it's decoupled

1071
00:37:29,889 --> 00:37:32,128
and if if the payment agent fails

1072
00:37:32,128 --> 00:37:34,208
or if the order agent fails, you'll still

1073
00:37:34,208 --> 00:37:35,329
be getting those events.

1074
00:37:35,599 --> 00:37:37,418
And you can gracefully degrade by

1075
00:37:37,949 --> 00:37:40,059
bringing up another agent or another application

1076
00:37:40,059 --> 00:37:41,679
to work on those events.

1077
00:37:42,449 --> 00:37:43,750
So overall

1078
00:37:44,010 --> 00:37:45,550
these are the

1079
00:37:46,409 --> 00:37:48,949
benefits of using all those open standards

1080
00:37:49,250 --> 00:37:50,628
with event driven architecture.

1081
00:37:50,889 --> 00:37:52,708
If you have to add a new agent,

1082
00:37:53,010 --> 00:37:55,168
you don't have to touch anything around what you

1083
00:37:55,168 --> 00:37:57,289
have already set up. Like if you, if you

1084
00:37:57,289 --> 00:37:58,648
see the, if you,

1085
00:37:58,969 --> 00:38:01,110
if I want to add a new agent to this setup

1086
00:38:01,570 --> 00:38:03,869
which has to work on the order support placed event,

1087
00:38:04,010 --> 00:38:05,478
I don't have to touch anything here.

1088
00:38:06,409 --> 00:38:08,648
I'll just add that agent, subscribe to the new

1089
00:38:08,648 --> 00:38:10,099
event, and keep on going.

1090
00:38:10,530 --> 00:38:11,128
So my.

1091
00:38:11,780 --> 00:38:13,898
Like a blast radius will be smaller. I don't

1092
00:38:13,898 --> 00:38:14,800
have to test everything.

1093
00:38:15,800 --> 00:38:17,898
Cool. So now that we

1094
00:38:17,898 --> 00:38:19,239
know how you build

1095
00:38:20,019 --> 00:38:22,329
the patterns, even even architectures,

1096
00:38:22,398 --> 00:38:23,699
the standards, etc.

1097
00:38:24,099 --> 00:38:26,139
the next question is how will I run it on

1098
00:38:26,139 --> 00:38:26,820
AWS,

1099
00:38:27,179 --> 00:38:28,360
and that's where I have

1100
00:38:28,739 --> 00:38:29,260
Higgy

1101
00:38:29,539 --> 00:38:32,119
to talk more about how can you deploy agents

1102
00:38:32,219 --> 00:38:34,570
and tools and on soveless

1103
00:38:34,570 --> 00:38:36,110
compute. Cool,

1104
00:38:36,958 --> 00:38:39,110
thank you. Far

1105
00:38:39,110 --> 00:38:41,309
we talked about uh tool calls

1106
00:38:41,309 --> 00:38:43,458
and these agentic frameworks. This allows

1107
00:38:43,458 --> 00:38:45,750
us to use the LLM to reason

1108
00:38:45,750 --> 00:38:47,780
through completing these tasks or requests on

1109
00:38:47,780 --> 00:38:49,090
behalf of your end users.

1110
00:38:49,478 --> 00:38:51,510
Um, we also want to then use

1111
00:38:51,510 --> 00:38:53,510
these agentic frameworks and these tool calls to be able to

1112
00:38:53,510 --> 00:38:55,550
get additional data context so

1113
00:38:55,550 --> 00:38:57,590
that the LLM has the

1114
00:38:57,590 --> 00:38:59,648
appropriate amount of information

1115
00:38:59,869 --> 00:39:01,989
to adequately process whatever this request

1116
00:39:01,989 --> 00:39:02,500
might be,

1117
00:39:03,599 --> 00:39:05,750
uh, and then Diraj talked about a bunch of these open standards, ways

1118
00:39:05,750 --> 00:39:06,409
that we can.

1119
00:39:06,728 --> 00:39:09,019
Uh, make sure that, uh, developers of different

1120
00:39:09,019 --> 00:39:11,378
teams are doing this in a uniform way

1121
00:39:11,378 --> 00:39:13,458
that makes it simpler for you to then operate

1122
00:39:13,458 --> 00:39:14,679
in production. So

1123
00:39:15,059 --> 00:39:17,219
let's think through a little bit of how we then do

1124
00:39:17,219 --> 00:39:19,409
this using some serverless capabilities

1125
00:39:19,409 --> 00:39:21,458
here on AWS. And so we're gonna think

1126
00:39:21,458 --> 00:39:23,469
through some patterns here. We're gonna go through

1127
00:39:23,469 --> 00:39:24,978
servalus functions with lambda.

1128
00:39:25,369 --> 00:39:27,668
We'll do some, uh, servalus containers with,

1129
00:39:27,688 --> 00:39:29,909
uh, Fargate, and then of course we'll do a quick,

1130
00:39:29,938 --> 00:39:32,128
uh, dive into Agent Corp which went

1131
00:39:32,128 --> 00:39:33,389
GA about a month or two ago,

1132
00:39:33,809 --> 00:39:35,969
and we'll, we'll look through some of these, uh, deployment

1133
00:39:35,969 --> 00:39:38,010
patterns and how you can actually apply this into

1134
00:39:38,010 --> 00:39:38,789
your organization.

1135
00:39:40,059 --> 00:39:42,090
Before we do that, let's take a quick high level view

1136
00:39:42,090 --> 00:39:44,500
of like what does it look like as a developer

1137
00:39:44,500 --> 00:39:46,500
as you're building out these capabilities, and the

1138
00:39:46,500 --> 00:39:48,668
first thing is that foundation capability

1139
00:39:48,668 --> 00:39:50,699
which Draj spent a bunch of time talking through

1140
00:39:50,699 --> 00:39:52,829
is you can select whatever agentic

1141
00:39:52,829 --> 00:39:54,840
framework you're gonna use. Of course here at AWS

1142
00:39:54,840 --> 00:39:56,860
we love strands, but we've also seen some

1143
00:39:56,860 --> 00:39:58,918
of our customers choose, uh, alternate

1144
00:39:59,070 --> 00:40:00,260
open source frameworks.

1145
00:40:00,889 --> 00:40:03,019
And the beauty here is that you can take whatever

1146
00:40:03,019 --> 00:40:05,090
framework that you're going to use again I'll just talk about

1147
00:40:05,090 --> 00:40:05,800
strands

1148
00:40:06,139 --> 00:40:07,688
and you can develop that locally,

1149
00:40:07,978 --> 00:40:09,418
do a lot of testing locally,

1150
00:40:09,750 --> 00:40:12,059
then you can package it up in whatever

1151
00:40:12,059 --> 00:40:14,059
artifact is required for your compute target,

1152
00:40:14,070 --> 00:40:15,679
which we're going to talk about momentarily,

1153
00:40:16,168 --> 00:40:18,340
so you have that same experience of developing

1154
00:40:18,340 --> 00:40:20,530
locally and also deploying

1155
00:40:20,530 --> 00:40:21,418
into production.

1156
00:40:22,128 --> 00:40:24,179
And then of course when you're then exposing these

1157
00:40:24,179 --> 00:40:26,579
whether that's these are in private VPCs

1158
00:40:26,579 --> 00:40:28,699
again maybe you have a a requirement that's internal

1159
00:40:28,699 --> 00:40:30,699
only I think we were talking about that earlier with some of the

1160
00:40:30,699 --> 00:40:31,309
audience

1161
00:40:31,619 --> 00:40:33,898
where you have internal only private network

1162
00:40:33,898 --> 00:40:36,208
capabilities or maybe you're actually providing

1163
00:40:36,208 --> 00:40:38,659
this as a service to your end customers so

1164
00:40:38,659 --> 00:40:40,938
necessarily these become public endpoints, right?

1165
00:40:40,949 --> 00:40:43,090
And so if you're gonna be doing this with Fargate,

1166
00:40:43,139 --> 00:40:45,438
of course you're gonna perhaps use an ALB

1167
00:40:45,489 --> 00:40:47,519
and that will become the ingress mechanism

1168
00:40:47,860 --> 00:40:49,938
for all requests coming into uh

1169
00:40:49,938 --> 00:40:51,099
your agent application.

1170
00:40:51,739 --> 00:40:53,739
How you'll be exposing that in this scenario is

1171
00:40:53,739 --> 00:40:56,360
just gonna be as a simple HTTP web interface.

1172
00:40:57,059 --> 00:40:59,300
Now if you're gonna be doing this with lambda, perhaps

1173
00:40:59,300 --> 00:41:01,110
you're gonna have API gateway in front of it.

1174
00:41:01,378 --> 00:41:03,579
You're gonna have all of the nice things that API gateway

1175
00:41:03,579 --> 00:41:05,719
provides you like an authorizer, WAF integration,

1176
00:41:05,938 --> 00:41:07,398
cloud front integration, etc.

1177
00:41:07,938 --> 00:41:10,188
And now what you'll use is you're gonna use that lambda

1178
00:41:10,188 --> 00:41:11,398
handler that we love

1179
00:41:11,659 --> 00:41:14,179
and integrate that with that HTTP interface

1180
00:41:14,179 --> 00:41:15,478
for your agentic application.

1181
00:41:16,478 --> 00:41:18,750
And then last but not least, we'll cover a little bit of Agent

1182
00:41:18,750 --> 00:41:19,340
Core in a moment.

1183
00:41:20,219 --> 00:41:22,438
Where that is similar to your

1184
00:41:22,438 --> 00:41:24,539
Fargate scenario where you're gonna have your

1185
00:41:24,539 --> 00:41:26,780
regular agent application uh with

1186
00:41:26,780 --> 00:41:29,139
Agent Corp then we're gonna actually just use imports

1187
00:41:29,139 --> 00:41:31,139
and dependencies and then we're gonna actually do a

1188
00:41:31,139 --> 00:41:33,219
little bit of annotation which, which again we're gonna

1189
00:41:33,219 --> 00:41:34,579
show you momentarily.

1190
00:41:34,860 --> 00:41:37,219
The beauty here is that these are all different

1191
00:41:37,219 --> 00:41:39,010
options depending on what your organization

1192
00:41:39,590 --> 00:41:41,199
uh necessarily requires

1193
00:41:41,530 --> 00:41:43,579
uh you know I've talked to some customers where some of them say,

1194
00:41:43,619 --> 00:41:45,699
you know what, all of our artifacts are gonna be

1195
00:41:45,699 --> 00:41:47,719
container artifacts because we've built out

1196
00:41:48,019 --> 00:41:50,050
um our. CI pipelines to

1197
00:41:50,050 --> 00:41:52,208
do all of our testing, security scanning, all

1198
00:41:52,208 --> 00:41:54,728
of the governance mechanisms based on a container-based

1199
00:41:54,728 --> 00:41:55,418
artifact.

1200
00:41:55,728 --> 00:41:57,929
Um, if that's the case, then you may actually

1201
00:41:57,929 --> 00:41:59,929
make, uh, certain choices about how you're

1202
00:41:59,929 --> 00:42:01,469
going to be deploying your artifacts.

1203
00:42:01,929 --> 00:42:04,090
Uh, alternatively, if you love lambda and you

1204
00:42:04,090 --> 00:42:06,128
love that zip artifact deployment, that could

1205
00:42:06,128 --> 00:42:08,409
be one, approach that you're gonna be using, and we're gonna

1206
00:42:08,409 --> 00:42:09,679
talk through some of these patterns,

1207
00:42:10,050 --> 00:42:11,530
uh, and we'll go through these, um.

1208
00:42:12,099 --> 00:42:14,099
One by one, so of course the first one

1209
00:42:14,099 --> 00:42:16,099
would be if you're using ECS Fargate

1210
00:42:16,300 --> 00:42:18,389
again you have a pipeline based on containers

1211
00:42:18,699 --> 00:42:20,898
again you're gonna standardize on ECR or

1212
00:42:20,898 --> 00:42:23,039
elastic container, uh, repository.

1213
00:42:23,500 --> 00:42:25,570
So your agent application again you're gonna

1214
00:42:25,570 --> 00:42:27,648
build that Docker file. You'll then bundle that

1215
00:42:27,648 --> 00:42:29,070
as a container image locally,

1216
00:42:29,418 --> 00:42:31,539
push that into your ECR image, uh, into

1217
00:42:31,539 --> 00:42:33,820
your ECR repository, and then deploy

1218
00:42:33,820 --> 00:42:35,938
that into, uh, Fargate

1219
00:42:35,938 --> 00:42:38,139
right with the ELB ALB in front of it.

1220
00:42:38,369 --> 00:42:40,688
And in this scenario it's just that like

1221
00:42:40,688 --> 00:42:42,728
Draj had shared before, this is that fast

1222
00:42:42,728 --> 00:42:44,728
API and strands application or

1223
00:42:44,728 --> 00:42:46,208
maybe that fast MCP application.

1224
00:42:47,938 --> 00:42:50,059
Next, of course then is as this audience is

1225
00:42:50,059 --> 00:42:52,099
probably familiar with, as your lambda function

1226
00:42:52,099 --> 00:42:54,719
you have both your zip and container deployment artifact,

1227
00:42:55,019 --> 00:42:57,139
and this then allows you to give, get that

1228
00:42:57,139 --> 00:42:59,478
API gateway to lambda

1229
00:42:59,719 --> 00:43:01,458
um deployment architecture.

1230
00:43:03,329 --> 00:43:05,329
You can similarly do the same thing

1231
00:43:05,329 --> 00:43:07,378
if you're doing MCP servers. So we

1232
00:43:07,378 --> 00:43:08,559
spent a bunch of time

1233
00:43:09,099 --> 00:43:11,179
talking about agentic frameworks, whether you're using

1234
00:43:11,179 --> 00:43:12,199
strands or otherwise.

1235
00:43:12,579 --> 00:43:14,840
You could do similar again. Dras showed an example

1236
00:43:14,840 --> 00:43:16,889
of being able to do these MCP servers

1237
00:43:16,889 --> 00:43:19,010
as well. That same architecture can actually

1238
00:43:19,010 --> 00:43:21,219
apply in this serverless paradigm. So

1239
00:43:21,219 --> 00:43:23,539
again, whether you're doing it with API gateway and lambda.

1240
00:43:23,934 --> 00:43:26,304
Again you have those same artifacts or

1241
00:43:26,304 --> 00:43:28,425
you can uh do that into your Far gate.

1242
00:43:28,704 --> 00:43:30,784
So the nice thing again here is that uh you

1243
00:43:30,784 --> 00:43:32,864
have that local developer experience building out

1244
00:43:32,864 --> 00:43:33,764
that framework

1245
00:43:34,054 --> 00:43:36,144
again with your local MTP servers. You could

1246
00:43:36,144 --> 00:43:38,405
then do things like MTP Inspector to connect

1247
00:43:38,405 --> 00:43:40,523
to that MTP server locally

1248
00:43:40,704 --> 00:43:43,043
and to do some amount of testing before you do

1249
00:43:43,184 --> 00:43:43,985
that deployment.

1250
00:43:45,750 --> 00:43:47,989
Um, Similarly, so Draz shared

1251
00:43:47,989 --> 00:43:50,148
before about that order, uh, and, and

1252
00:43:50,148 --> 00:43:51,668
payments agent scenario.

1253
00:43:52,039 --> 00:43:54,148
So if we're gonna actually apply that scenario and

1254
00:43:54,148 --> 00:43:56,389
do this now with API gateway and lambda

1255
00:43:56,389 --> 00:43:58,510
with all of these serviceless capabilities that we already

1256
00:43:58,510 --> 00:44:00,969
love in this scenario, the order agent,

1257
00:44:01,039 --> 00:44:02,829
uh, acts as the um.

1258
00:44:03,398 --> 00:44:04,148
As the client,

1259
00:44:04,570 --> 00:44:06,728
uh, to the payments agent, so you can

1260
00:44:06,728 --> 00:44:07,469
imagine having

1261
00:44:07,809 --> 00:44:09,949
just a client that connects to the uh

1262
00:44:09,949 --> 00:44:12,010
API gateway endpoint for the payments agent,

1263
00:44:12,250 --> 00:44:13,628
and that then acts as the A

1264
00:44:14,099 --> 00:44:14,849
A to A server.

1265
00:44:15,280 --> 00:44:17,559
So across domains across these bounded contexts,

1266
00:44:17,809 --> 00:44:19,889
you have these API calls that are going

1267
00:44:19,889 --> 00:44:22,070
from, you know, the A to A client in the order agent

1268
00:44:22,070 --> 00:44:22,949
lambda function

1269
00:44:23,320 --> 00:44:25,688
to the API gateway endpoint in

1270
00:44:25,688 --> 00:44:26,728
the payments agent.

1271
00:44:27,030 --> 00:44:29,139
And again, as Draja then mentioned, if you want to make

1272
00:44:29,139 --> 00:44:30,610
these internal tool calls,

1273
00:44:30,898 --> 00:44:33,208
again, these can just be MCP calls

1274
00:44:33,219 --> 00:44:35,500
from that each of the respective lambda functions.

1275
00:44:35,780 --> 00:44:37,820
So you can imagine the order function. I've written some

1276
00:44:37,820 --> 00:44:38,500
of my code,

1277
00:44:38,780 --> 00:44:39,820
the code that

1278
00:44:40,228 --> 00:44:42,438
Draj was showing before in my lambda function

1279
00:44:42,619 --> 00:44:44,780
has that MCP client makes those tool

1280
00:44:44,780 --> 00:44:46,869
calls within the order

1281
00:44:46,869 --> 00:44:48,898
domain, similarly on the payments

1282
00:44:48,898 --> 00:44:49,958
agent side as well.

1283
00:44:51,570 --> 00:44:53,688
So the nice thing is that we're going to be applying all

1284
00:44:53,688 --> 00:44:55,719
of these servius deployment capabilities and

1285
00:44:55,719 --> 00:44:58,039
using those open standards that

1286
00:44:58,039 --> 00:44:59,559
Draj had already been talking about.

1287
00:45:00,780 --> 00:45:02,898
So uh we talked about all of the

1288
00:45:02,898 --> 00:45:04,958
things that we already love oner lists. Um,

1289
00:45:05,619 --> 00:45:07,860
another option that you have then is can

1290
00:45:07,860 --> 00:45:10,039
we do this at a higher level of abstraction?

1291
00:45:10,139 --> 00:45:12,208
Can we have some more fully managed services?

1292
00:45:12,418 --> 00:45:14,500
And this is where Agent Core comes into the play, and we'll

1293
00:45:14,500 --> 00:45:16,119
do a quick primer here

1294
00:45:16,458 --> 00:45:18,458
again. There are gonna be a lot more sessions here at Reinvent where

1295
00:45:18,458 --> 00:45:19,559
you can go a lot deeper.

1296
00:45:19,969 --> 00:45:21,978
Um, there are kind of a, a suite

1297
00:45:21,978 --> 00:45:24,099
of services, uh, that are available to

1298
00:45:24,099 --> 00:45:24,760
you to make

1299
00:45:25,019 --> 00:45:26,559
the deployment of your agents easier.

1300
00:45:26,860 --> 00:45:29,219
The first, of course, is Agent Corp runtime. Agent

1301
00:45:29,219 --> 00:45:31,378
Corps run time is really your erless compute

1302
00:45:31,739 --> 00:45:33,050
for running your agents,

1303
00:45:33,340 --> 00:45:35,418
um, and this allows you to again, again bring

1304
00:45:35,418 --> 00:45:36,559
any open source framework

1305
00:45:36,898 --> 00:45:38,039
against strands or otherwise.

1306
00:45:38,500 --> 00:45:40,438
It can interact with any model again

1307
00:45:40,780 --> 00:45:42,860
we of course here prefer you to do it at Bedrock, but

1308
00:45:42,860 --> 00:45:45,228
you can then choose any other, uh, provider

1309
00:45:45,228 --> 00:45:46,958
for your, uh, for your models.

1310
00:45:48,239 --> 00:45:49,438
There's an Asian Core Gateway,

1311
00:45:49,739 --> 00:45:52,110
perhaps a little bit analogous to API gateway,

1312
00:45:52,438 --> 00:45:54,579
but Asian Core Gateway is built specifically

1313
00:45:54,579 --> 00:45:56,840
as a tool aggregator, right, so

1314
00:45:56,840 --> 00:45:59,139
this becomes your similar with API gateway

1315
00:45:59,478 --> 00:46:01,519
you use API gateway as the front end for all of your

1316
00:46:01,519 --> 00:46:02,280
APIs.

1317
00:46:02,728 --> 00:46:04,809
Agent Core Gateway becomes the front end for all of your

1318
00:46:04,809 --> 00:46:05,349
tools,

1319
00:46:05,610 --> 00:46:08,010
um, so it provides very similar, uh, capabilities

1320
00:46:08,010 --> 00:46:10,188
around, uh, off and,

1321
00:46:10,199 --> 00:46:11,228
uh, a lot of the

1322
00:46:11,530 --> 00:46:13,530
that front end capability. It also allows you

1323
00:46:13,530 --> 00:46:15,949
to do things as both public tools

1324
00:46:16,250 --> 00:46:18,260
or private tools. So a lot of those

1325
00:46:18,260 --> 00:46:20,829
same capabilities that you expected out of API gateway

1326
00:46:21,079 --> 00:46:23,128
are there available in Asian Corre Gateway.

1327
00:46:24,550 --> 00:46:26,789
Um, these are the some of the managed

1328
00:46:26,789 --> 00:46:27,648
tools. So again,

1329
00:46:28,418 --> 00:46:30,800
Dra showed, uh, like the calculator tool example,

1330
00:46:31,070 --> 00:46:33,090
um, common use cases that we see

1331
00:46:33,090 --> 00:46:35,188
for people who are building agentic applications

1332
00:46:35,188 --> 00:46:37,300
and the type of tools that they need. Again,

1333
00:46:37,418 --> 00:46:39,889
Dra showed that browser one with uh the Denver,

1334
00:46:39,898 --> 00:46:40,978
uh, pub breweries,

1335
00:46:41,340 --> 00:46:42,878
uh, but also there's code interpreter.

1336
00:46:43,159 --> 00:46:44,639
Uh, we've seen a lot of customers who say

1337
00:46:45,059 --> 00:46:47,139
we're gonna use these LLMs to actually generate

1338
00:46:47,139 --> 00:46:49,119
code on behalf on my behalf. However,

1339
00:46:49,699 --> 00:46:52,139
given that this is generated code, it is untrusted

1340
00:46:52,139 --> 00:46:54,539
code not written by your developers. You don't

1341
00:46:54,539 --> 00:46:56,260
necessarily wanna run this in your,

1342
00:46:56,579 --> 00:46:58,659
uh, that has exposure to the rest of your

1343
00:46:58,659 --> 00:47:00,820
production environment. So we've seen a lot of our customers

1344
00:47:00,820 --> 00:47:03,168
say we wanna run untrusted code in

1345
00:47:03,168 --> 00:47:05,260
an isolated environment that has no access

1346
00:47:05,260 --> 00:47:06,739
to any of my other production data.

1347
00:47:07,188 --> 00:47:09,728
Uh, code interpreter is, is a managed capability

1348
00:47:10,110 --> 00:47:12,168
that gives you, uh, isolation of

1349
00:47:12,168 --> 00:47:13,728
running, uh, untrusted code.

1350
00:47:14,349 --> 00:47:16,349
So those, those are just some of the managed tools that are

1351
00:47:16,349 --> 00:47:17,250
available to you.

1352
00:47:17,750 --> 00:47:20,139
Um, then of course there's agent core identity. One of the

1353
00:47:20,139 --> 00:47:22,148
biggest things that Draj and I, as we talk to our

1354
00:47:22,148 --> 00:47:24,679
customers around agents and even MCP

1355
00:47:24,909 --> 00:47:27,188
is around what are the security implications of

1356
00:47:27,188 --> 00:47:28,539
building out these agents.

1357
00:47:28,829 --> 00:47:31,228
How do we ensure that if, if my customer

1358
00:47:31,228 --> 00:47:33,389
support agent representative is making this request

1359
00:47:33,389 --> 00:47:34,668
to my agenttic application.

1360
00:47:35,030 --> 00:47:36,869
And then is making downstream tool calls.

1361
00:47:37,168 --> 00:47:39,329
How do I ensure that, uh, that

1362
00:47:39,329 --> 00:47:41,599
agent is not as uh elevating privileges,

1363
00:47:41,849 --> 00:47:44,010
is not getting access to data that he or she

1364
00:47:44,010 --> 00:47:45,059
should not have access to.

1365
00:47:45,369 --> 00:47:47,489
And so agent core identity is one of those mechanisms

1366
00:47:47,489 --> 00:47:49,570
that simplifies the chaining of these

1367
00:47:49,570 --> 00:47:50,188
calls

1368
00:47:50,449 --> 00:47:51,269
so that, um,

1369
00:47:51,530 --> 00:47:53,809
the original principle or the original

1370
00:47:53,809 --> 00:47:56,010
user making these calls, uh, that

1371
00:47:56,010 --> 00:47:57,148
identity, uh,

1372
00:47:57,530 --> 00:47:59,849
or that those permissions are propagated

1373
00:47:59,849 --> 00:48:01,889
down even down to the tool calls.

1374
00:48:03,349 --> 00:48:05,398
Uh, and then of course we didn't, we're not gonna

1375
00:48:05,398 --> 00:48:07,478
cover this in much depth, but as you continue to

1376
00:48:07,478 --> 00:48:09,228
build out these agentic applications,

1377
00:48:09,599 --> 00:48:11,000
uh, what we're starting to see is, you know,

1378
00:48:11,309 --> 00:48:13,438
we talked a bunch about how do we provide context

1379
00:48:13,438 --> 00:48:15,599
to the framework, how do we ensure that it has the appropriate

1380
00:48:15,599 --> 00:48:16,500
level of data.

1381
00:48:17,030 --> 00:48:19,389
Well, there's also that chat interaction um

1382
00:48:19,389 --> 00:48:21,550
that you have with your identity application so you can

1383
00:48:21,550 --> 00:48:23,728
imagine I'm a customer support representative

1384
00:48:24,110 --> 00:48:26,579
you know Higgy just gave this um

1385
00:48:26,579 --> 00:48:28,829
this support ticket around, you know, this order

1386
00:48:28,829 --> 00:48:30,949
that was uh double charged did

1387
00:48:30,949 --> 00:48:32,949
not ship all my items, and I need it

1388
00:48:32,949 --> 00:48:33,780
by tomorrow.

1389
00:48:34,110 --> 00:48:36,409
You can imagine perhaps I had a prior

1390
00:48:36,409 --> 00:48:38,769
uh support session where I was talking about

1391
00:48:39,019 --> 00:48:41,099
uh. Issue I had perhaps with payments maybe

1392
00:48:41,099 --> 00:48:42,820
there was an issue with my credit card

1393
00:48:43,099 --> 00:48:45,530
you can imagine some of that information may be relevant

1394
00:48:45,530 --> 00:48:46,760
for this newer

1395
00:48:47,019 --> 00:48:48,958
well now it's present, but it could have been a future

1396
00:48:49,378 --> 00:48:51,378
uh interaction. So these are interactions

1397
00:48:51,378 --> 00:48:53,280
we may want to save and store

1398
00:48:53,579 --> 00:48:55,579
where we can do things like short term and long term

1399
00:48:55,579 --> 00:48:58,260
memory in order to enhance that personalization

1400
00:48:58,260 --> 00:49:00,280
experience uh with these uh different

1401
00:49:00,280 --> 00:49:01,860
end user uh interactions.

1402
00:49:02,978 --> 00:49:05,019
And of course, as you can imagine with any of

1403
00:49:05,019 --> 00:49:05,840
these.

1404
00:49:06,829 --> 00:49:09,219
Capabilities we wanna make sure that observability

1405
00:49:09,219 --> 00:49:11,300
is tied into this entire stack and so

1406
00:49:11,478 --> 00:49:14,199
this is where we standardize on open telemetry

1407
00:49:14,199 --> 00:49:16,360
format to ensure that your traces, metrics, and logs

1408
00:49:16,360 --> 00:49:18,360
are all shipped in a way that can

1409
00:49:18,360 --> 00:49:20,639
be ingested into your, uh, enterprise

1410
00:49:20,639 --> 00:49:22,139
observability capabilities.

1411
00:49:22,978 --> 00:49:25,219
So this is a quick overview of what Agent Corre

1412
00:49:25,219 --> 00:49:27,219
allows you to do. What we're gonna do is we're gonna spend a little bit

1413
00:49:27,219 --> 00:49:27,800
more time

1414
00:49:28,250 --> 00:49:30,320
on Agent Corp runtime and gateway

1415
00:49:30,449 --> 00:49:32,579
aserless options for running your

1416
00:49:32,579 --> 00:49:34,820
agents and your MCP servers.

1417
00:49:36,489 --> 00:49:38,739
Um, so similar to the deployment patterns

1418
00:49:38,739 --> 00:49:40,769
here, fortunately with Agent Corps runtime

1419
00:49:40,769 --> 00:49:42,809
you have the same deployment capabilities.

1420
00:49:42,898 --> 00:49:45,019
So again in your organization, if you've

1421
00:49:45,019 --> 00:49:47,059
built, uh, a lot of your

1422
00:49:47,059 --> 00:49:49,208
CI capabilities around deploying to

1423
00:49:49,208 --> 00:49:51,208
lambda functions as zip artifacts,

1424
00:49:51,469 --> 00:49:54,000
you can leverage those same deployment pipelines

1425
00:49:54,139 --> 00:49:56,139
in order to be able to deploy zip artifacts to

1426
00:49:56,139 --> 00:49:56,989
Agent Corps runtime.

1427
00:49:57,260 --> 00:49:59,079
Again, the same would apply if you're doing this

1428
00:49:59,340 --> 00:50:00,320
based on containers.

1429
00:50:02,239 --> 00:50:04,320
Similarly, if you're building out, uh, MCP

1430
00:50:04,320 --> 00:50:06,478
servers, I know that there are a lot of, uh, folks

1431
00:50:06,478 --> 00:50:07,260
that are out there,

1432
00:50:07,599 --> 00:50:09,760
uh, either consuming existing public

1433
00:50:09,760 --> 00:50:11,840
MCP servers or saying I

1434
00:50:11,840 --> 00:50:13,699
have a bunch of internal data,

1435
00:50:14,079 --> 00:50:16,079
um, and they're saying I want to be

1436
00:50:16,079 --> 00:50:18,119
able to expose this data. Maybe I

1437
00:50:18,119 --> 00:50:18,699
wanna build out

1438
00:50:18,958 --> 00:50:19,610
an agentic,

1439
00:50:20,199 --> 00:50:22,519
uh, data platform that allows,

1440
00:50:22,750 --> 00:50:24,840
you know, certain enterprise data to be exposed

1441
00:50:24,840 --> 00:50:26,918
to these agents internally in order to be

1442
00:50:26,918 --> 00:50:28,938
able to give good internal use cases,

1443
00:50:29,199 --> 00:50:31,208
um. This could be something where you build out

1444
00:50:31,208 --> 00:50:33,418
an MCP server on top of data. Again,

1445
00:50:33,458 --> 00:50:35,239
we want to ensure that security

1446
00:50:35,809 --> 00:50:37,860
is implemented in a way that protects that

1447
00:50:37,860 --> 00:50:39,938
data so that there is not any

1448
00:50:39,938 --> 00:50:41,978
privilege escalation or exposure

1449
00:50:41,978 --> 00:50:44,260
of data to entities that should not have

1450
00:50:44,260 --> 00:50:45,159
access to that data

1451
00:50:45,769 --> 00:50:48,000
and then you could again deploy these MCP servers

1452
00:50:48,179 --> 00:50:49,300
into agent core runtime.

1453
00:50:50,789 --> 00:50:52,800
Uh, similarly, as we talked about with Agent Core

1454
00:50:52,800 --> 00:50:55,000
Gateway, again, Gateway becomes that front

1455
00:50:55,000 --> 00:50:56,719
end for all of your tool capabilities.

1456
00:50:57,039 --> 00:50:59,478
So again, in your organization you may have lambda

1457
00:50:59,478 --> 00:51:01,500
functions already built with some amount

1458
00:51:01,500 --> 00:51:03,079
of business logic

1459
00:51:03,438 --> 00:51:05,820
that you want to then expose that business logic,

1460
00:51:05,958 --> 00:51:07,704
uh. As a tool call

1461
00:51:08,003 --> 00:51:10,043
to your agents, well, you don't actually need to

1462
00:51:10,043 --> 00:51:12,164
do anything with that lambda function. You don't need to

1463
00:51:12,164 --> 00:51:14,235
refactor it to make it a tool. You can

1464
00:51:14,235 --> 00:51:16,425
actually put agent core gateway in front of it

1465
00:51:16,925 --> 00:51:19,083
and provide it with some additional metadata.

1466
00:51:19,204 --> 00:51:21,364
So when you're putting agent core gateway in front of a lambda

1467
00:51:21,364 --> 00:51:23,719
function. You provide it with that description

1468
00:51:23,719 --> 00:51:25,320
that D Raj had showed before

1469
00:51:25,619 --> 00:51:27,978
of the tool description and then uh

1470
00:51:27,978 --> 00:51:30,119
that will then get passed uh as part of that,

1471
00:51:30,139 --> 00:51:31,739
uh, tool list to the agent.

1472
00:51:32,059 --> 00:51:34,059
So now the agent has information about

1473
00:51:34,059 --> 00:51:36,219
this particular lambda function and whether

1474
00:51:36,219 --> 00:51:37,958
or not it needs to be invoked

1475
00:51:38,458 --> 00:51:40,655
similar. If you have open API schemas,

1476
00:51:40,784 --> 00:51:42,894
right, so again, lots of folks in this room, I

1477
00:51:42,894 --> 00:51:45,523
imagine you're building out your microservices strategy.

1478
00:51:45,824 --> 00:51:48,014
You've defined your APIs using open API

1479
00:51:48,014 --> 00:51:50,184
schema. You could then import those open

1480
00:51:50,184 --> 00:51:52,224
API schemas, and they can then

1481
00:51:52,224 --> 00:51:54,625
be exposed as tools via

1482
00:51:54,625 --> 00:51:55,465
Agent Core gateway.

1483
00:51:57,228 --> 00:51:59,340
OK, So now we go

1484
00:51:59,340 --> 00:52:01,340
back to that example where we were doing

1485
00:52:01,340 --> 00:52:03,389
this before with API gateway and lambda

1486
00:52:03,820 --> 00:52:05,909
where maybe that lambda function was my A

1487
00:52:05,909 --> 00:52:06,429
toA client

1488
00:52:06,699 --> 00:52:08,898
and maybe uh my API gateway

1489
00:52:08,898 --> 00:52:11,228
was exposing that uh that A to A server.

1490
00:52:11,500 --> 00:52:13,500
Well, in this scenario now we can replace some of

1491
00:52:13,500 --> 00:52:14,958
those serverless capabilities

1492
00:52:15,340 --> 00:52:17,579
with Agent core runtime and Agent core

1493
00:52:17,579 --> 00:52:18,139
gateway.

1494
00:52:18,478 --> 00:52:20,679
So we're trying to make this simpler

1495
00:52:20,780 --> 00:52:22,958
and the nice thing here then is with both

1496
00:52:22,958 --> 00:52:23,519
the

1497
00:52:23,789 --> 00:52:26,090
the A. calls across the agents

1498
00:52:26,090 --> 00:52:28,708
but also the the MCP calls

1499
00:52:28,708 --> 00:52:29,829
within the agent

1500
00:52:30,168 --> 00:52:32,208
um we actually do a lot of the the the

1501
00:52:32,208 --> 00:52:34,188
security capabilities with agent core identity.

1502
00:52:34,519 --> 00:52:37,010
So I, I spent a lot of time talking to customers

1503
00:52:37,010 --> 00:52:39,228
around how do we do to,

1504
00:52:39,250 --> 00:52:41,309
uh, you know, with my MCP tool calls

1505
00:52:41,489 --> 00:52:43,869
and how do I scope that down to make sure that,

1506
00:52:44,010 --> 00:52:46,250
uh, you know, the end user request with

1507
00:52:46,250 --> 00:52:48,289
a certain set of scopes can only make these

1508
00:52:48,289 --> 00:52:48,909
tool calls

1509
00:52:49,250 --> 00:52:51,378
similarly with. With A to A calls

1510
00:52:51,559 --> 00:52:54,159
when we're making a call out to a different agent,

1511
00:52:54,398 --> 00:52:56,579
we wanna ensure that we're using the right

1512
00:52:56,579 --> 00:52:58,878
IDP, the identity provider, and

1513
00:52:58,878 --> 00:53:01,139
making sure those OO 2 flows are implemented

1514
00:53:01,250 --> 00:53:02,119
throughout that process.

1515
00:53:02,559 --> 00:53:04,619
So you know, Agent Core, what we're trying to do

1516
00:53:04,619 --> 00:53:06,500
with this service is to make a lot of these,

1517
00:53:06,800 --> 00:53:08,958
uh, capabilities more fully managed again

1518
00:53:08,958 --> 00:53:10,500
in this audience, you guys love Servius.

1519
00:53:10,760 --> 00:53:12,800
We're trying to give you that Servius experience as you're

1520
00:53:12,800 --> 00:53:15,000
building out your agents and your MCP

1521
00:53:15,000 --> 00:53:15,739
capabilities.

1522
00:53:16,579 --> 00:53:17,719
OK, so

1523
00:53:18,349 --> 00:53:20,989
We covered a bunch of these practical

1524
00:53:20,989 --> 00:53:22,989
deployment patterns. Now we want to think through

1525
00:53:22,989 --> 00:53:24,989
again. I had that earlier slide of how do

1526
00:53:24,989 --> 00:53:27,349
we start to decompose perhaps that monolithic

1527
00:53:27,349 --> 00:53:29,429
agent and go out to these multi-agent

1528
00:53:29,429 --> 00:53:31,550
systems. Draj talked about

1529
00:53:31,550 --> 00:53:33,550
using these open protocols in order to be able

1530
00:53:33,550 --> 00:53:34,168
to have

1531
00:53:34,769 --> 00:53:36,769
the different communication patterns, and

1532
00:53:36,769 --> 00:53:39,260
then Diraj also talked about some of these EDA patterns.

1533
00:53:39,300 --> 00:53:41,409
So let's think through that a little bit more

1534
00:53:41,898 --> 00:53:44,030
as we get close to wrapping up. So we have these

1535
00:53:44,030 --> 00:53:44,989
decomposed agents,

1536
00:53:45,418 --> 00:53:47,329
orders, inventory, payment support agents.

1537
00:53:47,769 --> 00:53:49,889
Uh, we've talked about different deployment patterns,

1538
00:53:49,978 --> 00:53:52,300
so maybe some of these, maybe one line of business

1539
00:53:52,300 --> 00:53:54,050
likes using ALB and Fargate.

1540
00:53:54,320 --> 00:53:56,579
Another line of business likes our API gateway lambda,

1541
00:53:56,860 --> 00:53:58,978
and maybe another group is like, hey, we're

1542
00:53:58,978 --> 00:54:01,059
gonna kind of cut our teeth on Agent

1543
00:54:01,059 --> 00:54:03,219
Core. And so again you can make your choices

1544
00:54:03,219 --> 00:54:04,579
about where you want to deploy these.

1545
00:54:06,309 --> 00:54:08,789
We also talked about uh this uh

1546
00:54:08,789 --> 00:54:11,099
orchestration, right, and so those three common

1547
00:54:11,099 --> 00:54:12,539
problems. So the first might be

1548
00:54:13,079 --> 00:54:15,340
that double charge again perhaps you

1549
00:54:15,389 --> 00:54:17,559
you could have just solved this by just doing better unit

1550
00:54:17,559 --> 00:54:18,699
integration testing

1551
00:54:18,958 --> 00:54:21,079
and uh rooting out the the uh the root

1552
00:54:21,079 --> 00:54:22,728
cause in those serverless APIs,

1553
00:54:23,110 --> 00:54:24,478
but also you can then uh.

1554
00:54:24,929 --> 00:54:27,059
Augment and create an agent that is

1555
00:54:27,059 --> 00:54:29,628
able to do some of that root cause analysis on your behalf.

1556
00:54:30,250 --> 00:54:32,329
Similarly, uh, for the, uh,

1557
00:54:32,340 --> 00:54:34,438
the order that included two items and only shipped

1558
00:54:34,438 --> 00:54:36,519
with one, maybe you're gonna actually make

1559
00:54:36,820 --> 00:54:38,159
a call out to the orders agent

1560
00:54:38,539 --> 00:54:40,659
and go and try to make a determination as

1561
00:54:40,659 --> 00:54:41,780
to why it didn't ship.

1562
00:54:42,135 --> 00:54:44,135
It may also even talk to the inventory agent.

1563
00:54:44,375 --> 00:54:46,655
Maybe it'll go and say actually we,

1564
00:54:47,054 --> 00:54:49,215
there was some race condition where the,

1565
00:54:49,224 --> 00:54:51,293
the, the front end exposed the fact that we

1566
00:54:51,293 --> 00:54:53,273
had one item left, but actually

1567
00:54:53,735 --> 00:54:55,853
the reality was that item had already shipped and we

1568
00:54:55,853 --> 00:54:57,853
actually were out of inventory. Maybe there was

1569
00:54:57,853 --> 00:54:58,853
some type of race condition.

1570
00:54:59,329 --> 00:55:01,438
So this type of uh orchestration can

1571
00:55:01,438 --> 00:55:03,570
then actually be done all by this orchestrator

1572
00:55:03,570 --> 00:55:04,949
agent. So now

1573
00:55:05,289 --> 00:55:07,530
again we talked about those challenges of your customer

1574
00:55:07,530 --> 00:55:09,559
support agent who wants to get faster

1575
00:55:09,559 --> 00:55:11,849
response time, wants to be able to uh resolve

1576
00:55:11,849 --> 00:55:13,889
this issue in a quicker way without having to do

1577
00:55:13,889 --> 00:55:15,969
a lot of manual work across a lot of different

1578
00:55:15,969 --> 00:55:16,840
dashboards.

1579
00:55:17,168 --> 00:55:19,280
Well this orchestrator agent can actually do a lot of this

1580
00:55:19,280 --> 00:55:21,590
on your behalf and we'll actually simplify

1581
00:55:21,989 --> 00:55:24,050
that and get you that better customer experience.

1582
00:55:25,478 --> 00:55:27,489
And as D Raj talked about maybe

1583
00:55:27,489 --> 00:55:29,849
instead of an interactive customer

1584
00:55:29,849 --> 00:55:31,849
support session you could be in a scenario

1585
00:55:31,849 --> 00:55:33,929
where maybe this is actually a retail planning

1586
00:55:34,728 --> 00:55:35,750
exercise where maybe you're doing.

1587
00:55:36,250 --> 00:55:38,958
Uh, quarterly purchasing, uh,

1588
00:55:39,019 --> 00:55:41,128
decisioning where you actually wanna make a determination

1589
00:55:41,329 --> 00:55:43,329
how much inventory do we need to buy across

1590
00:55:43,329 --> 00:55:44,208
different categories.

1591
00:55:44,570 --> 00:55:46,769
We just went through Black Friday, but now we're going into

1592
00:55:46,769 --> 00:55:49,289
the Christmas shopping period. What type of inventory,

1593
00:55:49,449 --> 00:55:51,489
so this could be something now where you build out this

1594
00:55:51,489 --> 00:55:52,239
planning agent,

1595
00:55:52,570 --> 00:55:54,570
maybe this is actually an async agent going

1596
00:55:54,570 --> 00:55:56,648
and working in the background and saying we're gonna go

1597
00:55:56,648 --> 00:55:58,809
and collect data from a variety of different data

1598
00:55:58,809 --> 00:55:59,469
sources.

1599
00:56:00,010 --> 00:56:02,010
And actually we're gonna do this using some of the

1600
00:56:02,010 --> 00:56:04,090
async patterns that D Raja talked about before where

1601
00:56:04,090 --> 00:56:05,228
we can actually fire off

1602
00:56:05,610 --> 00:56:07,849
maybe we're gonna go and do research in our inventory database

1603
00:56:07,849 --> 00:56:09,889
we're gonna do some analysis on what

1604
00:56:09,889 --> 00:56:12,250
is the history of order pattern over the last 36

1605
00:56:12,250 --> 00:56:14,070
months, over the last 48 months,

1606
00:56:14,659 --> 00:56:16,829
um, and then we're gonna actually collate that with,

1607
00:56:16,840 --> 00:56:19,050
uh, maybe different, uh, orders

1608
00:56:19,050 --> 00:56:21,090
information and so we can start to get and

1609
00:56:21,090 --> 00:56:22,668
build out some of these reports

1610
00:56:22,929 --> 00:56:24,969
that maybe your inventory planning or your

1611
00:56:24,969 --> 00:56:26,829
retail planning team can then leverage.

1612
00:56:28,099 --> 00:56:30,188
The other benefit here, uh, again, as D Raja

1613
00:56:30,188 --> 00:56:32,188
talked about then is that you can

1614
00:56:32,188 --> 00:56:34,469
imagine maybe some of these agents have different scaling

1615
00:56:34,469 --> 00:56:34,978
requirements.

1616
00:56:35,349 --> 00:56:37,389
Maybe the inventory agent is one that

1617
00:56:37,389 --> 00:56:39,389
is far busier and maybe that actually needs

1618
00:56:39,389 --> 00:56:41,389
to scale out, uh, far more rapidly,

1619
00:56:41,510 --> 00:56:42,989
whereas maybe the support agent.

1620
00:56:43,349 --> 00:56:45,628
Maybe you've actually built your system so well

1621
00:56:45,628 --> 00:56:47,789
that you're the number of support requests

1622
00:56:47,789 --> 00:56:49,869
is actually reducing and so maybe that's something

1623
00:56:49,869 --> 00:56:50,889
that doesn't need to scale

1624
00:56:51,179 --> 00:56:53,369
as rapidly and so this allows you to then

1625
00:56:53,750 --> 00:56:56,070
uh similar with the microservices world, scale your

1626
00:56:56,070 --> 00:56:58,208
resources based on wherever the requirements may be.

1627
00:56:59,179 --> 00:57:01,269
OK, so let's talk, uh, a

1628
00:57:01,269 --> 00:57:03,789
little bit about pros and cons of some of these different architectural

1629
00:57:03,789 --> 00:57:06,030
patterns that we've been talking through here. So if

1630
00:57:06,030 --> 00:57:08,090
we start with that single agent architecture,

1631
00:57:08,750 --> 00:57:11,128
um, again, similar with monoliths, it's just

1632
00:57:11,128 --> 00:57:13,219
easier to develop, uh, it's easier to

1633
00:57:13,219 --> 00:57:15,409
debug. You get clearer reasoning traces,

1634
00:57:15,628 --> 00:57:17,829
um, and possibly, I, I

1635
00:57:17,829 --> 00:57:19,840
say possibly, uh, fewer compute

1636
00:57:19,840 --> 00:57:22,010
resources again, the idea being that,

1637
00:57:22,228 --> 00:57:24,228
um, because I don't need to make these

1638
00:57:24,228 --> 00:57:26,530
network calls, I don't need to do a lot of waiting, etc.

1639
00:57:27,289 --> 00:57:29,570
These might be certain benefits. It just is simpler

1640
00:57:29,570 --> 00:57:30,389
to be able to build out

1641
00:57:30,728 --> 00:57:31,789
these capabilities.

1642
00:57:32,168 --> 00:57:34,369
Um, however, for those that are already experimenting,

1643
00:57:34,449 --> 00:57:37,110
you're probably aware when you're interacting with LLMs

1644
00:57:37,250 --> 00:57:39,070
there is this notion of a context window

1645
00:57:39,329 --> 00:57:41,340
that data that we've been collecting

1646
00:57:41,489 --> 00:57:43,128
and enhancing that prompt with

1647
00:57:43,409 --> 00:57:45,409
is a finite amount of data that we can

1648
00:57:45,409 --> 00:57:47,489
provide to these LLMs. So you may

1649
00:57:47,489 --> 00:57:49,570
have heard of there, there are some models at this point that

1650
00:57:49,570 --> 00:57:51,594
can handle a million. Token, uh,

1651
00:57:51,813 --> 00:57:52,715
context windows

1652
00:57:53,063 --> 00:57:53,793
and so

1653
00:57:54,054 --> 00:57:56,175
you could put in theory exceed that

1654
00:57:56,175 --> 00:57:58,175
context window and uh you

1655
00:57:58,175 --> 00:58:00,293
would then have to do some work around compressing

1656
00:58:00,293 --> 00:58:02,764
whatever information that you wanna provide to that context.

1657
00:58:03,333 --> 00:58:05,425
The other challenge is if you put too much context

1658
00:58:05,425 --> 00:58:07,905
that is not relevant to that particular request,

1659
00:58:08,135 --> 00:58:10,715
you may be in a scenario where it takes longer

1660
00:58:10,934 --> 00:58:13,135
for the LLM to respond and it's actually more

1661
00:58:13,135 --> 00:58:14,273
expensive than it need be.

1662
00:58:14,628 --> 00:58:16,708
And so this is where you may want to start thinking about do

1663
00:58:16,708 --> 00:58:18,969
we want to decompose into these finer grained

1664
00:58:19,179 --> 00:58:21,228
uh smaller agents that

1665
00:58:21,228 --> 00:58:23,228
have, uh, maybe they're gonna be faster

1666
00:58:23,228 --> 00:58:24,369
and actually perhaps cheaper

1667
00:58:24,829 --> 00:58:26,289
to run with these models.

1668
00:58:27,409 --> 00:58:29,458
So there are a couple of multi-agent patterns that we're seeing

1669
00:58:29,458 --> 00:58:31,458
some of our customers build out. So the first is

1670
00:58:31,458 --> 00:58:33,489
this, this serialized pipeline.

1671
00:58:33,820 --> 00:58:35,820
So this could be something like we're doing a

1672
00:58:35,820 --> 00:58:37,978
content generation, right? So you can imagine in

1673
00:58:37,978 --> 00:58:40,139
content generation you're gonna do some amount of

1674
00:58:40,139 --> 00:58:40,659
research.

1675
00:58:40,938 --> 00:58:43,239
You're gonna then maybe build out a draft,

1676
00:58:43,289 --> 00:58:44,958
and then you're gonna maybe build out a final,

1677
00:58:45,219 --> 00:58:45,840
um,

1678
00:58:46,179 --> 00:58:48,340
maybe a final production copy, and

1679
00:58:48,340 --> 00:58:50,489
then maybe you're gonna do some, uh, feedback loops,

1680
00:58:50,780 --> 00:58:52,780
um, you can imagine this is a scenario

1681
00:58:52,780 --> 00:58:53,760
where, uh.

1682
00:58:54,478 --> 00:58:56,519
This is just simple to model. I, I realize

1683
00:58:56,519 --> 00:58:58,688
I'm running out of time here, so I'm gonna speed up along,

1684
00:58:59,219 --> 00:59:01,320
um, but there are downsides similar to Christmas lights.

1685
00:59:01,438 --> 00:59:03,438
If there is a problem at one point in

1686
00:59:03,438 --> 00:59:05,639
the stage, you can actually end up bottlenecking

1687
00:59:05,639 --> 00:59:07,989
there. The next is the orchestrator

1688
00:59:07,989 --> 00:59:10,050
pattern which uh we've already talked about kind of

1689
00:59:10,050 --> 00:59:12,659
at length here. This allows you to do decomposition,

1690
00:59:12,958 --> 00:59:15,228
allows you to actually orchestrate some of these patterns,

1691
00:59:15,530 --> 00:59:17,769
um, uh, but again there is some communication

1692
00:59:17,769 --> 00:59:19,369
overhead as we had just mentioned.

1693
00:59:19,769 --> 00:59:21,918
And then the last pattern here is around

1694
00:59:21,918 --> 00:59:24,019
a swarm architecture, right? And so the idea here

1695
00:59:24,019 --> 00:59:26,050
is you may have a scenario where you wanna do

1696
00:59:26,050 --> 00:59:28,179
actually a broad research. You don't have a

1697
00:59:28,179 --> 00:59:29,918
finite path to that end result

1698
00:59:30,219 --> 00:59:32,219
where you maybe actually wanna send out a large

1699
00:59:32,219 --> 00:59:34,340
number of agents or a number of agents to go

1700
00:59:34,340 --> 00:59:36,378
and do research in parallel. It's

1701
00:59:36,378 --> 00:59:38,409
kind of like the scatter gather pattern where you're gonna go

1702
00:59:38,409 --> 00:59:41,119
out and do research. You're gonna bring that back and try to synthesize

1703
00:59:41,340 --> 00:59:43,159
what a number of these uh agents have done.

1704
00:59:43,550 --> 00:59:45,610
The challenge here though is that uh in

1705
00:59:45,610 --> 00:59:47,728
this type of swarm architecture it is a lot more

1706
00:59:47,728 --> 00:59:49,789
difficult to reason about some of the behavior

1707
00:59:50,010 --> 00:59:52,050
uh and it is somewhat harder so again

1708
00:59:52,050 --> 00:59:53,148
make sure that your

1709
00:59:53,449 --> 00:59:55,789
uh your use case aligns to whichever pattern

1710
00:59:55,929 --> 00:59:56,849
makes the most sense

1711
00:59:57,208 --> 00:59:59,369
again I realize I'm coming up on time. I'll just skip

1712
00:59:59,369 --> 01:00:00,269
to the last one

1713
01:00:00,610 --> 01:00:02,688
we talked a little bit about security, so this is one

1714
01:00:02,688 --> 01:00:04,510
where you wanna build out your agents in a way

1715
01:00:04,849 --> 01:00:07,550
that propagates uh security context

1716
01:00:07,688 --> 01:00:09,769
appropriately. You also want to make sure that you

1717
01:00:09,769 --> 01:00:11,110
are, uh.

1718
01:00:11,889 --> 01:00:14,070
Have steps along the way where

1719
01:00:14,449 --> 01:00:16,688
uh as an end user comes into the agent,

1720
01:00:16,769 --> 01:00:19,039
the agent comes into the MCP server and the MCP

1721
01:00:19,039 --> 01:00:21,429
server makes the the downstream API calls

1722
01:00:21,648 --> 01:00:23,889
you wanna make sure that those are all separate

1723
01:00:23,889 --> 01:00:25,909
set of tokens. You don't wanna use the same token

1724
01:00:25,909 --> 01:00:26,429
throughout.

1725
01:00:27,628 --> 01:00:28,760
And of course with governance

1726
01:00:29,179 --> 01:00:29,739
uh

1727
01:00:30,139 --> 01:00:32,458
you wanna make sure that you are using the same

1728
01:00:32,458 --> 01:00:34,539
type of governance policies mechanisms

1729
01:00:34,539 --> 01:00:36,000
that you're deploying into production

1730
01:00:36,539 --> 01:00:37,119
um

1731
01:00:37,659 --> 01:00:39,659
that you've already been using all right so just a couple

1732
01:00:39,659 --> 01:00:41,360
of takeaways as we try to wrap up here,

1733
01:00:41,860 --> 01:00:43,978
um, so a lot of the, the things that you've

1734
01:00:43,978 --> 01:00:46,019
already been doing with serverless APIs in

1735
01:00:46,019 --> 01:00:48,179
production you can actually continue to apply

1736
01:00:48,179 --> 01:00:50,260
those as you're building out, uh, agents into

1737
01:00:50,260 --> 01:00:50,840
production as well.

1738
01:00:51,449 --> 01:00:53,648
Um, you wanna use agents in a way that

1739
01:00:53,648 --> 01:00:55,809
really bridges data and gleans insight,

1740
01:00:56,010 --> 01:00:58,208
uh, out of that information. Again, you don't wanna use this

1741
01:00:58,208 --> 01:01:00,590
kind of as this low level shim across your data.

1742
01:01:00,889 --> 01:01:03,389
Uh, you wanna use this as higher order insight gathering

1743
01:01:03,889 --> 01:01:05,708
and servius again can be a way to accelerate,

1744
01:01:06,000 --> 01:01:07,769
uh, your path to production.

1745
01:01:08,250 --> 01:01:10,539
And of course, uh, as we talked about a lot of these patterns

1746
01:01:10,539 --> 01:01:12,559
that allow you to scale your agents,

1747
01:01:12,780 --> 01:01:14,938
um, as you build out your particular use

1748
01:01:14,938 --> 01:01:15,820
cases again there are,

1749
01:01:16,099 --> 01:01:17,119
there are a number of, um,

1750
01:01:17,500 --> 01:01:19,699
key considerations. I think we're out of time at this

1751
01:01:19,699 --> 01:01:21,898
point, but, uh, certainly just make sure

1752
01:01:21,898 --> 01:01:23,679
that you're documenting along the way,

1753
01:01:24,059 --> 01:01:25,599
uh, build and be scrappy,

1754
01:01:25,909 --> 01:01:28,500
uh, and then again document and provide feedback

1755
01:01:28,500 --> 01:01:30,659
so that your internal platform teams, your internal

1756
01:01:30,659 --> 01:01:32,958
developer teams are able to learn from

1757
01:01:33,059 --> 01:01:34,969
the things that you are learning within your organization.

1758
01:01:35,938 --> 01:01:37,369
We do have a number of resources

1759
01:01:37,628 --> 01:01:39,789
again you can take a quick picture of that one and find

1760
01:01:39,789 --> 01:01:40,619
that afterwards.

1761
01:01:40,938 --> 01:01:43,269
Um, there are a number of other sessions

1762
01:01:43,269 --> 01:01:45,530
that we wanna encourage you to to participate

1763
01:01:45,530 --> 01:01:47,590
in and so these are some of the other ones that we

1764
01:01:47,590 --> 01:01:49,128
recommend you go and check out.

1765
01:01:49,429 --> 01:01:51,610
And of course there are other servalless resources.

1766
01:01:51,780 --> 01:01:53,829
This deck will be provided afterwards as well, so

1767
01:01:53,829 --> 01:01:56,090
I, I recognize there are a bunch of people trying to take pictures,

1768
01:01:56,429 --> 01:01:58,429
uh, and again Draj and I do wanna thank you.

1769
01:01:58,539 --> 01:02:00,628
You can find our socials here so you can connect with us

1770
01:02:00,628 --> 01:02:01,938
afterwards. Thank you everyone,

1771
01:02:02,349 --> 01:02:03,500
and we, uh, thank you.

1772
01:02:03,760 --> 01:02:05,550
Please do fill out the survey. We appreciate it.

