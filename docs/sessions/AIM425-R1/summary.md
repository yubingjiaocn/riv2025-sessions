# AWS re:Invent 2025 技术会议总结

## 会议概述

本次会议是一场关于构建智能事件代理(Event Agent)的深度技术分享,由Amazon Bedrock团队的解决方案架构师Danny和数据科学家Akasha Seag主讲。会议重点介绍了如何使用Amazon Bedrock的知识库(Knowledge Bases)和代理核心内存(Agent Core Memory)功能,构建一个具有超个性化体验的AI代理系统。

演讲者通过实际代码演示,展示了如何将传统的检索增强生成(RAG)系统升级为代理式RAG(Agentic RAG)系统。这种系统不仅能够从知识库中检索会议信息,还能够记住用户偏好、对话历史,并基于这些上下文提供个性化的会议推荐。整个演示使用了Anthropic Claude Haiku 4.5模型和Amazon Titan Text Embeddings v2,并采用Trans Agents框架进行代理开发。

会议强调了"上下文工程"(Context Engineering)的重要性,即通过精心策划的上下文(包括文档信息、工具配置和用户记忆)来提升代理的智能性和准确性。这种方法能够有效解决大型语言模型的无状态特性,同时优化成本、延迟和准确性。

## 详细时间线

00:00:00 - 会议开场与讲师介绍
- Danny介绍自己是Amazon Bedrock团队的解决方案架构师,专注于生成式AI、知识库和代理核心内存
- Akasha Seag介绍自己是代理核心内存团队的生成式AI数据科学家
- 说明这是一场400级别的深度技术会议,将进行代码演示

00:02:30 - RAG基础概念回顾
- 介绍传统检索增强生成(RAG)的工作流程:查询→检索→增强→生成响应
- 解释RAG如何通过提供外部信息来防止模型幻觉

00:04:15 - 代理式RAG(Agentic RAG)概念
- Akasha解释代理本质上是无状态的,需要通过上下文工程来增强能力
- 介绍上下文工程的三个组成部分:文档信息(传统RAG)、工具配置、用户记忆
- 强调精确的上下文策划对于代理智能性的重要性

00:06:45 - 代理式RAG工作流程
- 展示代理式RAG的迭代检索过程:查询→检索→增强→模型判断是否需要更多信息→可能再次检索→最终响应
- 说明代理可以自主决定是否需要获取更多信息

00:08:20 - 今日构建目标:事件代理
- 介绍将构建一个AWS re:Invent事件代理
- 代理具备两大能力:从知识库检索会议信息、存储和检索对话历史及用户偏好
- 目标是提供超个性化的会议推荐体验

00:10:00 - 开始代码演示
- 切换到Jupyter Notebook进行实际代码演示
- 说明代码将在本周发布到Amazon Bedrock样例代码库

00:11:30 - 创建简单代理
- 导入Trans Agents框架和Claude Haiku 4.5模型
- 演示如何用一行代码创建基础代理:定义模型和系统提示词
- 测试基础代理,发现它无法回答关于会议的问题(因为没有相关上下文)

00:14:00 - Amazon Bedrock知识库介绍
- 解释知识库是完全托管的RAG工作流服务
- 介绍知识库的工作流程:文档→解析→分块→向量化→存储到向量数据库
- 说明知识库支持两种数据连接器:S3和直接输入
- 介绍四种分块策略和检索API选项

00:17:30 - 创建知识库的步骤
- 下载2024年re:Invent会议数据
- 创建S3存储桶并上传文档(将单个文件拆分为580个文档)
- 创建S3向量存储和索引

00:20:15 - S3向量存储配置
- 使用S3 Tables的向量存储功能(较新的S3能力)
- 创建向量存储桶和向量索引
- 配置维度为1024(对应Titan Embeddings v2的输出维度)
- 设置距离度量、数据类型和元数据配置

00:23:00 - 创建知识库资源
- 创建IAM角色,授予知识库访问嵌入模型和S3的权限
- 配置知识库:指定Titan Text Embeddings v2作为嵌入模型
- 配置存储为之前创建的S3向量索引
- 使用固定大小分块策略:最大300个token,20%重叠

00:26:30 - 数据摄取与测试
- 创建S3数据源并启动摄取作业
- 摄取过程处理583个文件,耗时约2分钟
- 使用Retrieve API测试知识库,查询"关于生成式AI和安全的会议"
- 成功返回三个最相关的会议结果

00:29:00 - 创建知识库搜索工具
- 使用Trans Agents的@tool装饰器创建工具
- 定义工具描述,告诉代理何时使用该工具
- 工具内部调用Bedrock知识库的Retrieve API
- 强调工具描述的重要性:代理根据描述决定是否调用工具

00:31:45 - 代理核心内存概念介绍(Akasha)
- 解释为什么需要内存:避免将整周的对话历史发送给LLM(影响成本、延迟和准确性)
- 介绍短期记忆和长期记忆的区别
- 短期记忆:存储原始对话消息到数据存储(DynamoDB)
- 长期记忆:从对话中提取关键洞察(用户偏好、语义事实、会话摘要等)

00:35:20 - 内存提取流程
- 对话事件进入短期记忆
- 根据配置的策略(用户偏好、语义、摘要或自定义)进行提取
- 提取模块包含两个步骤:提取相关信息、与现有记忆合并去重
- 合并步骤可以添加新记忆、更新现有记忆或跳过冗余信息
- 最终存储到长期记忆的向量存储中

00:38:00 - 内存标识符系统
- 回答观众问题:如何区分不同用户的记忆
- 介绍三个标识符:Memory ID、Actor ID、Session ID
- Actor ID可以是用户、项目、团队或组合
- Session ID用于区分不同会话
- 长期记忆使用命名空间(namespace)进行分层组织

00:40:30 - 创建内存资源(代码演示)
- 使用Memory Manager创建或获取内存资源
- 配置策略类型(如用户偏好策略)
- 定义命名空间路径结构,支持0个或多个变量(actor_id、strategy_id、session_id等)
- 设置事件过期时间(7-365天)
- API返回Memory ID供后续使用

00:43:00 - 使用Hooks集成内存
- 介绍Hooks方法与Tools方法的区别
- Hooks允许在代理生命周期的不同阶段执行操作
- 演示两个关键Hooks:
  - Agent Initialized Hook:代理初始化时从长期记忆检索用户偏好
  - Message Added Hook:每次新消息时将用户和代理消息存储到短期记忆

00:45:30 - 完整代理集成
- 将知识库工具和内存Hooks集成到代理中
- 代理现在具备:检索会议信息的能力、记住用户偏好和对话历史的能力

00:47:00 - 会话继续(字幕在此处截断)
- 演示继续进行,展示如何检索事件数据...

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━


注:字幕在会议进行到约47分钟时截断,完整会议可能还包含更多关于生产环境部署、安全配置(使用Core Runtime和Core Identity)以及最佳实践的内容。