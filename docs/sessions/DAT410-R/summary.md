# AWS re:Invent 2025 DAT410 会议总结：PostgreSQL 性能调优实战

## 会议概述

本次会议（DAT410）主题为"PostgreSQL 性能：真实工作负载调优"，由 AWS RDS 和 Aurora PostgreSQL 高级数据库工程师 Bajishek 和数据库技术负责人 Vlad Blash Chana 主讲。会议通过一个电商应用的实际案例，演示了如何诊断和解决常见的 PostgreSQL 性能问题。

演讲者以一个虚拟角色 John（高级数据库工程师）的困境开场——尽管他正确配置了数据库并设置了监控告警，但随着数据增长，仍然在凌晨 3 点收到性能告警。会议重点关注五个关键性能问题，包括查询重写、执行计划切换、索引优化等，并通过实时演示展示了如何将查询执行时间从 1 分钟降低到 800 毫秒，以及如何在相同工作负载下将查询吞吐量从 15,000 提升到 20,000。

整个演示基于 Aurora PostgreSQL 实例，使用了超过 150 个并发连接的负载生成器，模拟真实的电商场景（包含订单、产品、用户等表），并通过 Performance Insights、Database Insights 和 CloudWatch 等工具进行实时监控和分析。

## 详细时间线与关键要点

### 开场与背景介绍（开始）
- **主题引入**：询问听众是否遇到过凌晨 3 点因数据库性能下降（高 CPU、查询执行时间长、执行计划切换）而收到告警
- **演讲者介绍**：Bajishek（RDS/Aurora PostgreSQL 高级数据库工程师）和 Vlad（数据库技术负责人）
- **案例背景**：介绍虚拟角色 John，一位配置良好但仍遇到性能问题的数据库工程师

### 性能调优关键领域
- **CPU 利用率**：次优查询导致全表扫描、工作负载与实例规模不匹配、并行查询过多
- **内存**：内存密集型查询、基于进程的架构（每个连接消耗内存）、内存参数配置过高
- **存储和 IOPS**：MVCC 机制产生的膨胀（bloat）、未使用或重复的索引、work_memory 不足导致临时文件写入磁盘
- **应用模式**：查询相互阻塞、长事务或空闲事务、过多空闲连接（建议使用连接池）

### 查询调优方法论
- **步骤流程**：
  1. 查看 Performance Insights 中的活动会话摘要或 pg_stat_activity 视图
  2. 识别消耗资源最多的 Top SQL 和等待事件
  3. 生成 EXPLAIN ANALYZE 计划（带 BUFFERS 选项）
  4. 分析共享缓冲区信息并进行调查
- **迭代过程**：强调这是一个逐步迭代的过程，需要找出 Top SQL 并逐一修复

### EXPLAIN ANALYZE 计划解读
- **计划结构**：每个箭头代表一个计划节点，顶行是所有计划节点的汇总
- **两部分信息**：
  - **估算部分**：启动成本、总成本、预估行数、平均行宽度
  - **实际部分**：实际启动时间（毫秒）、总时间（毫秒）、实际行数、循环次数
- **关键指标**：执行时间、行数、循环次数、缓冲区读取

### 演示环境设置
- **电商应用**：包含订单（orders）、产品（products）、用户（users）等表
- **负载生成器**：超过 150 个连接，读写平衡，每 30 秒提供查询执行摘要
- **监控工具**：Performance Insights、Database Insights、CloudWatch 仪表板

### 问题 1：函数调用导致的全表扫描
- **问题描述**：get_sale_movement_count() 函数消耗大量 CPU 资源
- **执行计划分析**：
  - 执行时间：约 60 秒
  - 全表扫描 1100 万行
  - 过滤器移除了 1000 万行（只需要 100 万行）
  - 共享缓冲区命中：87,000 个 8KB 块（约 800MB）
- **根本原因**：优化器不知道函数返回的值（"sale"），对每行执行函数调用
- **解决方案**：在函数中使用 SELECT 调用代替直接函数调用
- **改进效果**：
  - 执行时间从 60 秒降至 800 毫秒
  - 使用索引扫描而非全表扫描
  - 共享缓冲区从 87,000 块降至 2,800 块
  - 无过滤器移除的行
  - 函数调用次数从每 30 秒 9 次提升到 489 次

### 问题 2：部分索引优化
- **问题描述**：查询获取特定类别的活跃产品平均价格
- **执行计划分析**：
  - 使用位图索引扫描（比普通索引扫描更高效）
  - 过滤器移除 30,000 行
  - 共享缓冲区：13,800 个块
- **数据分析**：只有 33% 的产品是活跃状态
- **解决方案**：创建部分索引（partial index）仅针对活跃产品
 sql
  CREATE INDEX CONCURRENTLY idx_category_active 
  ON products(category) 
  WHERE is_active = true
  
- **改进效果**：
  - 过滤器移除行数从 30,000 降至 900
  - 执行时间从 360 毫秒降至 23 毫秒
  - 共享缓冲区从 13,000 降至 10,000
  - 查询吞吐量从 1,200 提升到 2,000（100% 提升）
- **Q&A 讨论**：为什么不使用复合索引？因为复合索引仍会包含非活跃产品，导致过滤器移除大量行

### 问题 3：查询提示（Hint）导致的错误索引选择
- **问题描述**：使用 pg_hint_plan 扩展强制使用特定索引
- **执行计划分析**：
  - 使用单列索引（created_at）
  - 过滤器移除 400,000 行
  - 共享缓冲区：400,800 个块
- **根本原因**：查询有两个谓词（created_at 和 total_amount），但提示强制使用单列索引
- **已有资源**：表上已存在复合索引（created_at, total_amount）
- **短期解决方案**：使用 Aurora 查询计划管理（APG Plan Management）扩展
  - 捕获当前计划（使用单列索引）
  - 移除提示后捕获新计划（使用复合索引）
  - 使用 set_plan_status 函数批准新计划、拒绝旧计划
- **改进效果**：
  - 无过滤器移除的行
  - 共享缓冲区从 400,000 降至 37,000
  - 自动切换到最优执行计划
- **监控工具**：aurora_stat_plans 函数查看实时查询使用的计划

### 扩展和工具讨论
- **pg_hint_plan**：允许在查询中使用提示（类似 Oracle）
- **APG Plan Management**：Aurora 专有扩展，用于捕获和管理查询执行计划
  - dba_plans 表存储所有捕获的计划
  - 支持批准/拒绝/未批准状态
  - 可在不修改应用代码的情况下切换执行计划
- **重要说明**：
  - APG Plan Management 仅适用于 Aurora PostgreSQL（不适用于 RDS）
  - 创建/删除扩展需要重启数据库
  - AWS 正在努力确保扩展的向前兼容性，但目前尚未完全保证

### 整体性能改进
- **查询吞吐量**：从 15,000 次/30 秒提升到 20,000 次/30 秒（33% 提升）
- **提交延迟**：从 23 毫秒降至 21 毫秒
- **CPU 利用率**：从接近 100% 逐步下降
- **查询完成数**：持续改善
- **总查询时间**：从 500 万降至 52.5 万

### 监控和诊断工具
- **Performance Insights**：查看等待事件和 Top SQL
- **Database Insights**：Performance Insights 的扩展版本
- **CloudWatch 仪表板**：自定义指标监控（CPU、IOPS、延迟等）
- **pg_stat_activity**：数据库内部视图，查看活动连接
- **EXPLAIN ANALYZE**：生成查询执行计划
- **aurora_stat_plans**：查看实时查询使用的执行计划

### 最佳实践建议
1. 避免在谓词中直接使用函数调用：使用 SELECT 子查询提供提示
2. 考虑部分索引：当查询始终过滤特定条件时（如活跃记录）
3. 谨慎使用查询提示：可能随数据增长变得次优
4. 定期监控索引使用情况：删除未使用或重复的索引
5. 关注 EXPLAIN 计划中的关键指标：
   - 过滤器移除的行数（越少越好）
   - 共享缓冲区命中数
   - 估算值与实际值的差异
   - 顺序扫描 vs 索引扫描
6. 使用查询计划管理：在不修改代码的情况下优化执行计划

### 未完成内容提示
- 会议提到五个关键性能问题，但演示中详细展示了前三个
- 第四个问题：堆仅元组（Heap-Only Tuple, HOT）更新
- 第五个问题：轻量级日志分析
- 其他主题：未使用索引的识别和清理