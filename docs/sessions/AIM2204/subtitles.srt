1
00:00:00,930 --> 00:00:02,370
- Good afternoon, everyone.

2
00:00:02,370 --> 00:00:04,950
Thank you for making
the trek to Mandalay Bay

3
00:00:04,950 --> 00:00:06,157
and welcome to our session,

4
00:00:06,157 --> 00:00:08,577
"Bridging the Gap from
Prototype to Production".

5
00:00:10,110 --> 00:00:11,520
Over the last year,

6
00:00:11,520 --> 00:00:13,290
we have started seeing AI agents

7
00:00:13,290 --> 00:00:15,240
transition into autonomous systems

8
00:00:15,240 --> 00:00:17,640
that can reason, plan, and adapt

9
00:00:17,640 --> 00:00:19,800
in pursuit of user-defined goals,

10
00:00:19,800 --> 00:00:23,250
completing tasks on behalf
of humans or other systems,

11
00:00:23,250 --> 00:00:24,720
things like compiling research,

12
00:00:24,720 --> 00:00:26,610
remediating infrastructure issues,

13
00:00:26,610 --> 00:00:28,890
or even generating full stack applications

14
00:00:28,890 --> 00:00:30,003
from a single prompt.

15
00:00:32,850 --> 00:00:35,850
The advent of reasoning
models, agent frameworks,

16
00:00:35,850 --> 00:00:38,610
and open source protocols
like model context protocol

17
00:00:38,610 --> 00:00:41,487
have made it easier than
ever to prototype agents.

18
00:00:41,487 --> 00:00:42,690
And as a result,

19
00:00:42,690 --> 00:00:45,090
we are seeing an explosion
of agent prototypes

20
00:00:45,090 --> 00:00:47,283
across both startups and enterprises.

21
00:00:48,390 --> 00:00:49,470
But when we look at which ones

22
00:00:49,470 --> 00:00:51,300
actually made it make into production,

23
00:00:51,300 --> 00:00:53,050
the number is in low single digits.

24
00:00:54,030 --> 00:00:54,863
Quick show of hands,

25
00:00:54,863 --> 00:00:56,780
how many of you have built
or experimented with an agent

26
00:00:56,780 --> 00:00:58,173
in the last six months?

27
00:00:59,220 --> 00:01:00,090
That's a lot.

28
00:01:00,090 --> 00:01:02,424
Now keep your hands up if that
agent made it into production

29
00:01:02,424 --> 00:01:04,083
and is running reliably today.

30
00:01:05,910 --> 00:01:06,990
See that drop off?

31
00:01:06,990 --> 00:01:08,880
That's the story we
are here to talk about.

32
00:01:08,880 --> 00:01:12,120
We are still in the early
innings of the agent era.

33
00:01:12,120 --> 00:01:14,820
There's enormous excitement,
enormous potential,

34
00:01:14,820 --> 00:01:16,200
but the value only comes

35
00:01:16,200 --> 00:01:18,543
when those agents operate safely at scale.

36
00:01:19,530 --> 00:01:20,880
I'm Vivek Singh.

37
00:01:20,880 --> 00:01:23,970
I lead product management
for Amazon Bedrock AgentCore.

38
00:01:23,970 --> 00:01:25,923
I'm joined today by Mark Roy,

39
00:01:25,923 --> 00:01:28,272
tech lead for agentic AI at AWS,

40
00:01:28,272 --> 00:01:31,293
and Sarbashis Das who's the
GenAI tech lead at Ericsson.

41
00:01:35,400 --> 00:01:38,880
Today, we'll cover the key
challenges that developers face

42
00:01:38,880 --> 00:01:41,610
in moving their agent
prototypes to production

43
00:01:41,610 --> 00:01:44,460
and how Bedrock AgentCore
provides developers

44
00:01:44,460 --> 00:01:46,650
the building blocks to cross the prototype

45
00:01:46,650 --> 00:01:48,420
to production chasm.

46
00:01:48,420 --> 00:01:50,100
We also have a few demos for you

47
00:01:50,100 --> 00:01:51,930
to show AgentCore in action,

48
00:01:51,930 --> 00:01:53,310
and then Sarbashis will cover

49
00:01:53,310 --> 00:01:55,260
how Ericsson is leveraging AgentCore

50
00:01:55,260 --> 00:01:57,363
to power agentic AI innovations.

51
00:01:58,230 --> 00:01:59,733
So let's get into it.

52
00:02:01,890 --> 00:02:03,870
AI agents are autonomous systems.

53
00:02:03,870 --> 00:02:06,870
So even a basic one requires
multiple moving parts

54
00:02:06,870 --> 00:02:09,030
such as orchestration, tool execution,

55
00:02:09,030 --> 00:02:11,700
state management, and error handling.

56
00:02:11,700 --> 00:02:14,130
That's a lot of wiring to get right.

57
00:02:14,130 --> 00:02:16,050
And here is where frameworks

58
00:02:16,050 --> 00:02:19,650
like LangGraph, Strands
Agents, and CrewAI help.

59
00:02:19,650 --> 00:02:21,480
They provide ready-made abstractions

60
00:02:21,480 --> 00:02:23,940
for behaviors like multi-step planning,

61
00:02:23,940 --> 00:02:26,220
coordination between different sub-agents,

62
00:02:26,220 --> 00:02:27,483
tool and vocation.

63
00:02:28,320 --> 00:02:30,808
That means developers
no longer have to start

64
00:02:30,808 --> 00:02:32,730
everything from scratch.

65
00:02:32,730 --> 00:02:35,490
They can focus on defining
the agent's behavior

66
00:02:35,490 --> 00:02:38,820
while the frameworks take care
of the lower level plumbing.

67
00:02:38,820 --> 00:02:40,110
So using these frameworks,

68
00:02:40,110 --> 00:02:41,940
you can spin up a coding assistant,

69
00:02:41,940 --> 00:02:43,260
a customer support bot,

70
00:02:43,260 --> 00:02:45,693
or a sales agent in a few days.

71
00:02:46,920 --> 00:02:50,010
But moving that same
prototype to production

72
00:02:50,010 --> 00:02:52,950
with thousands of users,
reliability requirements,

73
00:02:52,950 --> 00:02:54,540
lead compliance requirements,

74
00:02:54,540 --> 00:02:56,490
that's a completely different ballgame.

75
00:02:57,630 --> 00:02:59,160
Let's make that concrete.

76
00:02:59,160 --> 00:03:02,160
Imagine you build an agent,
let's call it sales assist,

77
00:03:02,160 --> 00:03:05,340
that helps your sales
reps close deals faster.

78
00:03:05,340 --> 00:03:06,810
It answers product questions,

79
00:03:06,810 --> 00:03:09,030
it pulls customer history from Salesforce,

80
00:03:09,030 --> 00:03:11,040
it drops personalized emails,

81
00:03:11,040 --> 00:03:14,853
and it can even suggest next
steps based on prior deals.

82
00:03:16,080 --> 00:03:17,910
You can get that prototype up and running

83
00:03:17,910 --> 00:03:20,913
for one sales rep locally in a few days.

84
00:03:21,960 --> 00:03:25,890
Now, imagine deploying
that across 10,000 reps

85
00:03:25,890 --> 00:03:27,480
in five different countries,

86
00:03:27,480 --> 00:03:29,730
each with dozens of daily conversations,

87
00:03:29,730 --> 00:03:32,850
each agent accessing Salesforce,
confluence, DocuSign,

88
00:03:32,850 --> 00:03:34,800
your internal pricing APIs,

89
00:03:34,800 --> 00:03:38,760
all while acting under a
rep's individual permissions.

90
00:03:38,760 --> 00:03:41,280
That's where the real work begins.

91
00:03:41,280 --> 00:03:44,030
Let's unpack what makes that
transition so challenging.

92
00:03:45,630 --> 00:03:48,360
When you try to scale
something like sales assist,

93
00:03:48,360 --> 00:03:51,450
four categories of challenges emerge fast.

94
00:03:51,450 --> 00:03:56,450
Your performance, scalability,
security, and governance.

95
00:03:56,460 --> 00:03:58,410
Before you even think about scale,

96
00:03:58,410 --> 00:04:01,860
the agent has to be responsive,
reliable, and accurate.

97
00:04:01,860 --> 00:04:03,810
It has to be able to reason well,

98
00:04:03,810 --> 00:04:06,720
reliably call multiple
tools to take action,

99
00:04:06,720 --> 00:04:10,290
remember pertinent facts
from prior interactions.

100
00:04:10,290 --> 00:04:12,346
For example, sales assist might ace a demo

101
00:04:12,346 --> 00:04:14,250
with one or two tools,

102
00:04:14,250 --> 00:04:16,710
but in production it's
tens or hundreds of tools,

103
00:04:16,710 --> 00:04:19,410
each with its own auth,
schema, rate limits,

104
00:04:19,410 --> 00:04:21,900
and unpredictable failures.

105
00:04:21,900 --> 00:04:23,370
Turning all of those

106
00:04:23,370 --> 00:04:26,310
into uniform reliable
MCP'S compatible tools

107
00:04:26,310 --> 00:04:28,310
becomes a massive engineering challenge.

108
00:04:29,370 --> 00:04:33,120
Secondly, LLMs are stateless,
but agents are not.

109
00:04:33,120 --> 00:04:35,670
So sales assist must
remember the deal history.

110
00:04:35,670 --> 00:04:37,320
It must remember pertinent facts

111
00:04:37,320 --> 00:04:38,880
from prior customer interactions

112
00:04:38,880 --> 00:04:42,030
such as the quote it gave
to the customer last week.

113
00:04:42,030 --> 00:04:44,894
Without a proper memory layer,
the agent will lose context,

114
00:04:44,894 --> 00:04:48,303
misremember things, and can
even hallucinate the past state.

115
00:04:49,584 --> 00:04:51,570
And without continuous evaluations

116
00:04:51,570 --> 00:04:54,300
for things like correctness
and helpfulness,

117
00:04:54,300 --> 00:04:57,030
the agent performance may
even drift in production

118
00:04:57,030 --> 00:04:59,013
leading to widespread customer impact.

119
00:05:00,660 --> 00:05:02,520
So performance is not about picking

120
00:05:02,520 --> 00:05:04,200
a bigger and better model,

121
00:05:04,200 --> 00:05:06,030
it's a system around the model,

122
00:05:06,030 --> 00:05:08,340
the continuous evaluation,
the tool integration,

123
00:05:08,340 --> 00:05:09,600
the persistent memory

124
00:05:09,600 --> 00:05:12,273
that keep the agents
reliable and consistent.

125
00:05:16,230 --> 00:05:19,140
After performance, the
real challenge scale.

126
00:05:19,140 --> 00:05:20,370
Sales assistant production

127
00:05:20,370 --> 00:05:22,410
means thousands of concurrent agents,

128
00:05:22,410 --> 00:05:24,180
each making multiple tool calls,

129
00:05:24,180 --> 00:05:25,830
running long workflows,

130
00:05:25,830 --> 00:05:28,530
and handling sensitive
customer data at the same time.

131
00:05:29,730 --> 00:05:32,430
So you need a secure, resilient,

132
00:05:32,430 --> 00:05:33,930
and elastic runtime

133
00:05:33,930 --> 00:05:36,030
that can scale up during peak workloads,

134
00:05:36,030 --> 00:05:37,443
scale down when idle,

135
00:05:38,340 --> 00:05:40,590
keep each agent session isolated,

136
00:05:40,590 --> 00:05:42,436
maintain state during long running

137
00:05:42,436 --> 00:05:44,580
multi-step reasoning workflows,

138
00:05:44,580 --> 00:05:46,770
and quickly recover from failures

139
00:05:46,770 --> 00:05:48,900
like API timeouts or service disruptions

140
00:05:48,900 --> 00:05:51,700
when it's calling multiple
different tools and services.

141
00:05:53,340 --> 00:05:55,530
Then comes security.

142
00:05:55,530 --> 00:05:57,420
Agents act on behalf of humans.

143
00:05:57,420 --> 00:05:59,100
So every action must respect

144
00:05:59,100 --> 00:06:01,950
fine-grained identity and access controls.

145
00:06:01,950 --> 00:06:04,830
If Sarah in Enterprises
is using sales assist,

146
00:06:04,830 --> 00:06:07,530
it should see a list of
her Fortune 500 accounts.

147
00:06:07,530 --> 00:06:09,810
But when Tom in Startup
does it, he shouldn't.

148
00:06:09,810 --> 00:06:13,110
The sales assist shouldn't
see the Enterprise accounts.

149
00:06:13,110 --> 00:06:16,710
That's per user identity,
not shared credentials.

150
00:06:16,710 --> 00:06:20,050
And doing that securely across
thousands of agent sessions

151
00:06:20,970 --> 00:06:22,323
requires deliberate design.

152
00:06:24,600 --> 00:06:27,810
Finally, you need
visibility and guardrails

153
00:06:27,810 --> 00:06:29,790
to know what each agent is doing

154
00:06:29,790 --> 00:06:33,120
and to control unsafe
actions before they happen.

155
00:06:33,120 --> 00:06:35,220
If a D goes sideways,

156
00:06:35,220 --> 00:06:38,220
can you audit what data
sales assist accessed,

157
00:06:38,220 --> 00:06:40,520
what email it sent, what
pricing it suggested?

158
00:06:41,580 --> 00:06:43,440
Additionally, you need a way

159
00:06:43,440 --> 00:06:45,960
to enforce your business
rules in real time.

160
00:06:45,960 --> 00:06:48,030
For example, never share
unannounced features,

161
00:06:48,030 --> 00:06:50,580
never discount over 20%.

162
00:06:50,580 --> 00:06:53,340
So governance isn't something
that you bolt on later.

163
00:06:53,340 --> 00:06:56,090
It has to be built in in your
application from day one.

164
00:06:57,060 --> 00:06:59,190
And doing all of these things

165
00:06:59,190 --> 00:07:00,210
essentially means building

166
00:07:00,210 --> 00:07:02,730
a distributed enterprise scale system

167
00:07:02,730 --> 00:07:04,950
that can handle thousands
of concurrent sessions,

168
00:07:04,950 --> 00:07:06,690
millions of tool calls,

169
00:07:06,690 --> 00:07:09,840
adhere to strict latency and
reliability requirements,

170
00:07:09,840 --> 00:07:12,123
all while leaving very
little room for error.

171
00:07:13,374 --> 00:07:14,850
And that's the difference

172
00:07:14,850 --> 00:07:18,060
between a prototype and
a production system.

173
00:07:18,060 --> 00:07:20,608
And right now, developers
have to do significant

174
00:07:20,608 --> 00:07:22,740
undifferentiated heavy lifting

175
00:07:22,740 --> 00:07:24,540
in building all of these pieces

176
00:07:24,540 --> 00:07:28,650
for a combination of a framework,
model, and a set of tools.

177
00:07:28,650 --> 00:07:30,297
And as your business case evolves

178
00:07:30,297 --> 00:07:32,100
and you want to leverage newer models,

179
00:07:32,100 --> 00:07:33,750
newer frameworks, and newer tools,

180
00:07:33,750 --> 00:07:35,520
you start all over again.

181
00:07:35,520 --> 00:07:37,882
And that is what's slowing
down organizations right now

182
00:07:37,882 --> 00:07:39,843
in realizing their agent equation.

183
00:07:42,240 --> 00:07:43,890
To address these challenges,

184
00:07:43,890 --> 00:07:46,110
we launched Amazon Bedrock AgentCore.

185
00:07:46,110 --> 00:07:47,970
It's a generally available service.

186
00:07:47,970 --> 00:07:50,010
We launched it earlier this year.

187
00:07:50,010 --> 00:07:50,850
It's an agentic platform

188
00:07:50,850 --> 00:07:53,940
that provides a complete set of services

189
00:07:53,940 --> 00:07:57,690
purpose-built to build,
deploy, and operate

190
00:07:57,690 --> 00:08:01,023
highly performant agents
securely and at scale.

191
00:08:02,640 --> 00:08:03,473
Let's look into some

192
00:08:03,473 --> 00:08:05,367
of the key characteristics of AgentCore.

193
00:08:06,780 --> 00:08:10,590
First, AgentCore helps
you optimize time to value

194
00:08:10,590 --> 00:08:13,290
because you don't have to
manage any infrastructure.

195
00:08:13,290 --> 00:08:16,560
All AgentCore services
are completely serverless

196
00:08:16,560 --> 00:08:18,540
and you pay for what you use.

197
00:08:18,540 --> 00:08:21,240
For example, if you're
using AgentCore Runtime,

198
00:08:21,240 --> 00:08:23,670
you only pay for the
active compute and memory

199
00:08:23,670 --> 00:08:25,590
that your agent consumes.

200
00:08:25,590 --> 00:08:28,440
In fact, you don't even have
to pay for the I/O wait time,

201
00:08:28,440 --> 00:08:29,704
which is the time your agent spends

202
00:08:29,704 --> 00:08:31,767
waiting to get responses back from LLMs

203
00:08:31,767 --> 00:08:33,570
and different tool calls.

204
00:08:33,570 --> 00:08:35,220
And in most of the agentic session,

205
00:08:35,220 --> 00:08:37,650
I/O wait could make it up to 60 to 70%

206
00:08:37,650 --> 00:08:39,350
of the overall agent session time.

207
00:08:40,320 --> 00:08:44,460
Secondly, AgentCore was built
with flexibility in mind.

208
00:08:44,460 --> 00:08:46,983
Each AgentCore service
is completely modular,

209
00:08:47,820 --> 00:08:49,110
so you can use them together

210
00:08:49,110 --> 00:08:50,810
or you can use them independently.

211
00:08:51,840 --> 00:08:54,810
And each AgentCore service
works with any framework

212
00:08:54,810 --> 00:08:56,790
or model out there.

213
00:08:56,790 --> 00:08:58,770
So if you built your agent using LangGraph

214
00:08:58,770 --> 00:09:00,270
or Cloud Agent SDK,

215
00:09:00,270 --> 00:09:03,780
or if your agent is using
OpenAI models or Gemini models,

216
00:09:03,780 --> 00:09:06,900
you can still use any of
the AgentCore primitives

217
00:09:06,900 --> 00:09:08,433
with your agent.

218
00:09:09,330 --> 00:09:12,827
And finally, AgentCore
provides the controls,

219
00:09:12,827 --> 00:09:15,390
the access management,
and the observability,

220
00:09:15,390 --> 00:09:17,643
which are crucial for
enterprise deployments.

221
00:09:18,600 --> 00:09:19,920
So overall with AgentCore,

222
00:09:19,920 --> 00:09:22,470
you can accelerate
prototypes into production

223
00:09:22,470 --> 00:09:25,890
with the scale, reliability, and security,

224
00:09:25,890 --> 00:09:28,170
which are critical to
real world deployments,

225
00:09:28,170 --> 00:09:30,513
eliminating months of infrastructure work.

226
00:09:31,770 --> 00:09:33,089
Now, let's look into
some of the key services

227
00:09:33,089 --> 00:09:34,653
that Agent Core offers.

228
00:09:36,330 --> 00:09:39,480
First, to build highly performant agents,

229
00:09:39,480 --> 00:09:43,050
AgentCore offers memory
that helps developers

230
00:09:43,050 --> 00:09:44,940
build context of their agents.

231
00:09:44,940 --> 00:09:48,120
It automatically extracts
and stores short-term memory

232
00:09:48,120 --> 00:09:50,490
across multi-term user interactions,

233
00:09:50,490 --> 00:09:52,042
as well as long-term memory patterns

234
00:09:52,042 --> 00:09:55,050
such as semantic memory
and user preferences

235
00:09:55,050 --> 00:09:58,053
across longer horizon
and multiple sessions.

236
00:09:59,460 --> 00:10:03,000
Gateway enables you to
compose your tools and agents

237
00:10:03,000 --> 00:10:04,830
across your ecosystem

238
00:10:04,830 --> 00:10:07,320
into a single MCP server interface

239
00:10:07,320 --> 00:10:10,413
that you can then expose
to your agent remotely.

240
00:10:11,460 --> 00:10:14,850
With Gateway, you can combine
different tool sources

241
00:10:14,850 --> 00:10:16,781
from your REST APIs to
your Lambda functions

242
00:10:16,781 --> 00:10:19,080
to your existing MCP servers

243
00:10:19,080 --> 00:10:21,120
into one unified interface

244
00:10:21,120 --> 00:10:23,029
without managing multiple tool connections

245
00:10:23,029 --> 00:10:25,203
or implementing any integrations.

246
00:10:26,769 --> 00:10:29,400
AgentCore also provides
fully managed tools

247
00:10:29,400 --> 00:10:32,520
that are essential to
most agentic workflows.

248
00:10:32,520 --> 00:10:34,410
Code interpreter enables agents

249
00:10:34,410 --> 00:10:36,900
to securely generate and execute code

250
00:10:36,900 --> 00:10:38,820
in isolated environments,

251
00:10:38,820 --> 00:10:40,742
and browser enables agents to interact

252
00:10:40,742 --> 00:10:42,903
with web applications at scale.

253
00:10:47,880 --> 00:10:49,875
Then to deploy and scale agents,

254
00:10:49,875 --> 00:10:53,250
AgentCore provides a secure
and serverless runtime

255
00:10:53,250 --> 00:10:56,940
that is purpose built to
host agents as well as tools,

256
00:10:56,940 --> 00:10:59,910
and agents and tools could
be built using any framework,

257
00:10:59,910 --> 00:11:04,083
any protocol, whether it's
MCP or A2A or any model.

258
00:11:05,232 --> 00:11:07,471
AgentCore identity simplifies

259
00:11:07,471 --> 00:11:10,680
agent identity and access management,

260
00:11:10,680 --> 00:11:14,370
allowing agents to securely
access AWS services

261
00:11:14,370 --> 00:11:15,720
and third party services

262
00:11:15,720 --> 00:11:18,993
on behalf of users with
preauthorized consent.

263
00:11:20,640 --> 00:11:22,320
And we also launched policy today,

264
00:11:22,320 --> 00:11:24,330
this was announced in Matt's keynote,

265
00:11:24,330 --> 00:11:27,150
which provides you real
time deterministic controls

266
00:11:27,150 --> 00:11:28,434
over how agents interact

267
00:11:28,434 --> 00:11:31,350
with your enterprise tools and data.

268
00:11:31,350 --> 00:11:34,410
And you can define these
policies in natural language.

269
00:11:34,410 --> 00:11:36,780
For example, block all
reimbursement requests,

270
00:11:36,780 --> 00:11:38,880
which are over a thousand dollars,

271
00:11:38,880 --> 00:11:41,141
and these policies are
evaluated and enforced

272
00:11:41,141 --> 00:11:43,650
in real time in milliseconds

273
00:11:43,650 --> 00:11:45,743
so that every agent action is operating

274
00:11:45,743 --> 00:11:48,753
within the boundaries or
policies that you have specified.

275
00:11:51,420 --> 00:11:54,690
And finally, to operate trustworthy agent,

276
00:11:54,690 --> 00:11:57,784
we have observability that
provides rich visualization

277
00:11:57,784 --> 00:12:00,660
into each step of the agent workflow,

278
00:12:00,660 --> 00:12:02,700
as well as operational metrics

279
00:12:02,700 --> 00:12:06,840
like token count latency
via unified dashboards.

280
00:12:06,840 --> 00:12:10,788
It also emits the data like
logs, metrics, and traces,

281
00:12:10,788 --> 00:12:13,350
and open telemetry compatible format

282
00:12:13,350 --> 00:12:16,140
so you can plug it into the
monitoring tool of your choice

283
00:12:16,140 --> 00:12:20,157
such as CloudWatch, Datadog,
Langfuse, and LangSmith.

284
00:12:20,157 --> 00:12:22,650
And we also launched evaluations today,

285
00:12:22,650 --> 00:12:24,570
which is a new AgentCore service

286
00:12:24,570 --> 00:12:27,210
that helps developers continuously inspect

287
00:12:27,210 --> 00:12:29,520
the quality of agent behavior

288
00:12:29,520 --> 00:12:30,870
so that you can catch issues

289
00:12:30,870 --> 00:12:33,120
before they cause
widespread customer impact.

290
00:12:35,190 --> 00:12:36,630
Overall with AgentCore,

291
00:12:36,630 --> 00:12:38,310
you get everything you need

292
00:12:38,310 --> 00:12:41,100
to take your agents from
prototype through production

293
00:12:41,100 --> 00:12:45,300
built on the AWS foundation
that customers already trust.

294
00:12:45,300 --> 00:12:47,610
Now, I'm gonna hand it over to Mark

295
00:12:47,610 --> 00:12:49,530
to go all layer deeper into these services

296
00:12:49,530 --> 00:12:51,893
and show you a few demos
of how they work together.

297
00:12:53,610 --> 00:12:54,752
- Thank you, Vivek.

298
00:12:54,752 --> 00:12:56,910
(audience applauding)

299
00:12:56,910 --> 00:12:58,464
Great introduction to AgentCore

300
00:12:58,464 --> 00:13:02,487
and super excited to be here
for my eighth re:Invent.

301
00:13:02,487 --> 00:13:04,275
My name is Mark Roy.

302
00:13:04,275 --> 00:13:07,830
I'm with, do we go to
the wrong slide here?

303
00:13:07,830 --> 00:13:10,290
Sorry, I might've hit the wrong button.

304
00:13:10,290 --> 00:13:12,922
My name is Mark Roy, I am with AWS,

305
00:13:12,922 --> 00:13:16,290
and I'm a global tech lead for Agentic AI.

306
00:13:16,290 --> 00:13:19,710
And although you may think
I'm only 29 years old,

307
00:13:19,710 --> 00:13:21,960
I've actually been building
for about 30 years now.

308
00:13:21,960 --> 00:13:24,089
So Vivek talked a lot

309
00:13:24,089 --> 00:13:26,309
about the chasm of production readiness.

310
00:13:26,309 --> 00:13:28,260
I really love that term.

311
00:13:28,260 --> 00:13:30,174
I'm wondering who here,
after that description,

312
00:13:30,174 --> 00:13:32,750
feels like they're in that chasm

313
00:13:32,750 --> 00:13:35,820
of production readiness already?

314
00:13:35,820 --> 00:13:37,230
Anyone out there?

315
00:13:37,230 --> 00:13:39,030
Okay, not too many hands.

316
00:13:39,030 --> 00:13:42,000
But let me tell you, it is real.

317
00:13:42,000 --> 00:13:42,833
For the last two years,

318
00:13:42,833 --> 00:13:44,760
I've been working with
hundreds of customers

319
00:13:44,760 --> 00:13:46,169
trying to build and deploy agents

320
00:13:46,169 --> 00:13:48,510
and get real business value.

321
00:13:48,510 --> 00:13:51,750
And I see three things
showing up every time.

322
00:13:51,750 --> 00:13:54,720
One, great looking prototypes,

323
00:13:54,720 --> 00:13:57,153
amazing capability, looks great,

324
00:13:58,380 --> 00:14:00,774
compelling business value
that everyone's excited about,

325
00:14:00,774 --> 00:14:02,640
all the potential,

326
00:14:02,640 --> 00:14:03,780
and then months,

327
00:14:03,780 --> 00:14:06,840
and usually quarters of heavy lifting

328
00:14:06,840 --> 00:14:10,020
and pain and suffering in between.

329
00:14:10,020 --> 00:14:11,430
So for the next 15 minutes,

330
00:14:11,430 --> 00:14:15,390
I'll drill down into what
are those real challenges,

331
00:14:15,390 --> 00:14:17,397
and I'll go one level deeper on AgentCore

332
00:14:17,397 --> 00:14:21,231
and explain how these
services help you solve

333
00:14:21,231 --> 00:14:23,730
those compelling challenges.

334
00:14:23,730 --> 00:14:24,905
So with that, we've got a lot to cover.

335
00:14:24,905 --> 00:14:27,873
So buckle up and let's jump in.

336
00:14:28,800 --> 00:14:29,633
Let me start

337
00:14:29,633 --> 00:14:32,970
with the very most common
and compelling challenge,

338
00:14:32,970 --> 00:14:36,660
and that is where am I gonna run my agent?

339
00:14:36,660 --> 00:14:39,240
I can't run my agent on my laptop

340
00:14:39,240 --> 00:14:42,660
and just share that out to users.

341
00:14:42,660 --> 00:14:45,840
So you're an agent builder and
you're thinking this through.

342
00:14:45,840 --> 00:14:49,050
You've got pressure to
deliver some real value here.

343
00:14:49,050 --> 00:14:53,100
You know that your agent is
gonna be used by 10,000 users.

344
00:14:53,100 --> 00:14:53,933
You need to ship it now.

345
00:14:53,933 --> 00:14:56,250
You've got a security officer

346
00:14:56,250 --> 00:14:57,457
breathing down your neck saying,

347
00:14:57,457 --> 00:14:58,350
"You've gotta make sure

348
00:14:58,350 --> 00:15:02,040
this thing isn't going
to do the wrong things."

349
00:15:02,040 --> 00:15:03,237
And for most of you,

350
00:15:03,237 --> 00:15:05,730
you probably have got a platform team

351
00:15:05,730 --> 00:15:07,620
you're working with as well,

352
00:15:07,620 --> 00:15:10,560
and they're thinking
beyond your one agent.

353
00:15:10,560 --> 00:15:12,990
They're dealing with
multiple different teams.

354
00:15:12,990 --> 00:15:13,823
And guess what?

355
00:15:13,823 --> 00:15:15,510
You're using LangGraph,

356
00:15:15,510 --> 00:15:17,790
there's some other teams using CrewAI,

357
00:15:17,790 --> 00:15:22,080
other teams using OpenAI,
and it's a bit of a mess.

358
00:15:22,080 --> 00:15:23,670
And guess what?

359
00:15:23,670 --> 00:15:26,010
If you look at across
these business units,

360
00:15:26,010 --> 00:15:29,130
they've got a thousand use cases lined up.

361
00:15:29,130 --> 00:15:30,720
So you've got a big dilemma here,

362
00:15:30,720 --> 00:15:33,900
how am I gonna do this
at scale and securely

363
00:15:33,900 --> 00:15:36,540
and not spend the next year getting ready?

364
00:15:36,540 --> 00:15:38,970
So that's where AgentCore runtime steps in

365
00:15:38,970 --> 00:15:43,440
and gives you the first major
component of your platform.

366
00:15:43,440 --> 00:15:48,060
Runtime, lets you use
any framework, any model,

367
00:15:48,060 --> 00:15:51,330
host your agent securely and at scale.

368
00:15:51,330 --> 00:15:55,470
You can scale from zero to
thousands of concurrent sessions.

369
00:15:55,470 --> 00:16:00,450
It comes built in with the
ability of the host MCP

370
00:16:00,450 --> 00:16:03,915
to use A2A for agent interoperability,

371
00:16:03,915 --> 00:16:08,310
OTEL for observability,
OAuth for security.

372
00:16:08,310 --> 00:16:11,970
All of these things help
get you that time to value

373
00:16:11,970 --> 00:16:13,527
where you can focus on building agents

374
00:16:13,527 --> 00:16:15,273
and not building infrastructure.

375
00:16:17,610 --> 00:16:18,990
Another key point here

376
00:16:18,990 --> 00:16:21,075
is that although you're
probably working on,

377
00:16:21,075 --> 00:16:23,059
let's say an intelligent chat experience,

378
00:16:23,059 --> 00:16:26,040
that's kind of usually the first step,

379
00:16:26,040 --> 00:16:26,952
there's a lot more out there.

380
00:16:26,952 --> 00:16:28,890
There's voice agents,

381
00:16:28,890 --> 00:16:31,195
there's long running, deep research,

382
00:16:31,195 --> 00:16:33,840
there's large payloads to worry about.

383
00:16:33,840 --> 00:16:36,731
This complicates what am
I gonna do about hosting.

384
00:16:36,731 --> 00:16:39,903
It's not as simple as just
popping it into a Lambda.

385
00:16:43,230 --> 00:16:45,900
That sales assistant
that Vivek talked about?

386
00:16:45,900 --> 00:16:47,520
Let's say it's a multi-agent system.

387
00:16:47,520 --> 00:16:50,400
You've got one agent
running with Claude SDK,

388
00:16:50,400 --> 00:16:51,930
using Claude models,

389
00:16:51,930 --> 00:16:55,620
another one using
LangGraph and GPT models,

390
00:16:55,620 --> 00:16:58,710
maybe a third one using CrewAI and Gemini

391
00:16:58,710 --> 00:17:02,100
with strands agent on top
of it doing orchestration

392
00:17:02,100 --> 00:17:04,380
using Bedrock models.

393
00:17:04,380 --> 00:17:07,240
All of this can be done
out of the box with runtime

394
00:17:08,310 --> 00:17:11,393
and literally it's just four lines of code

395
00:17:11,393 --> 00:17:13,650
to take an existing agent

396
00:17:13,650 --> 00:17:16,350
and make it ready for AgentCore runtime

397
00:17:16,350 --> 00:17:18,540
and then you can deploy it to the cloud

398
00:17:18,540 --> 00:17:21,243
and it's ready to scale and
it's ready to be secure.

399
00:17:25,020 --> 00:17:27,630
A2A built in? No problem.

400
00:17:27,630 --> 00:17:29,880
You've got full interoperability there.

401
00:17:29,880 --> 00:17:32,345
And if you want to host MCP servers,

402
00:17:32,345 --> 00:17:36,633
you can pop your tools into
AgentCore runtime as well.

403
00:17:37,710 --> 00:17:40,200
So I talked about security.

404
00:17:40,200 --> 00:17:42,153
I'm not a security expert.

405
00:17:43,200 --> 00:17:45,753
I'm kind of glad about that on some days.

406
00:17:46,710 --> 00:17:48,870
When you're building agents,

407
00:17:48,870 --> 00:17:49,830
you're using agents

408
00:17:49,830 --> 00:17:52,080
because you want them to be
a little bit more autonomous,

409
00:17:52,080 --> 00:17:53,160
you're not wanting to build

410
00:17:53,160 --> 00:17:55,950
a hard coded traditional application.

411
00:17:55,950 --> 00:17:57,060
Now what about when you're dealing

412
00:17:57,060 --> 00:17:58,000
with sensitive information?

413
00:17:58,000 --> 00:17:59,910
That's my social security number there.

414
00:17:59,910 --> 00:18:02,400
Don't grab it, please.

415
00:18:02,400 --> 00:18:03,616
You might be giving out credit scores.

416
00:18:03,616 --> 00:18:06,870
You're doing very sensitive transactions.

417
00:18:06,870 --> 00:18:09,750
And while your agent's
being used by one user,

418
00:18:09,750 --> 00:18:12,750
there might be another user
doing something similar

419
00:18:12,750 --> 00:18:15,300
with also sensitive data.

420
00:18:15,300 --> 00:18:17,670
So I've got a question for you.

421
00:18:17,670 --> 00:18:19,350
Who here, raise your hands high,

422
00:18:19,350 --> 00:18:22,800
is ready to stand with
their security officer

423
00:18:22,800 --> 00:18:24,870
and say they're a hundred percent sure

424
00:18:24,870 --> 00:18:27,033
that those conversations are secure?

425
00:18:28,500 --> 00:18:30,150
We've got one guy in the front row.

426
00:18:30,150 --> 00:18:31,173
I wanna talk to you.

427
00:18:32,640 --> 00:18:33,930
This is a huge challenge.

428
00:18:33,930 --> 00:18:35,820
This, for me as a builder,

429
00:18:35,820 --> 00:18:38,370
this is where I wake up with a cold sweat.

430
00:18:38,370 --> 00:18:39,873
How am I gonna deal with this?

431
00:18:40,900 --> 00:18:44,640
AgentCore runtime does
this out of the box.

432
00:18:44,640 --> 00:18:46,930
Secure session isolation

433
00:18:48,240 --> 00:18:51,660
for no coding involved.

434
00:18:51,660 --> 00:18:53,130
It's just there.

435
00:18:53,130 --> 00:18:55,590
Safely execute those conversations,

436
00:18:55,590 --> 00:18:58,890
there's no risk of leaving
temporary files lying around,

437
00:18:58,890 --> 00:19:01,950
no risk of getting permission escalations,

438
00:19:01,950 --> 00:19:04,050
all taken care of for you.

439
00:19:04,050 --> 00:19:06,821
You get multiple concurrent
sessions, no problem.

440
00:19:06,821 --> 00:19:08,850
When the sessions are done,

441
00:19:08,850 --> 00:19:10,680
poof, they're gone.

442
00:19:10,680 --> 00:19:13,470
This is using our micro VM architecture

443
00:19:13,470 --> 00:19:16,410
so it's not just a
container level isolation,

444
00:19:16,410 --> 00:19:18,510
it's literally a micro VM

445
00:19:18,510 --> 00:19:20,340
that ensures that this is going to work

446
00:19:20,340 --> 00:19:23,493
and it does so at scale
and with low latency.

447
00:19:24,690 --> 00:19:26,400
This is something that
I wouldn't recommend

448
00:19:26,400 --> 00:19:27,800
trying to build on your own.

449
00:19:29,460 --> 00:19:33,120
Okay, problem number one,
let's put a check box on that.

450
00:19:33,120 --> 00:19:37,200
I think hosting AgentCore has
a pretty good story there.

451
00:19:37,200 --> 00:19:39,270
What's the second biggest problem?

452
00:19:39,270 --> 00:19:42,300
In my mind, agents, you know,

453
00:19:42,300 --> 00:19:43,732
what separates maybe a toy agent

454
00:19:43,732 --> 00:19:46,470
from closer to a real world agent,

455
00:19:46,470 --> 00:19:47,303
real business values,

456
00:19:47,303 --> 00:19:49,470
is is it able to learn?

457
00:19:49,470 --> 00:19:50,580
Is it able to remember?

458
00:19:50,580 --> 00:19:52,800
Is it able to improve?

459
00:19:52,800 --> 00:19:54,570
How do you make that happen?

460
00:19:54,570 --> 00:19:55,710
So first of all,

461
00:19:55,710 --> 00:19:57,411
your agent better remember
what's been discussed

462
00:19:57,411 --> 00:20:00,600
over the last few
minutes of a conversation

463
00:20:00,600 --> 00:20:02,850
and then ideally it's
remembering what happened

464
00:20:02,850 --> 00:20:06,330
in the last few months as well.

465
00:20:06,330 --> 00:20:09,810
So that's called memory for an agent

466
00:20:09,810 --> 00:20:11,505
and it better work reliably.

467
00:20:11,505 --> 00:20:14,329
So even if the agent
needs to be restarted,

468
00:20:14,329 --> 00:20:15,625
you better still have that there

469
00:20:15,625 --> 00:20:17,973
and it better be secure as well.

470
00:20:18,840 --> 00:20:21,690
And yes, you could build this on your own.

471
00:20:21,690 --> 00:20:23,400
Do it yourself memory.

472
00:20:23,400 --> 00:20:26,670
A lot of people out here
have probably tried it.

473
00:20:26,670 --> 00:20:29,100
Wouldn't necessarily recommend it,

474
00:20:29,100 --> 00:20:31,050
but with AgentCore,

475
00:20:31,050 --> 00:20:33,543
you get a memory component out of the box.

476
00:20:34,980 --> 00:20:36,130
So what does that mean?

477
00:20:37,320 --> 00:20:39,480
Pick your favorite framework again

478
00:20:39,480 --> 00:20:41,493
and just plug in AgentCore memory.

479
00:20:42,540 --> 00:20:43,500
When you've got that,

480
00:20:43,500 --> 00:20:45,150
your events, your conversations

481
00:20:45,150 --> 00:20:47,490
feed right into short term memory.

482
00:20:47,490 --> 00:20:50,220
It's got low latency, it's got security,

483
00:20:50,220 --> 00:20:52,863
it's there for you to
have good conversations.

484
00:20:53,730 --> 00:20:56,670
More exciting than that

485
00:20:56,670 --> 00:21:00,810
is automatic memory extraction
into long-term memory.

486
00:21:00,810 --> 00:21:02,370
What does that mean?

487
00:21:02,370 --> 00:21:06,390
All of these conversations
get fed into a process

488
00:21:06,390 --> 00:21:10,560
that runs behind the scenes
and extracts knowledge.

489
00:21:10,560 --> 00:21:12,330
It extracts facts.

490
00:21:12,330 --> 00:21:14,670
It summarizes conversations.

491
00:21:14,670 --> 00:21:17,274
It even identifies
episodes as of yesterday.

492
00:21:17,274 --> 00:21:19,750
We've got episodic memory now built in

493
00:21:21,030 --> 00:21:24,150
and it will actually look across episodes

494
00:21:24,150 --> 00:21:27,300
and reflect and get insights.

495
00:21:27,300 --> 00:21:30,930
All of these get put into
what's called long-term memory.

496
00:21:30,930 --> 00:21:32,880
And this long-term memory

497
00:21:32,880 --> 00:21:35,973
can be easily plugged into your agent.

498
00:21:36,870 --> 00:21:37,996
So now, instead of your agent

499
00:21:37,996 --> 00:21:40,354
having this long list of conversations

500
00:21:40,354 --> 00:21:42,870
that it's trying to take advantage of,

501
00:21:42,870 --> 00:21:46,020
you can selectively pull
out long-term memory,

502
00:21:46,020 --> 00:21:47,730
manage your context,

503
00:21:47,730 --> 00:21:51,270
and make your agent
learning from the past.

504
00:21:51,270 --> 00:21:53,340
And that's hyper-personalization.

505
00:21:53,340 --> 00:21:54,173
And that's, again,

506
00:21:54,173 --> 00:21:59,173
making really a real world
experience for your customers

507
00:21:59,370 --> 00:22:03,630
and doing so fully manage,
serverless, secure,

508
00:22:03,630 --> 00:22:05,373
and plugging into any framework.

509
00:22:06,570 --> 00:22:09,060
Okay, so two check boxes.

510
00:22:09,060 --> 00:22:10,860
We've got memory, we've got runtime.

511
00:22:12,060 --> 00:22:14,193
What's the next big challenge?

512
00:22:15,570 --> 00:22:19,833
To me, an agent is pretty useless
unless it can take action.

513
00:22:21,570 --> 00:22:24,180
You've heard Matt Garman and Andy Jassy

514
00:22:24,180 --> 00:22:27,570
say data is your differentiator,

515
00:22:27,570 --> 00:22:29,550
and really that's true.

516
00:22:29,550 --> 00:22:32,730
You could just use an off the shelf LLM

517
00:22:32,730 --> 00:22:34,410
and get generic answers.

518
00:22:34,410 --> 00:22:36,150
That's not gonna take you too far.

519
00:22:36,150 --> 00:22:38,520
Your agent needs your data,

520
00:22:38,520 --> 00:22:41,190
your APIs, your services,

521
00:22:41,190 --> 00:22:45,570
and it needs your APIs
to take action as well.

522
00:22:45,570 --> 00:22:47,040
That's the power.

523
00:22:47,040 --> 00:22:49,230
So why is that so difficult?

524
00:22:49,230 --> 00:22:52,218
Well, we've got cool things
like model context protocol

525
00:22:52,218 --> 00:22:57,218
that showed up late last year
and is now used everywhere.

526
00:22:57,300 --> 00:23:00,300
But how do you put those
MCP servers together

527
00:23:00,300 --> 00:23:01,260
and how do you integrate

528
00:23:01,260 --> 00:23:04,020
with all of your existing capabilities?

529
00:23:04,020 --> 00:23:05,880
That's a lot of heavy lifting.

530
00:23:05,880 --> 00:23:08,372
That's a lot of time, a lot of wrapping.

531
00:23:08,372 --> 00:23:11,190
And how do you make that secure as well?

532
00:23:11,190 --> 00:23:14,670
All of these things add
up to a lot of work.

533
00:23:14,670 --> 00:23:16,740
So how does AgentCore help?

534
00:23:16,740 --> 00:23:19,050
We've got something called Gateway

535
00:23:19,050 --> 00:23:23,250
that automatically lets you
map those existing resources

536
00:23:23,250 --> 00:23:27,360
and surface them as agent-ready tools.

537
00:23:27,360 --> 00:23:30,810
So it exposes those APIs as MCP

538
00:23:30,810 --> 00:23:33,630
and those MCP tools plug in

539
00:23:33,630 --> 00:23:37,560
to Strands, and CrewAI, LangGraph,

540
00:23:37,560 --> 00:23:40,023
whatever you're using, securely.

541
00:23:41,520 --> 00:23:44,220
Let's look at a little
bit more closely here.

542
00:23:44,220 --> 00:23:46,164
So Gateway, you can create
as many of these Gateways

543
00:23:46,164 --> 00:23:47,433
as you'd like.

544
00:23:48,300 --> 00:23:49,230
When you create a Gateway,

545
00:23:49,230 --> 00:23:52,230
you can then add targets to that Gateway.

546
00:23:52,230 --> 00:23:55,050
So add a bunch of API end points in there,

547
00:23:55,050 --> 00:23:57,120
maybe throw in a few Lambdas,

548
00:23:57,120 --> 00:23:59,533
get a couple of existing MCP
servers that have been built

549
00:23:59,533 --> 00:24:01,830
or maybe third party ones,

550
00:24:01,830 --> 00:24:03,570
and now you've got a Gateway

551
00:24:03,570 --> 00:24:07,080
and you can hand that
Gateway to an agent builder

552
00:24:07,080 --> 00:24:09,600
and say these are your tools.

553
00:24:09,600 --> 00:24:10,652
Or you could have multiple of them,

554
00:24:10,652 --> 00:24:12,941
they can discover different Gateways.

555
00:24:12,941 --> 00:24:16,350
But basically, now you've
got agent ready tools

556
00:24:16,350 --> 00:24:20,403
securely at scale to
plug into your agents.

557
00:24:21,630 --> 00:24:23,943
Massive boost in time to value here.

558
00:24:26,370 --> 00:24:28,323
Last cool thing on Gateway.

559
00:24:29,790 --> 00:24:32,550
So you started with maybe a lack of tools.

560
00:24:32,550 --> 00:24:34,237
You can easily get into a situation

561
00:24:34,237 --> 00:24:36,870
where you've got too many tools,

562
00:24:36,870 --> 00:24:37,703
hard to believe,

563
00:24:37,703 --> 00:24:40,410
but pretty quickly you can see hundreds

564
00:24:40,410 --> 00:24:41,771
or maybe thousands of tools.

565
00:24:41,771 --> 00:24:43,830
And guess what happens

566
00:24:43,830 --> 00:24:47,520
if you give a thousand
tools worth of MCP metadata

567
00:24:47,520 --> 00:24:48,573
to your agent?

568
00:24:50,040 --> 00:24:50,910
You don't wanna know.

569
00:24:50,910 --> 00:24:52,083
It's not very pretty.

570
00:24:53,310 --> 00:24:54,600
We have a built-in search.

571
00:24:54,600 --> 00:24:58,440
So instead of handing all
300 tools in this case,

572
00:24:58,440 --> 00:25:00,720
we give you a built-in semantic search.

573
00:25:00,720 --> 00:25:02,190
So as you add tools,

574
00:25:02,190 --> 00:25:04,110
they're automatically indexed.

575
00:25:04,110 --> 00:25:07,530
You can call this MCP search capability.

576
00:25:07,530 --> 00:25:10,440
Now you can do dynamic tool selection.

577
00:25:10,440 --> 00:25:11,476
Instead of doing 300 tools,

578
00:25:11,476 --> 00:25:15,870
give a handful of tools that
are built for that context.

579
00:25:15,870 --> 00:25:19,680
Now you've got faster,
cheaper, and more accurate.

580
00:25:19,680 --> 00:25:22,350
It's pretty rare to get a triple play here

581
00:25:22,350 --> 00:25:24,469
but faster, cheaper, and more accurate

582
00:25:24,469 --> 00:25:26,763
all from doing semantic search.

583
00:25:28,920 --> 00:25:32,130
Okay, there's more.

584
00:25:32,130 --> 00:25:35,760
So today, in the keynote from Matt,

585
00:25:35,760 --> 00:25:37,260
as Vivek mentioned,

586
00:25:37,260 --> 00:25:40,200
we introduced Policy
for AgentCore Gateway.

587
00:25:40,200 --> 00:25:42,360
What's the big deal here?

588
00:25:42,360 --> 00:25:45,653
So you can give permission for
who can access the Gateway,

589
00:25:45,653 --> 00:25:47,583
who can access tools,

590
00:25:48,651 --> 00:25:50,890
and you can have requested tool calls

591
00:25:50,890 --> 00:25:53,430
and then which ones are allowed.

592
00:25:53,430 --> 00:25:54,267
But what you really want

593
00:25:54,267 --> 00:25:56,850
is something a little bit more granular

594
00:25:56,850 --> 00:25:57,683
because what's happening here

595
00:25:57,683 --> 00:26:00,780
is your agent has more autonomy

596
00:26:00,780 --> 00:26:03,750
and you're balancing the
need for that innovation

597
00:26:03,750 --> 00:26:05,940
with the need for control.

598
00:26:05,940 --> 00:26:07,560
You don't wanna risk

599
00:26:07,560 --> 00:26:09,413
getting on the front page
of the Wall Street Journal

600
00:26:09,413 --> 00:26:14,010
with an agent doing a hundred
million dollar mistake.

601
00:26:14,010 --> 00:26:18,150
So you wanna not trust your
agents to do the right thing.

602
00:26:18,150 --> 00:26:20,211
You don't wanna trust your developers

603
00:26:20,211 --> 00:26:22,710
to code up the right controls.

604
00:26:22,710 --> 00:26:24,540
So with policy,

605
00:26:24,540 --> 00:26:28,380
you're able to intercept
every single tool call

606
00:26:28,380 --> 00:26:32,760
and apply policies that your
administrators can put in place

607
00:26:32,760 --> 00:26:35,340
and attach to these Gateways.

608
00:26:35,340 --> 00:26:39,750
It applies those policies
on the fly with low latency

609
00:26:39,750 --> 00:26:42,372
and it does so in a way where
you can define these policies

610
00:26:42,372 --> 00:26:44,490
in natural language

611
00:26:44,490 --> 00:26:49,203
and they're verifiably
correct, verifiably enforced,

612
00:26:50,220 --> 00:26:51,600
and it's deterministic.

613
00:26:51,600 --> 00:26:53,376
So although your agent
is non-deterministic,

614
00:26:53,376 --> 00:26:55,740
which is a good thing,

615
00:26:55,740 --> 00:26:59,160
enforcing policies needs
to be deterministic

616
00:26:59,160 --> 00:27:02,430
and that's what these
policies end up doing for you.

617
00:27:02,430 --> 00:27:03,624
Of course, we've got observability

618
00:27:03,624 --> 00:27:07,470
because you wanna know which
policies were enforced,

619
00:27:07,470 --> 00:27:09,558
why they were enforced,
why do they get denied,

620
00:27:09,558 --> 00:27:12,930
why do they get allowed
and be able to audit that.

621
00:27:12,930 --> 00:27:15,503
And then I clicked one too many times.

622
00:27:15,503 --> 00:27:19,020
So this is keeping your
agents in their lane,

623
00:27:19,020 --> 00:27:23,133
keeping them inbounds while
still allowing innovation.

624
00:27:25,590 --> 00:27:27,990
Okay, great.

625
00:27:27,990 --> 00:27:30,570
We've got a couple of
built in tools as well.

626
00:27:30,570 --> 00:27:32,610
So beyond just using Gateways

627
00:27:32,610 --> 00:27:34,920
to get access to your MCP tools,

628
00:27:34,920 --> 00:27:39,920
what about the power of
LLMs to generate great code?

629
00:27:39,960 --> 00:27:43,710
Why not be able to plug
that into any agent

630
00:27:43,710 --> 00:27:46,230
and make it an instant data analyst?

631
00:27:46,230 --> 00:27:49,110
So here I'm saying in
that sales assist app,

632
00:27:49,110 --> 00:27:51,150
how are my accounts doing?

633
00:27:51,150 --> 00:27:53,670
So it can go grab some data,

634
00:27:53,670 --> 00:27:57,194
but are LMS good at analyzing
large amounts of data?

635
00:27:57,194 --> 00:27:59,190
Not necessarily.

636
00:27:59,190 --> 00:28:01,590
They're a lot better at generating code

637
00:28:01,590 --> 00:28:03,020
and now you've got a secure sandbox

638
00:28:03,020 --> 00:28:05,430
that you just plug in as a tool

639
00:28:05,430 --> 00:28:07,980
and your agent says, "Okay,
I know where to run this."

640
00:28:07,980 --> 00:28:09,630
And you've got great results,

641
00:28:09,630 --> 00:28:12,013
you can generate visualizations,

642
00:28:12,013 --> 00:28:14,160
whatever you need actually

643
00:28:14,160 --> 00:28:17,043
that the agent can generate on its own.

644
00:28:17,970 --> 00:28:20,455
Secondly, although I mentioned earlier

645
00:28:20,455 --> 00:28:24,540
a lot of nice APIs, data sources,

646
00:28:24,540 --> 00:28:27,270
who here has a few legacy applications?

647
00:28:27,270 --> 00:28:29,490
Maybe they're built five years ago.

648
00:28:29,490 --> 00:28:31,724
Maybe 25 years ago.

649
00:28:31,724 --> 00:28:35,250
They're still running
mission critical processes.

650
00:28:35,250 --> 00:28:37,249
So we're not gonna reinvent those

651
00:28:37,249 --> 00:28:39,780
in order to build an agent.

652
00:28:39,780 --> 00:28:43,803
Why not use a browser and
automate access to those?

653
00:28:45,420 --> 00:28:48,840
LLMs are great now at
interpreting screenshots.

654
00:28:48,840 --> 00:28:52,530
And then you can have your
agent click at a certain field,

655
00:28:52,530 --> 00:28:54,450
navigate to a different screen,

656
00:28:54,450 --> 00:28:55,953
scroll down, scroll up,

657
00:28:56,790 --> 00:28:59,160
copy the data into another field,

658
00:28:59,160 --> 00:29:00,330
all of this possible.

659
00:29:00,330 --> 00:29:02,340
We give you a headless browser.

660
00:29:02,340 --> 00:29:05,313
You just plug it in as a tool
and you're off and running.

661
00:29:08,910 --> 00:29:12,210
Okay, now let's quickly cover

662
00:29:12,210 --> 00:29:16,350
three cross-cutting concerns.

663
00:29:16,350 --> 00:29:18,243
First one is security.

664
00:29:19,470 --> 00:29:22,590
It's all well and good to
come up with a great agent,

665
00:29:22,590 --> 00:29:24,660
but there's table stakes here.

666
00:29:24,660 --> 00:29:26,520
It's got to be secure.

667
00:29:26,520 --> 00:29:27,930
And this is a challenging problem,

668
00:29:27,930 --> 00:29:30,990
user talking to an app,
talking to an agent,

669
00:29:30,990 --> 00:29:32,730
talking to another agent,

670
00:29:32,730 --> 00:29:36,300
talking to tools that are
internal and third party tools.

671
00:29:36,300 --> 00:29:38,280
You better get that right.

672
00:29:38,280 --> 00:29:39,798
You can't afford to let the wrong user

673
00:29:39,798 --> 00:29:43,560
get access to the data or
take the wrong actions.

674
00:29:43,560 --> 00:29:45,360
So this is pretty difficult.

675
00:29:45,360 --> 00:29:48,690
An AgentCore built into
runtime and gateway

676
00:29:48,690 --> 00:29:51,720
takes care of inbound and outbound off.

677
00:29:51,720 --> 00:29:53,610
On the inbound side,

678
00:29:53,610 --> 00:29:56,880
you use whatever identity
provider you'd like,

679
00:29:56,880 --> 00:29:58,800
maybe it's Microsoft Entra,

680
00:29:58,800 --> 00:30:01,770
maybe it's Ping or Okta or Auth0,

681
00:30:01,770 --> 00:30:05,500
plug that in and we take
care of who is the user

682
00:30:05,500 --> 00:30:07,833
and how are they allowed
to use this agent.

683
00:30:08,880 --> 00:30:12,180
On the outbound side, we can say,

684
00:30:12,180 --> 00:30:15,745
is this user allowed to, using this agent,

685
00:30:15,745 --> 00:30:17,883
get access to these tools?

686
00:30:18,810 --> 00:30:20,490
And we plug in again on this side

687
00:30:20,490 --> 00:30:22,380
with your credential providers.

688
00:30:22,380 --> 00:30:24,270
You need Salesforce data.

689
00:30:24,270 --> 00:30:28,170
You want ServiceNow or
Workday, JIRA, whatever it is.

690
00:30:28,170 --> 00:30:30,355
There's either an API key

691
00:30:30,355 --> 00:30:33,570
or an OAuth credentials,

692
00:30:33,570 --> 00:30:36,630
maybe IAM in some cases.

693
00:30:36,630 --> 00:30:38,940
We automatically let you configure those

694
00:30:38,940 --> 00:30:41,460
as outbound providers

695
00:30:41,460 --> 00:30:45,840
and then we make sure that
there's secure access end to end

696
00:30:45,840 --> 00:30:49,953
on behalf of a user or on
behalf of an agent autonomously.

697
00:30:51,270 --> 00:30:53,253
This is super important,

698
00:30:54,540 --> 00:30:57,570
and please don't try
to do this one at home.

699
00:30:57,570 --> 00:30:59,569
Don't try to do this one yourself.

700
00:30:59,569 --> 00:31:02,100
It's scary complicated under the hood.

701
00:31:02,100 --> 00:31:04,600
I've tried to make it look
pretty easy right here.

702
00:31:06,330 --> 00:31:11,330
Another table stakes piece of
the puzzle is observability.

703
00:31:11,700 --> 00:31:13,530
Never trust your agents.

704
00:31:13,530 --> 00:31:15,268
Never put an agent into production

705
00:31:15,268 --> 00:31:19,050
without being able to know
exactly what it's doing.

706
00:31:19,050 --> 00:31:21,030
You've got to be able to go back

707
00:31:21,030 --> 00:31:22,890
and find out exactly what it did.

708
00:31:22,890 --> 00:31:24,720
Here's the request.

709
00:31:24,720 --> 00:31:26,580
Here's the plan put together.

710
00:31:26,580 --> 00:31:28,260
here's the steps that it took.

711
00:31:28,260 --> 00:31:31,050
Maybe it redirected and
tried something else.

712
00:31:31,050 --> 00:31:32,822
This is the inputs that
it passed to the tool.

713
00:31:32,822 --> 00:31:34,680
This is what it got back.

714
00:31:34,680 --> 00:31:37,380
Maybe it got back an error and it retried.

715
00:31:37,380 --> 00:31:39,873
You need every bit of that.

716
00:31:41,190 --> 00:31:42,390
Auditors are gonna come in.

717
00:31:42,390 --> 00:31:43,410
Legal's gonna come in.

718
00:31:43,410 --> 00:31:46,350
Why did this agent do this?

719
00:31:46,350 --> 00:31:48,240
You've gotta be able to
have full observability.

720
00:31:48,240 --> 00:31:50,700
We've got that across
all of these services.

721
00:31:50,700 --> 00:31:53,370
We also give you dashboards

722
00:31:53,370 --> 00:31:56,385
so you can easily see
not only typical metrics

723
00:31:56,385 --> 00:32:00,330
like latency, error rates, and so forth.

724
00:32:00,330 --> 00:32:03,180
You can see the end-to-end visualization,

725
00:32:03,180 --> 00:32:07,440
a hierarchical timeline,
the full trajectory,

726
00:32:07,440 --> 00:32:10,080
the inputs, the outputs, it's all there.

727
00:32:10,080 --> 00:32:14,460
And in case you were wondering,
yes, we have open telemetry,

728
00:32:14,460 --> 00:32:19,020
so if you want to use Dynatrace
or Datadog or Langfuse,

729
00:32:19,020 --> 00:32:21,573
anything that you'd like, go for it.

730
00:32:25,440 --> 00:32:28,863
Okay, last cross-cutting concern,

731
00:32:29,940 --> 00:32:32,970
arguably the most important one so far.

732
00:32:32,970 --> 00:32:35,190
Drum roll, please.

733
00:32:35,190 --> 00:32:38,010
How do you know how good your agents are?

734
00:32:38,010 --> 00:32:38,947
You've got to be able to measure

735
00:32:38,947 --> 00:32:43,500
are they doing the right thing, right?

736
00:32:43,500 --> 00:32:46,376
So this includes are they being safe?

737
00:32:46,376 --> 00:32:48,540
Are they being responsible?

738
00:32:48,540 --> 00:32:49,500
Are they being polite?

739
00:32:49,500 --> 00:32:51,000
Do they have the right tone?

740
00:32:51,000 --> 00:32:53,640
Are they giving back the right answers?

741
00:32:53,640 --> 00:32:54,960
Are they making the right tool calls?

742
00:32:54,960 --> 00:32:57,630
Are they passing the right parameters?

743
00:32:57,630 --> 00:32:59,940
If you don't know the answers to these,

744
00:32:59,940 --> 00:33:01,440
you're not doing a good enough job

745
00:33:01,440 --> 00:33:04,800
for mission critical agents in production.

746
00:33:04,800 --> 00:33:06,693
So in today's keynote,

747
00:33:07,560 --> 00:33:10,380
we introduced AgentCore evaluations.

748
00:33:10,380 --> 00:33:11,583
So what does that do?

749
00:33:13,200 --> 00:33:16,140
So in under a minute,

750
00:33:16,140 --> 00:33:17,580
you can go to the console,

751
00:33:17,580 --> 00:33:19,230
pick your agent,

752
00:33:19,230 --> 00:33:22,031
pick a set of metrics
that you want to turn on,

753
00:33:22,031 --> 00:33:24,663
say where your traces are coming from,

754
00:33:25,560 --> 00:33:27,780
turn on a sampling rate,

755
00:33:27,780 --> 00:33:28,893
and then say go.

756
00:33:30,000 --> 00:33:32,790
Any traffic that shows up in that agent

757
00:33:32,790 --> 00:33:34,863
is gonna get automatically evaluated.

758
00:33:35,760 --> 00:33:37,290
So AgentCore evaluations

759
00:33:37,290 --> 00:33:40,222
will evaluate each of those
metrics on those traces

760
00:33:40,222 --> 00:33:42,630
and give you scores.

761
00:33:42,630 --> 00:33:45,660
And then not only will give
you a number or a label,

762
00:33:45,660 --> 00:33:47,550
but it'll say why.

763
00:33:47,550 --> 00:33:50,250
So why did it decide
that that was the score?

764
00:33:50,250 --> 00:33:53,640
You'll see the reasoning
and that's all logged.

765
00:33:53,640 --> 00:33:55,110
You'll get dashboards

766
00:33:55,110 --> 00:33:58,410
and you can even do on demand evaluations.

767
00:33:58,410 --> 00:34:00,779
So this is huge, critical,

768
00:34:00,779 --> 00:34:05,253
and it was launched today in
public preview in AgentCore.

769
00:34:07,440 --> 00:34:11,670
So this is the entire AgentCore platform.

770
00:34:11,670 --> 00:34:13,339
It'll probably get bigger
and better over time,

771
00:34:13,339 --> 00:34:16,350
but this is where it stands today.

772
00:34:16,350 --> 00:34:18,270
And as Vivek mentioned,

773
00:34:18,270 --> 00:34:19,500
you can pick and choose here.

774
00:34:19,500 --> 00:34:22,440
These are composable services.

775
00:34:22,440 --> 00:34:25,200
Decide which ones you're
having challenges with,

776
00:34:25,200 --> 00:34:28,290
kick the tires on that,
integrate what you need,

777
00:34:28,290 --> 00:34:33,290
use any framework, any
model, OAuth, OTEL, A2A, MCP.

778
00:34:33,390 --> 00:34:35,523
All of the right acronyms are there.

779
00:34:37,500 --> 00:34:40,468
So let's see a quick demo here

780
00:34:40,468 --> 00:34:44,250
and then I'll bring you
Sarbashis from Ericsson

781
00:34:44,250 --> 00:34:46,683
to dive in even further.

782
00:34:48,300 --> 00:34:49,980
So here's the scenario.

783
00:34:49,980 --> 00:34:52,740
I've said any framework, any model,

784
00:34:52,740 --> 00:34:53,760
and I've said A2A,

785
00:34:53,760 --> 00:34:55,620
but if you're not sure

786
00:34:55,620 --> 00:34:57,840
if you really believe that that's true,

787
00:34:57,840 --> 00:34:59,013
let's see it in action.

788
00:35:00,870 --> 00:35:02,191
So in this example,

789
00:35:02,191 --> 00:35:05,160
I've got an orchestrator

790
00:35:05,160 --> 00:35:07,293
using Google ADK and Gemini.

791
00:35:08,367 --> 00:35:10,257
You can see a couple of subagents,

792
00:35:10,257 --> 00:35:12,330
one using Strands and Bedrock models,

793
00:35:12,330 --> 00:35:15,300
another one using OpenAI and GPT-4,

794
00:35:15,300 --> 00:35:17,343
and they're communicating using A2A.

795
00:35:18,190 --> 00:35:22,653
And are you gonna boot me
off the stage, Precious?

796
00:35:24,000 --> 00:35:25,050
Am I running too far?

797
00:35:25,050 --> 00:35:27,423
Okay, I'll be done in about two minutes.

798
00:35:28,350 --> 00:35:30,337
So we're using A2A.

799
00:35:30,337 --> 00:35:32,641
We're using AgentCore
Gateway to access tools.

800
00:35:32,641 --> 00:35:35,160
We've got memory and observability,

801
00:35:35,160 --> 00:35:36,930
and let's keep going here.

802
00:35:36,930 --> 00:35:37,920
Here's the UI.

803
00:35:37,920 --> 00:35:39,840
We've got a JavaScript UI on the left.

804
00:35:39,840 --> 00:35:43,920
We're showing you access
to A2A agent cards.

805
00:35:43,920 --> 00:35:45,630
I'm handing it a task.

806
00:35:45,630 --> 00:35:46,830
I'm asking it a question.

807
00:35:46,830 --> 00:35:50,280
It's actually delegating
that to one of the sub-agents

808
00:35:50,280 --> 00:35:51,750
that's using a different framework,

809
00:35:51,750 --> 00:35:54,510
different model, uses A2A to get there.

810
00:35:54,510 --> 00:35:56,403
It comes back with an answer.

811
00:35:57,270 --> 00:35:59,730
I'll scroll ahead here.

812
00:35:59,730 --> 00:36:01,323
Too far, sorry.

813
00:36:02,550 --> 00:36:05,463
I don't like this laptop.

814
00:36:09,165 --> 00:36:10,263
Let's see.

815
00:36:21,840 --> 00:36:23,823
Oh man, isn't this great?

816
00:36:29,340 --> 00:36:30,513
My apologies.

817
00:36:33,870 --> 00:36:35,820
Okay, it's not gonna cooperate with me.

818
00:36:36,750 --> 00:36:39,874
So we are using A2A to
have a conversation,

819
00:36:39,874 --> 00:36:42,810
it's using multiple of those servers.

820
00:36:42,810 --> 00:36:44,003
This is at the end here,

821
00:36:44,003 --> 00:36:47,940
we're showing AgentCore memory as well.

822
00:36:47,940 --> 00:36:48,773
So we're browsing,

823
00:36:48,773 --> 00:36:50,850
we're showing you the short term memory,

824
00:36:50,850 --> 00:36:53,280
the detailed conversations were tracked

825
00:36:53,280 --> 00:36:54,630
showing you the long-term memory

826
00:36:54,630 --> 00:36:57,990
where it learned some facts
and was able to surface those.

827
00:36:57,990 --> 00:36:59,310
So with that,

828
00:36:59,310 --> 00:37:04,310
let me hand it off to
Sabarshis from Ericsson

829
00:37:04,680 --> 00:37:06,812
to talk about AgentCore.

830
00:37:06,812 --> 00:37:09,979
(audience applauding)

831
00:37:13,080 --> 00:37:13,980
- Thank you, Mark.

832
00:37:15,990 --> 00:37:17,400
Hello, everyone.

833
00:37:17,400 --> 00:37:19,410
You just heard about AgentCore

834
00:37:19,410 --> 00:37:20,767
and how it bridges the gap

835
00:37:20,767 --> 00:37:23,760
between proof of concept to production.

836
00:37:23,760 --> 00:37:27,270
Now I'm going to show you how
this looks like in practice.

837
00:37:27,270 --> 00:37:28,650
My name is Sabarshis Das.

838
00:37:28,650 --> 00:37:32,760
I am a principal data scientist
and tech lead at Ericsson.

839
00:37:32,760 --> 00:37:34,710
Within Ericsson, we are building

840
00:37:34,710 --> 00:37:38,040
a number of agentic solution
across different areas,

841
00:37:38,040 --> 00:37:40,525
and today I'm going to show
you one of our agentic solution

842
00:37:40,525 --> 00:37:44,790
that reduces our network
engineers research time

843
00:37:44,790 --> 00:37:46,503
from days to minute.

844
00:37:47,460 --> 00:37:50,583
Before that, let me give you
some context about Ericsson.

845
00:37:51,960 --> 00:37:54,071
If you think about global connectivity,

846
00:37:54,071 --> 00:37:56,850
Ericsson is at the heart of it.

847
00:37:56,850 --> 00:37:59,373
Right now, as I speak to you,

848
00:38:00,450 --> 00:38:04,560
50% of the 5G traffic throughout the world

849
00:38:04,560 --> 00:38:07,503
passes through the
technology that we build.

850
00:38:09,780 --> 00:38:13,200
With such a scale, it comes complexities.

851
00:38:13,200 --> 00:38:16,650
The question is that how do
we keep our network engineer

852
00:38:16,650 --> 00:38:19,443
efficient in such a complex environment?

853
00:38:20,850 --> 00:38:23,910
In reality, our network
engineers were trapped

854
00:38:23,910 --> 00:38:25,323
in knowledge silos.

855
00:38:26,430 --> 00:38:27,273
Let me explain.

856
00:38:28,320 --> 00:38:31,380
A network engineer working on his features

857
00:38:31,380 --> 00:38:35,610
need to look into thousands
of different documents

858
00:38:35,610 --> 00:38:39,480
just to get to understand what
this feature is all about.

859
00:38:39,480 --> 00:38:41,370
And then they need to find out

860
00:38:41,370 --> 00:38:43,913
what exactly this has been implemented

861
00:38:43,913 --> 00:38:47,160
in our millions of lines of code base

862
00:38:47,160 --> 00:38:50,880
that is distributed on hundreds
of different subsystems.

863
00:38:50,880 --> 00:38:53,163
You can imagine this takes days.

864
00:38:54,900 --> 00:38:57,480
Not because the work is hard

865
00:38:57,480 --> 00:38:59,820
but the information is fragmented,

866
00:38:59,820 --> 00:39:01,353
the knowledge is isolated.

867
00:39:02,610 --> 00:39:05,316
I can imagine that many
of you have also seen this

868
00:39:05,316 --> 00:39:06,993
in your organization.

869
00:39:08,100 --> 00:39:11,520
Our goal here is to fuse the information

870
00:39:11,520 --> 00:39:13,830
across the different knowledge silos

871
00:39:13,830 --> 00:39:17,613
to make a unified
understanding of the system.

872
00:39:19,530 --> 00:39:20,463
How to do that?

873
00:39:22,174 --> 00:39:24,000
Here is our solution.

874
00:39:24,000 --> 00:39:27,060
We have created a
three-layered architecture

875
00:39:27,060 --> 00:39:29,994
to eliminate the knowledge silos.

876
00:39:29,994 --> 00:39:32,490
As you can see at the bottom layers,

877
00:39:32,490 --> 00:39:35,370
we have industry standards,
we have our code base,

878
00:39:35,370 --> 00:39:36,960
we have product information.

879
00:39:36,960 --> 00:39:39,810
These are all fragmented information.

880
00:39:39,810 --> 00:39:41,610
We need to process this document

881
00:39:41,610 --> 00:39:45,540
in a way that it is ready to
consume to the next layer,

882
00:39:45,540 --> 00:39:46,800
the knowledge layer.

883
00:39:46,800 --> 00:39:48,420
That's why we have developed

884
00:39:48,420 --> 00:39:50,850
advanced data processing pipeline.

885
00:39:50,850 --> 00:39:52,890
In the advanced data processing pipeline,

886
00:39:52,890 --> 00:39:57,240
we fetch the data across
different knowledge silos,

887
00:39:57,240 --> 00:40:00,480
pass through GenAI
pre-processing pipeline.

888
00:40:00,480 --> 00:40:04,740
The goal for the GenAI
pre-processing pipeline is to fetch,

889
00:40:04,740 --> 00:40:07,020
is to process the data, clean the data,

890
00:40:07,020 --> 00:40:09,542
and also the key is to extract information

891
00:40:09,542 --> 00:40:12,030
from different modalities.

892
00:40:12,030 --> 00:40:12,960
Once it is done,

893
00:40:12,960 --> 00:40:17,190
it's stored the data to
different AWS storage,

894
00:40:17,190 --> 00:40:18,754
depending on what data type.

895
00:40:18,754 --> 00:40:22,080
It can be AWS Bedrock knowledge base

896
00:40:22,080 --> 00:40:23,703
or it can be a graph database.

897
00:40:26,760 --> 00:40:28,050
Once the data is ready,

898
00:40:28,050 --> 00:40:31,563
it fed to the next layer
called knowledge layer.

899
00:40:32,460 --> 00:40:34,890
This knowledge layer
consists of three component

900
00:40:34,890 --> 00:40:36,060
as you can see.

901
00:40:36,060 --> 00:40:37,890
We have a specialized agents.

902
00:40:37,890 --> 00:40:42,660
These are agents that are
experts you can think about

903
00:40:42,660 --> 00:40:44,280
in different areas.

904
00:40:44,280 --> 00:40:45,558
So we are running a number

905
00:40:45,558 --> 00:40:48,510
of these type of specialized agents.

906
00:40:48,510 --> 00:40:51,930
Second, we have specialized model.

907
00:40:51,930 --> 00:40:53,006
These models are specialized

908
00:40:53,006 --> 00:40:56,160
in a sense that we have
trained those model

909
00:40:56,160 --> 00:41:00,963
with our in-house data
and also the code base.

910
00:41:01,920 --> 00:41:05,610
And the next part are
the developer's tools.

911
00:41:05,610 --> 00:41:08,100
These are the tools our
network engineers uses

912
00:41:08,100 --> 00:41:09,663
on a daily basis.

913
00:41:10,620 --> 00:41:12,870
The knowledge layer is
connected on the top

914
00:41:12,870 --> 00:41:14,190
with an orchestration layer

915
00:41:14,190 --> 00:41:17,340
where the agentic
orchestration takes place

916
00:41:17,340 --> 00:41:19,657
and communicate through
the knowledge layer

917
00:41:19,657 --> 00:41:22,173
using MCP protocol.

918
00:41:24,360 --> 00:41:25,193
The key here,

919
00:41:25,193 --> 00:41:27,452
we are not just connecting different tools

920
00:41:27,452 --> 00:41:29,580
in this layer architecture,

921
00:41:29,580 --> 00:41:33,003
instead we are enabling
system comprehension,

922
00:41:34,140 --> 00:41:36,832
the system that understand
the whole workflow

923
00:41:36,832 --> 00:41:38,703
of our network engineer.

924
00:41:39,900 --> 00:41:42,690
Let me show you how
these systems looks like

925
00:41:42,690 --> 00:41:47,160
when you deploy this on
production using AgentCore.

926
00:41:47,160 --> 00:41:51,870
So this is our architecture
that is deployed on AgentCore.

927
00:41:51,870 --> 00:41:54,330
Our network engineer
interact with the system

928
00:41:54,330 --> 00:41:55,890
using natural language,

929
00:41:55,890 --> 00:41:59,240
just like asking a
question to your colleague,

930
00:41:59,240 --> 00:42:02,000
that there very commonly one
question people are asking

931
00:42:02,000 --> 00:42:04,620
that what is a HARQ timer.

932
00:42:04,620 --> 00:42:07,800
Any of you have any
knowledge about HARQ timer?

933
00:42:07,800 --> 00:42:09,183
Could you raise your hand?

934
00:42:11,010 --> 00:42:12,990
I can imagine that this
is a very specific,

935
00:42:12,990 --> 00:42:15,330
telecom specific query questions.

936
00:42:15,330 --> 00:42:18,120
So then this next step

937
00:42:18,120 --> 00:42:20,820
is the Amazon queue developers

938
00:42:20,820 --> 00:42:21,653
or the front end.

939
00:42:21,653 --> 00:42:22,860
These are the agentic system

940
00:42:22,860 --> 00:42:25,860
that basically interprets the queries

941
00:42:25,860 --> 00:42:30,120
and try to identify what
specialized knowledge needed

942
00:42:30,120 --> 00:42:31,320
to answer this question.

943
00:42:31,320 --> 00:42:36,120
And based on that, it request
securely through the Gateway

944
00:42:36,120 --> 00:42:38,100
to different specialized agents

945
00:42:38,100 --> 00:42:40,923
that are deployed on AgentCore runtime.

946
00:42:42,060 --> 00:42:44,059
AgentCore runtime gives us the flexibility

947
00:42:44,059 --> 00:42:47,460
to deploy any framework,

948
00:42:47,460 --> 00:42:49,830
any open source framework on this,

949
00:42:49,830 --> 00:42:52,050
and these are serverless.

950
00:42:52,050 --> 00:42:55,230
So in this example you can
see that we have 3GPP agent,

951
00:42:55,230 --> 00:42:58,500
which is an expert in telecom standards.

952
00:42:58,500 --> 00:43:00,840
We have code generation agent.

953
00:43:00,840 --> 00:43:04,800
This is an agent that
help our network engineer

954
00:43:04,800 --> 00:43:06,300
to generate code.

955
00:43:06,300 --> 00:43:11,280
This agent specially powered
by in-house trained LLM.

956
00:43:11,280 --> 00:43:13,740
Ericsson builds its own ASICs

957
00:43:13,740 --> 00:43:17,160
and the architecture is just
a proprietary information

958
00:43:17,160 --> 00:43:20,340
of the self-coating models
that is available today

959
00:43:20,340 --> 00:43:23,460
is not aware of those information.

960
00:43:23,460 --> 00:43:24,293
And then another example,

961
00:43:24,293 --> 00:43:27,150
you can see the RAN system design agent,

962
00:43:27,150 --> 00:43:30,630
which is an expert in designing the system

963
00:43:30,630 --> 00:43:33,030
and as well as how we are configuring

964
00:43:33,030 --> 00:43:34,623
within Ericsson context.

965
00:43:35,580 --> 00:43:38,939
All these agents sits on in
strong knowledge foundation

966
00:43:38,939 --> 00:43:42,150
as you can see on the bottom
part in the knowledge layer

967
00:43:42,150 --> 00:43:45,363
and that has been created
using advanced data processing.

968
00:43:46,290 --> 00:43:49,339
The key here that all these
agent that you can see

969
00:43:49,339 --> 00:43:53,640
running on these AgentCore runtimes,

970
00:43:53,640 --> 00:43:55,263
they do not work insolation.

971
00:43:56,310 --> 00:43:59,100
Instead they collaborate with each other.

972
00:43:59,100 --> 00:44:00,750
They shared the context

973
00:44:00,750 --> 00:44:04,863
and they build their insight
based on each other's finding.

974
00:44:07,080 --> 00:44:11,220
We are also leveraging
other AgentCore services

975
00:44:11,220 --> 00:44:15,690
that makes this architecture
enterprise-ready.

976
00:44:15,690 --> 00:44:18,360
For example, AgentCore observability

977
00:44:18,360 --> 00:44:20,610
gives us the flexibility

978
00:44:20,610 --> 00:44:23,670
to check at a granular level

979
00:44:23,670 --> 00:44:26,940
how our specialized agent behave and why.

980
00:44:26,940 --> 00:44:29,430
The identity also gives us a secure way

981
00:44:29,430 --> 00:44:31,173
to keep access control.

982
00:44:33,120 --> 00:44:37,380
Now, the question is that
how our network engineers

983
00:44:37,380 --> 00:44:38,670
uses this system.

984
00:44:38,670 --> 00:44:41,250
So you can see that
generally, as I mentioned,

985
00:44:41,250 --> 00:44:44,400
they interact with natural language.

986
00:44:44,400 --> 00:44:46,500
So this is an example question.

987
00:44:46,500 --> 00:44:48,450
Explain how HARQ timer works

988
00:44:48,450 --> 00:44:50,910
and elaborate in downlink design.

989
00:44:50,910 --> 00:44:53,562
Identify and list the main
implementation component

990
00:44:53,562 --> 00:44:55,410
in the code.

991
00:44:55,410 --> 00:44:58,140
As you can see, this has multiple parts

992
00:44:58,140 --> 00:44:59,910
asking about HARQ timers

993
00:44:59,910 --> 00:45:02,670
and also implementation in the code.

994
00:45:02,670 --> 00:45:05,940
As you can imagine that
a typical RAG solution

995
00:45:05,940 --> 00:45:08,144
is not going to give you the answer

996
00:45:08,144 --> 00:45:11,223
that our network engineer is asking for.

997
00:45:12,840 --> 00:45:15,600
In our case with our agentic solution,

998
00:45:15,600 --> 00:45:19,830
first, the RAN system
design agent kicked in

999
00:45:19,830 --> 00:45:22,440
and it is a deep research agent.

1000
00:45:22,440 --> 00:45:25,680
What it does is it looked for hundreds

1001
00:45:25,680 --> 00:45:27,300
of different documents,

1002
00:45:27,300 --> 00:45:30,690
try to identify what is this HARQ timer,

1003
00:45:30,690 --> 00:45:33,693
and generate a deep research output.

1004
00:45:34,890 --> 00:45:35,952
And this deep research output

1005
00:45:35,952 --> 00:45:40,952
then fend to the next agent
is our AI code search.

1006
00:45:41,070 --> 00:45:44,850
AI code search able to find
out from natural language

1007
00:45:44,850 --> 00:45:47,267
where exactly it has been implemented

1008
00:45:47,267 --> 00:45:50,973
by looking at our millions
of lines of code base.

1009
00:45:52,110 --> 00:45:53,190
Once it is done,

1010
00:45:53,190 --> 00:45:57,630
it pass on the output to the
next Ericsson silicon LLM.

1011
00:45:57,630 --> 00:46:00,930
And this is also another
in-house trained LLM

1012
00:46:00,930 --> 00:46:03,063
capable of explaining the code.

1013
00:46:05,010 --> 00:46:05,850
As you can see,

1014
00:46:05,850 --> 00:46:09,900
all these agents is not
going to work in isolation

1015
00:46:09,900 --> 00:46:12,840
but they collaborate
and share the context.

1016
00:46:12,840 --> 00:46:15,540
At the end, the network engineer

1017
00:46:15,540 --> 00:46:18,870
will not just get a chat bot response.

1018
00:46:18,870 --> 00:46:21,750
Instead a system level understanding

1019
00:46:21,750 --> 00:46:24,150
from the theory to the architecture

1020
00:46:24,150 --> 00:46:26,100
to the implementation in the code

1021
00:46:26,100 --> 00:46:29,820
and all connected how the features works.

1022
00:46:29,820 --> 00:46:34,530
Let me show you quickly
two example of the output.

1023
00:46:34,530 --> 00:46:39,530
So this is an output generated
from our deep research agent.

1024
00:46:39,600 --> 00:46:42,300
As you can see that it's a very
comprehensive documentation

1025
00:46:42,300 --> 00:46:47,070
and also it generate the images on the fly

1026
00:46:47,070 --> 00:46:48,390
that helps our network engineer

1027
00:46:48,390 --> 00:46:50,223
to understand the concept easily.

1028
00:46:51,630 --> 00:46:52,860
This is another one

1029
00:46:52,860 --> 00:46:56,550
where our Ericsson silicon
LLM explain the code

1030
00:46:56,550 --> 00:46:58,314
and you can see that it's not explaining

1031
00:46:58,314 --> 00:47:00,360
just a syntactical explanation.

1032
00:47:00,360 --> 00:47:03,960
Instead it's try to connect
it with the concept.

1033
00:47:03,960 --> 00:47:06,150
Now, imagine a network engineer

1034
00:47:06,150 --> 00:47:07,890
started working on these features

1035
00:47:07,890 --> 00:47:10,620
have to do all these things manually.

1036
00:47:10,620 --> 00:47:14,370
Looking at the features like
a deep research on that,

1037
00:47:14,370 --> 00:47:18,000
finding the implementation
in the code base and connect.

1038
00:47:18,000 --> 00:47:21,180
And this takes, depending
on their experience,

1039
00:47:21,180 --> 00:47:23,010
three to five days.

1040
00:47:23,010 --> 00:47:27,120
Using our solution deployed on AgentCore,

1041
00:47:27,120 --> 00:47:30,000
we can get it in less than seven minute.

1042
00:47:30,000 --> 00:47:34,590
This is a 99% reduction
in the research time

1043
00:47:34,590 --> 00:47:36,033
for our network engineer.

1044
00:47:37,080 --> 00:47:38,220
We have built the system.

1045
00:47:38,220 --> 00:47:41,550
The next question that how
do we evaluate this system.

1046
00:47:41,550 --> 00:47:45,150
For evaluation, we are
using a dual approach.

1047
00:47:45,150 --> 00:47:48,570
First of all, using an
automated script or framework,

1048
00:47:48,570 --> 00:47:51,720
we can easily identify the
consistency and correctness,

1049
00:47:51,720 --> 00:47:55,385
but it's also important to
evaluate through human expert

1050
00:47:55,385 --> 00:47:57,150
for the accuracy

1051
00:47:57,150 --> 00:48:00,033
and whether it's meets
our network engineer,

1052
00:48:02,100 --> 00:48:04,530
our network engineer's
expectations or not.

1053
00:48:04,530 --> 00:48:08,220
By combining the human
feedback that we have received

1054
00:48:08,220 --> 00:48:09,990
and also the value,

1055
00:48:09,990 --> 00:48:13,293
it gives us the confidence on
the reliability of the system.

1056
00:48:14,820 --> 00:48:16,860
While building this agentic solution,

1057
00:48:16,860 --> 00:48:19,470
there are a lot of learnings for us

1058
00:48:19,470 --> 00:48:22,323
and let me share the important ones.

1059
00:48:23,880 --> 00:48:26,610
It's a perfect timing,
we say, of our AgentCore.

1060
00:48:26,610 --> 00:48:28,542
We have been building this
type of specialized agent

1061
00:48:28,542 --> 00:48:30,270
for some times

1062
00:48:30,270 --> 00:48:31,680
and we reached to a point

1063
00:48:31,680 --> 00:48:34,890
where scalability was an issue for us.

1064
00:48:34,890 --> 00:48:36,285
When we see AgentCore,

1065
00:48:36,285 --> 00:48:39,843
it feels like it's exactly what we needed.

1066
00:48:41,700 --> 00:48:45,930
Next is that involve
the domain expert early.

1067
00:48:45,930 --> 00:48:48,280
What I mean is that if you are developing

1068
00:48:48,280 --> 00:48:49,740
an agentic solution,

1069
00:48:49,740 --> 00:48:53,010
my recommendation you
involve your domain expert

1070
00:48:53,010 --> 00:48:54,060
from the day one.

1071
00:48:54,060 --> 00:48:58,440
For us, the feedback that we
receive from the domain expert

1072
00:48:58,440 --> 00:49:00,690
about how our network engineer works,

1073
00:49:00,690 --> 00:49:02,070
what are their behaviors,

1074
00:49:02,070 --> 00:49:03,660
and what are their pain point

1075
00:49:03,660 --> 00:49:07,023
help us to design these
specialized agents.

1076
00:49:09,240 --> 00:49:12,570
Third is important of
unifying the knowledge.

1077
00:49:12,570 --> 00:49:15,600
When you connect your data

1078
00:49:15,600 --> 00:49:18,420
and make a unified knowledge base

1079
00:49:18,420 --> 00:49:21,270
from industry standards code base,

1080
00:49:21,270 --> 00:49:23,207
your product documentation,

1081
00:49:23,207 --> 00:49:26,280
you get a system level understanding

1082
00:49:26,280 --> 00:49:29,217
and that overall improve the accuracy

1083
00:49:29,217 --> 00:49:31,680
of the answers that you get.

1084
00:49:31,680 --> 00:49:35,583
And also, at the same time,
it's remove any ambiguities.

1085
00:49:37,230 --> 00:49:39,780
Last but not the least,

1086
00:49:39,780 --> 00:49:44,400
infrastructures matters
even more than we think of.

1087
00:49:44,400 --> 00:49:48,300
Using AgentCore, our
network engineers focus more

1088
00:49:48,300 --> 00:49:51,660
on developing the agentic
structure architect,

1089
00:49:51,660 --> 00:49:54,990
agentic structures and as well
as how the agent will behave.

1090
00:49:54,990 --> 00:49:58,500
All the heavy lifting is
done by the AgentCore.

1091
00:49:58,500 --> 00:49:59,333
As a result,

1092
00:49:59,333 --> 00:50:02,733
the development life cycles
improved significantly.

1093
00:50:04,230 --> 00:50:06,000
Let me summarize here.

1094
00:50:06,000 --> 00:50:10,110
With AgentCore, we have moved beyond

1095
00:50:10,110 --> 00:50:11,670
just answering questions.

1096
00:50:11,670 --> 00:50:13,603
We have developed a system

1097
00:50:13,603 --> 00:50:18,603
that understand how our network
engineers work and think.

1098
00:50:19,320 --> 00:50:22,263
And we are excited what comes next.

1099
00:50:23,820 --> 00:50:25,650
With that, let me close here

1100
00:50:25,650 --> 00:50:29,340
with a perspective from our
organization head, Dag Lindbo.

1101
00:50:29,340 --> 00:50:31,972
By unifying the data and the information,

1102
00:50:31,972 --> 00:50:35,220
AgentCore let us build specialized agents

1103
00:50:35,220 --> 00:50:40,053
that scaled over our tens of
thousands of network engineers.

1104
00:50:41,250 --> 00:50:42,083
Thank you.

1105
00:50:42,083 --> 00:50:43,281
Over to you, Mark.

1106
00:50:43,281 --> 00:50:46,448
(audience applauding)

1107
00:50:47,490 --> 00:50:49,050
- Thanks, Sabarshis.

1108
00:50:49,050 --> 00:50:52,770
Okay, since I was so great at demo one,

1109
00:50:52,770 --> 00:50:55,500
I'll do a quick pass on demo two here.

1110
00:50:55,500 --> 00:50:56,520
I'm just gonna kick it off

1111
00:50:56,520 --> 00:50:58,263
and not try to click any mouse.

1112
00:50:59,880 --> 00:51:01,173
What this is trying to show here

1113
00:51:01,173 --> 00:51:02,527
is I get a lot of questions

1114
00:51:02,527 --> 00:51:05,577
about how well if I'm
using a coding assistant,

1115
00:51:05,577 --> 00:51:09,510
am I able to easily use AgentCore?

1116
00:51:09,510 --> 00:51:11,430
And yes, what this is showing you

1117
00:51:11,430 --> 00:51:15,060
is a scenario where I've
got an existing REST API,

1118
00:51:15,060 --> 00:51:19,110
I've got a URL to it and an API key

1119
00:51:19,110 --> 00:51:22,170
and I kicked off a
session with Kiro to say,

1120
00:51:22,170 --> 00:51:24,330
take that existing API,

1121
00:51:24,330 --> 00:51:27,900
give me a Gateway that
will use that, the MCP,

1122
00:51:27,900 --> 00:51:31,140
give me a Strands agent to use that,

1123
00:51:31,140 --> 00:51:34,860
and then deploy that agent to the cloud,

1124
00:51:34,860 --> 00:51:37,680
write a client, test that client,

1125
00:51:37,680 --> 00:51:40,940
and even write a load
test for me and run that.

1126
00:51:40,940 --> 00:51:42,870
So here it goes.

1127
00:51:42,870 --> 00:51:44,460
So I gave it some context.

1128
00:51:44,460 --> 00:51:46,019
I gave it the URL.

1129
00:51:46,019 --> 00:51:48,240
I gave it the API key.

1130
00:51:48,240 --> 00:51:50,876
Now, it's exploring the
AgentCore command line

1131
00:51:50,876 --> 00:51:53,070
to understand what's offered.

1132
00:51:53,070 --> 00:51:54,234
It figures out, oh I can do this.

1133
00:51:54,234 --> 00:51:55,430
I can create a Gateway.

1134
00:51:55,430 --> 00:51:57,385
I see how to do that.

1135
00:51:57,385 --> 00:52:00,870
I know I've got access to the API.

1136
00:52:00,870 --> 00:52:03,180
So it probes that REST interface,

1137
00:52:03,180 --> 00:52:05,720
extracts the OpenAPI spec.

1138
00:52:05,720 --> 00:52:08,730
Earlier you saw the swagger
user interface there

1139
00:52:08,730 --> 00:52:10,800
describing the API.

1140
00:52:10,800 --> 00:52:12,540
It's able to download that.

1141
00:52:12,540 --> 00:52:15,180
It pops it into a JSON file,

1142
00:52:15,180 --> 00:52:17,190
uploads that to S3,

1143
00:52:17,190 --> 00:52:19,740
and now it's ready to create the Gateway.

1144
00:52:19,740 --> 00:52:22,260
So, it creates the Gateway.

1145
00:52:22,260 --> 00:52:25,530
And here on the left I'm
showing you the actual API spec.

1146
00:52:25,530 --> 00:52:27,720
It was able to retrieve that on the fly.

1147
00:52:27,720 --> 00:52:30,540
And again, I still haven't
written any lines of code.

1148
00:52:30,540 --> 00:52:32,790
I haven't touched any
command lines at all.

1149
00:52:32,790 --> 00:52:35,520
I just said, "Hey, go
do this for me please."

1150
00:52:35,520 --> 00:52:37,710
And the gateway's already created.

1151
00:52:37,710 --> 00:52:38,730
Here, we're just waiting

1152
00:52:38,730 --> 00:52:40,800
for the DNS propagation to complete.

1153
00:52:40,800 --> 00:52:42,177
It takes about a minute.

1154
00:52:42,177 --> 00:52:45,450
So it's got it all set up,

1155
00:52:45,450 --> 00:52:47,211
it's got it configured,

1156
00:52:47,211 --> 00:52:51,240
and about another 10 seconds
here, it'll be ready.

1157
00:52:51,240 --> 00:52:52,680
Once it's ready,

1158
00:52:52,680 --> 00:52:57,510
then it's going to add the
API target to the Gateway.

1159
00:52:57,510 --> 00:52:58,680
So what is that all about?

1160
00:52:58,680 --> 00:53:02,700
It's got to configure an OAuth authorizer.

1161
00:53:02,700 --> 00:53:05,580
In this case, I've told
it we should use Kognito.

1162
00:53:05,580 --> 00:53:08,220
That's the standard that we
were using in this environment.

1163
00:53:08,220 --> 00:53:09,820
It could be whatever you'd like.

1164
00:53:11,220 --> 00:53:14,100
And it looks like it's
already done it now,

1165
00:53:14,100 --> 00:53:16,350
and now it's on to testing.

1166
00:53:16,350 --> 00:53:18,240
So I asked it to test,

1167
00:53:18,240 --> 00:53:20,220
given that it's standard MCP,

1168
00:53:20,220 --> 00:53:23,439
just use HTTP and do a list tools,

1169
00:53:23,439 --> 00:53:26,880
do an invoke tool on any
of the available tools.

1170
00:53:26,880 --> 00:53:30,770
And so now, it's got
the Gateway that's API,

1171
00:53:30,770 --> 00:53:34,152
sorry, the API is now agent ready.

1172
00:53:34,152 --> 00:53:36,860
Now, it's on to testing.

1173
00:53:36,860 --> 00:53:39,123
So let's see what happens here.

1174
00:53:41,160 --> 00:53:44,670
So it writes a little code
to try to test it out.

1175
00:53:44,670 --> 00:53:46,043
Of course, it's going to be successful.

1176
00:53:46,043 --> 00:53:47,377
No problem.

1177
00:53:47,377 --> 00:53:52,053
You'll see in a moment here
it's going to list the tools.

1178
00:53:53,190 --> 00:53:57,630
First, it's getting an access
key from the authorizer.

1179
00:53:57,630 --> 00:54:00,671
You've gotta do a secure invocation here

1180
00:54:00,671 --> 00:54:03,153
using the MCP protocol.

1181
00:54:05,010 --> 00:54:07,920
And voila!

1182
00:54:07,920 --> 00:54:12,920
There's all of the tools
automatically coming back as MCP,

1183
00:54:13,050 --> 00:54:15,990
even though we started
with just a REST API.

1184
00:54:15,990 --> 00:54:17,190
So it's done that mapping.

1185
00:54:17,190 --> 00:54:18,420
It's got it live.

1186
00:54:18,420 --> 00:54:20,970
You can plug that into any agent.

1187
00:54:20,970 --> 00:54:23,490
And here, we tested out invoking a tool.

1188
00:54:23,490 --> 00:54:26,547
So we did MCP call tool
on one of the tools

1189
00:54:26,547 --> 00:54:29,250
to list customers who was able to do that.

1190
00:54:29,250 --> 00:54:32,430
Here it's retrieving the
details on a particular order.

1191
00:54:32,430 --> 00:54:33,788
So we've got all of the basics here

1192
00:54:33,788 --> 00:54:38,788
of managing orders based on existing APIs

1193
00:54:39,480 --> 00:54:42,990
and it's available as MCP now.

1194
00:54:42,990 --> 00:54:46,350
So then it's creating
a simple Strands agent

1195
00:54:46,350 --> 00:54:48,090
and any of these agent frameworks

1196
00:54:48,090 --> 00:54:50,131
makes it easy to just
plug in an MCP server.

1197
00:54:50,131 --> 00:54:52,764
So that's what it's doing here.

1198
00:54:52,764 --> 00:54:56,820
And in less than a minute here,
it's gonna have a running,

1199
00:54:56,820 --> 00:54:58,920
see, it's actually executing right now.

1200
00:54:58,920 --> 00:55:00,070
It's actually listing servers,

1201
00:55:00,070 --> 00:55:03,510
getting listing orders,
getting order details.

1202
00:55:03,510 --> 00:55:06,000
So now the Strands
agent's already working.

1203
00:55:06,000 --> 00:55:07,634
We're only a few minutes
into this job here.

1204
00:55:07,634 --> 00:55:09,659
I still haven't done any work.

1205
00:55:09,659 --> 00:55:11,643
Kind of nice, I like this.

1206
00:55:12,930 --> 00:55:17,930
And now what I'd like to do
is deploy it in the cloud.

1207
00:55:18,210 --> 00:55:19,650
It's great on my laptop.

1208
00:55:19,650 --> 00:55:20,610
I want it in the cloud.

1209
00:55:20,610 --> 00:55:21,600
I want to be able to hand it

1210
00:55:21,600 --> 00:55:24,150
to app developers and app builders.

1211
00:55:24,150 --> 00:55:28,770
And so Kiro says, "Okay,
let me see what it takes."

1212
00:55:28,770 --> 00:55:29,880
It checks out the commands.

1213
00:55:29,880 --> 00:55:33,090
It figures out all I
need to do is configure

1214
00:55:33,090 --> 00:55:34,800
and then launch.

1215
00:55:34,800 --> 00:55:36,150
So it does a configure,

1216
00:55:36,150 --> 00:55:39,730
configure sees that it's got your agent,

1217
00:55:39,730 --> 00:55:42,690
it knows how to just then at that point,

1218
00:55:42,690 --> 00:55:46,410
package the code, upload it,

1219
00:55:46,410 --> 00:55:51,090
and then create a secure
endpoint for that agent.

1220
00:55:51,090 --> 00:55:52,105
So that's what it's doing right now.

1221
00:55:52,105 --> 00:55:54,300
It's doing the packaging.

1222
00:55:54,300 --> 00:55:55,830
It's getting it uploaded.

1223
00:55:55,830 --> 00:55:58,380
It's setting up the endpoint in the cloud.

1224
00:55:58,380 --> 00:56:00,783
Another 10 seconds or
so that'll be running.

1225
00:56:03,120 --> 00:56:05,557
Once it's running in the cloud, Kiro says,

1226
00:56:05,557 --> 00:56:09,360
"Okay, let me test the
agent via the command line."

1227
00:56:09,360 --> 00:56:11,514
So we'll do an AgentCore invoke,

1228
00:56:11,514 --> 00:56:13,380
prove that it works.

1229
00:56:13,380 --> 00:56:14,340
Here it goes right now.

1230
00:56:14,340 --> 00:56:15,603
It's doing an invoke,

1231
00:56:16,800 --> 00:56:18,540
and let's see if that works.

1232
00:56:18,540 --> 00:56:20,370
Hey, what do you know?

1233
00:56:20,370 --> 00:56:22,155
It's able to list the customers.

1234
00:56:22,155 --> 00:56:25,680
You can get the details
of a particular order.

1235
00:56:25,680 --> 00:56:27,690
No problem, it's got session management.

1236
00:56:27,690 --> 00:56:30,060
It's secure session isolation.

1237
00:56:30,060 --> 00:56:32,763
It can handle those concurrency at scale.

1238
00:56:33,780 --> 00:56:35,670
And just to prove that out,

1239
00:56:35,670 --> 00:56:40,670
I ask it to write a simple client script

1240
00:56:41,160 --> 00:56:42,990
to prove that you can use it from Python,

1241
00:56:42,990 --> 00:56:44,853
from boto3 remotely.

1242
00:56:46,140 --> 00:56:47,820
And then I had it write a little load test

1243
00:56:47,820 --> 00:56:51,630
to spin up a bunch of
sessions concurrently

1244
00:56:51,630 --> 00:56:54,540
and prove that that works as well.

1245
00:56:54,540 --> 00:56:59,540
So there's a nice little
demo of not writing any code,

1246
00:56:59,550 --> 00:57:01,140
taking an existing API,

1247
00:57:01,140 --> 00:57:03,120
making it available via Gateway,

1248
00:57:03,120 --> 00:57:04,170
writing an agent,

1249
00:57:04,170 --> 00:57:06,150
hosting an agent in the cloud,

1250
00:57:06,150 --> 00:57:09,117
all with the magic and
wonder of AgentCore.

1251
00:57:10,350 --> 00:57:13,293
So let me give you four quick takeaways.

1252
00:57:14,520 --> 00:57:18,663
One, business value only comes
when you're in production.

1253
00:57:19,556 --> 00:57:21,180
Maybe it's obvious,

1254
00:57:21,180 --> 00:57:23,668
but there is that big chasm

1255
00:57:23,668 --> 00:57:24,980
and you need to address that

1256
00:57:24,980 --> 00:57:28,410
in order to start getting real
value out of these agents.

1257
00:57:28,410 --> 00:57:31,800
Second, know what your agents are up to.

1258
00:57:31,800 --> 00:57:33,076
Never put an agent in production

1259
00:57:33,076 --> 00:57:36,750
if you don't have a good
mechanism for observability.

1260
00:57:36,750 --> 00:57:38,007
You need all of the detail there

1261
00:57:38,007 --> 00:57:41,430
and you need an easy way
to get access to that.

1262
00:57:41,430 --> 00:57:44,640
And then find a way to iterate
and improve your agents,

1263
00:57:44,640 --> 00:57:46,620
as well as troubleshoot and debug

1264
00:57:46,620 --> 00:57:48,020
when things are going wrong.

1265
00:57:49,680 --> 00:57:52,473
Third, security is not optional.

1266
00:57:53,340 --> 00:57:55,920
Scale is not optional.

1267
00:57:55,920 --> 00:57:57,030
You're not building toys.

1268
00:57:57,030 --> 00:58:00,360
You're building production ready agents

1269
00:58:00,360 --> 00:58:02,160
to deliver real value.

1270
00:58:02,160 --> 00:58:05,130
You've gotta have security
and scale figured out.

1271
00:58:05,130 --> 00:58:08,550
And then lastly, don't waste time

1272
00:58:08,550 --> 00:58:11,040
crawling around in that chasm.

1273
00:58:11,040 --> 00:58:15,120
Use AgentCore and get a smooth
path right over that chasm

1274
00:58:15,120 --> 00:58:19,290
from POCs into production ready

1275
00:58:19,290 --> 00:58:20,790
real business value.

1276
00:58:20,790 --> 00:58:23,070
So with that, here's some resources.

1277
00:58:23,070 --> 00:58:24,751
You've got great documentation out there.

1278
00:58:24,751 --> 00:58:26,880
Quick starts, tutorials,

1279
00:58:26,880 --> 00:58:28,620
we've got workshops, self-service,

1280
00:58:28,620 --> 00:58:31,590
or you can use our help with those.

1281
00:58:31,590 --> 00:58:36,590
We've got a pretty robust
repo with tutorials as well,

1282
00:58:36,930 --> 00:58:40,650
examples of integrations,
A2A, multiple frameworks.

1283
00:58:40,650 --> 00:58:43,860
If you're looking to learn
more about agentic AI overall,

1284
00:58:43,860 --> 00:58:46,680
this is a skill builder capability.

1285
00:58:46,680 --> 00:58:49,947
And then with that, I wanna
thank you all for coming.

1286
00:58:49,947 --> 00:58:52,140
Hopefully this is giving you a good idea

1287
00:58:52,140 --> 00:58:54,030
of how to cross that chasm

1288
00:58:54,030 --> 00:58:57,720
from POC to real production ready agents.

1289
00:58:57,720 --> 00:58:58,553
Thank you.

1290
00:58:58,553 --> 00:59:00,889
(audience applauding)

