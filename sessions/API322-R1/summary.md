# AWS re:Invent 2025 会议总结：构建容错和消息传递系统

## 会议概述

本次会议是 AWS re:Invent 2025 第一天的技术分享，由两位高级解决方案架构师 Parnub Basup 和 Tom Romano 主讲。会议聚焦于如何使用 AWS 服务构建具有高可用性和容错能力的消息传递系统。两位讲师都是无服务器技术领域社区的成员，Parnub 同时也是数据分析技术社区的成员，这意味着本次分享的架构模式不仅适用于消息传递系统，也同样适用于数据管道场景。

会议采用了理论结合实践的方式，前半部分由 Parnub 介绍架构模式和设计考虑因素，后半部分由 Tom 进行现场编码演示。讲师通过一个咖啡订单处理系统作为示例应用，展示了如何在不大幅修改主应用代码的情况下，实现多种容错模式。会议强调的核心理念是：通过合理的架构设计，开发者可以避免在深夜或周末被系统故障叫醒，让系统能够优雅地处理各种失败场景。

会议涵盖了 AWS 原生消息服务（如 SQS、SNS、Kinesis、EventBridge）和托管开源服务（如 Amazon MQ、Amazon MSK）。从现场观众的反馈来看，使用 AWS 原生服务的开发者占多数。讲师介绍了五种关键的容错模式：死信队列（DLQ）模式、重试与退避模式、断路器模式、Saga 编排模式和冗余模式，并通过实际代码演示了前几种模式的具体实现。

## 详细时间线与关键要点

### 00:00 - 开场与背景介绍
- 讲师幽默地提到 re:Invent 第一天的三大发现：拉斯维加斯不只有赌场、运动鞋是最好的朋友、时差是真实存在的
- 现场调查显示大部分观众正在使用或计划使用 AWS 消息服务
- 许多观众有过因消息系统故障而在非工作时间被叫醒处理问题的经历

### 02:30 - 讲师自我介绍
- Parnub Basup：高级解决方案架构师，帮助公共部门客户采用 AWS，开发者背景
- Tom Romano：高级解决方案架构师，与 Parnub 合作 5 年，同属无服务器技术社区
- 两人都强调这些模式在数据工程和分析场景中同样适用

### 04:00 - 会议议程说明
- 简要介绍 AWS 消息服务和模式
- 现场编码演示（300 级别，不使用生成式 AI）
- 讨论架构设计的弹性考虑因素
- 深入讲解多种容错模式
- Q&A 环节（部署期间可以提问）

### 05:30 - AWS 消息服务概览
- **AWS 原生服务**：
  - Amazon SQS（标准队列和 FIFO 队列）
  - Amazon SNS（发布/订阅模式）
  - Amazon Kinesis（流式处理）
  - Amazon EventBridge（企业服务总线）
- **托管开源服务**：
  - Amazon MQ（支持 RabbitMQ 和 ActiveMQ）
  - Amazon MSK（托管 Kafka 服务）
- 现场调查显示更多观众倾向使用 AWS 原生服务

### 08:00 - 消息系统架构的故障点分析
- **生产者故障**：可能停止发送消息或发送格式错误的消息
- **消息服务故障**：可能因持久性错误或瞬态错误而宕机
- **消费者故障**：可能因网络问题或部署失败而无法处理消息
- 强调需要通过架构模式来应对这些故障场景

### 10:00 - 模式一：死信队列（DLQ）模式
- DLQ 是一个标准队列，用于存储无法处理的错误消息
- 讲师指出"死信"这个名称不太准确，这些消息并非真正"死亡"，而是需要人工或系统干预
- 建议称之为"错误消息队列"更为恰当
- 可以通过手动或系统化方式修正消息后重新发布到原队列
- 现场调查显示这是采用率最高的模式

### 13:00 - 模式二：重试与指数退避模式
- 用于处理瞬态错误（临时网络故障、消息过载、服务配额限制）
- 通过在消息之间增加时间间隔，给消息服务或消费者足够时间恢复到健康状态
- 某些 AWS 服务（如 SNS、Lambda）已内置此功能
- 可以根据需要覆盖默认配置

### 15:30 - 模式三：断路器模式
- 用于处理持久性错误（非临时性、不可自动恢复的错误）
- 借鉴电气系统概念：正常时电路闭合，故障时电路断开
- 使用 AWS Step Functions 或 Lambda 将消息暂存到 SQS
- 通过 Amazon EventBridge 进行健康检查，当消费者恢复后重新驱动消息
- 现场调查显示采用率相对较低

### 18:00 - 模式四：Saga 编排模式
- 用于分布式事务场景，需要多个消费者同时成功提交
- 使用 Step Functions 作为编排器，协调多个消费者之间的事务
- 如果某个消费者不可用，可以执行补偿事务回滚已提交的操作
- 将消息存储到数据库或其他队列中等待重试
- 名称来源于"史诗故事"，每个消费者就像故事中的章节

### 20:30 - 模式五：冗余模式
- 用于基础设施级别的高可用性需求
- Amazon MQ 支持主备模式：两个可用区部署，共享 EFS 文件系统
- 更高级别的冗余：多区域、多可用区的活跃代理网络，实现零停机时间

### 22:00 - 实战演示开始：咖啡订单系统介绍
- Tom 展示了一个简单的咖啡订单处理系统
- 架构：前端应用 → API Gateway → SQS → Lambda 消费者 → 外部支付系统 + 数据库
- 演示了正常工作流程：提交订单、查看订单历史

### 25:00 - 故障注入演示
- Tom 模拟外部支付系统宕机维护的场景
- 提交了 3 个咖啡订单，但订单历史中没有显示（订单未处理）
- 通过 CloudWatch 观察到严重问题：
  - 仅 3 个订单却产生了大量消息（每 10 秒 6 条消息）
  - SQS 队列深度保持在 3，消息不断被重复处理
  - Lambda 调用次数激增，每次调用持续 30 秒（超时时间）
  - 大量计算资源浪费，成本失控

### 28:00 - 实现 DLQ 模式：基础设施代码
- Tom 使用基础设施即代码（IaC）方式配置 DLQ
- 使用 Kiro IDE 进行现场编码（AWS 新推出的开发工具）
- 创建 DLQ 队列，设置消息保留期为 14 天（1,209,600 秒）
- 14 天的保留期是为了给团队足够时间发现问题并恢复系统

### 30:00 - 配置重驱策略
- 在原始队列上配置 RedrivePolicy
- 指定两个关键参数：
  - deadLetterTargetArn：DLQ 的 ARN
  - maxReceiveCount：最大接收次数（设置为 2-3 次）
- 重点：无需修改应用代码，SQS 自动处理消息转移

### 32:00 - 权限配置和环境变量
- 为 Lambda 函数授予访问 DLQ 的权限
- 将 DLQ 的名称、URL 和 ARN 作为环境变量传递给 Lambda
- 这样 Lambda 函数就能感知 DLQ 的存在

### 34:00 - 实现重驱函数
- 创建新的 Lambda 函数用于消息重驱
- **关键步骤一**：健康检查（Canary 测试）
  - 发送金额为 0 的测试订单到支付系统
  - 与支付系统协商忽略此类测试消息
  - 确认系统健康后再执行重驱操作
  - 避免消息在 DLQ 和主队列之间反复弹跳

### 36:30 - 使用 SQS 原生重驱功能
- 使用 AWS SDK（Python 的 boto3）调用 start_message_move_task API
- 关键参数：
  - source_queue_url：DLQ 的 URL
  - destination_queue_url：主队列的 URL
  - max_number_of_messages_per_second：控制重驱速率（设置为 1 条/秒）
- SQS 自动处理消息转移，无需手动编写循环代码

### 40:00 - DLQ 效果演示
- 部署 DLQ 配置后，系统行为立即改善：
  - 消息数量快速下降，不再无限循环
  - Lambda 调用次数大幅减少，不再出现"Lambda 风暴"
  - 虽然仍有少量 30 秒超时的执行，但不再持续发生
  - 系统成本得到控制，优雅地处理了故障

### 43:00 - 完整重驱流程演示
- 再次注入故障，提交 3 个咖啡订单
- 订单未处理，消息进入 DLQ
- 系统行为保持受控状态
- 修复支付系统后，执行重驱操作
- 订单历史中逐渐显示订单（每秒 1 个），所有订单成功处理

### 46:00 - Q&A 环节
- **问题 1**：控制台是否支持手动重驱消息？
  - 答：控制台可以查看消息内容和数量，但不支持直接修改消息
  - 需要使用 AWS CLI 或自定义工具来修改和重驱消息
  - 建议创建专门的工具来处理需要人工干预的消息

- **问题 2**：如何防止消息在 DLQ 和主队列之间无限循环？
  - 答：通过健康检查（Canary 测试）确保下游系统可用后再重驱
  - 重驱过程中消息不会重置重试计数
  - 关键是在重驱前验证系统已恢复健康

- **问题 3**：如果消息本身有问题怎么办？
  - 答：建议使用多个 DLQ 的分层策略
  - DLQ 1：用于需要人工干预的消息（格式错误、缺少必填字段等）
  - DLQ 2：用于因下游系统不可用而暂存的消息
  - 采用"分而治之"的方法，不同类型的错误使用不同的队列

- **问题 4**：重驱时消息的属性（如年龄）是否保留？
  - 答：消息属性会保留，不会创建新消息
  - 消息的原始时间戳和其他元数据在重驱过程中保持不变

### 50:00 - 会议总结要点
- 实现容错模式不需要大幅修改应用代码
- 充分利用 AWS 服务的内置功能（如 SQS 的重驱、Lambda 的重试）
- 通过合理的架构设计实现成本优化和系统稳定性
- 多层 DLQ 策略可以更好地处理不同类型的错误
- 健康检查是防止消息循环的关键机制