# AWS re:Invent 2025 CNS-359 会话总结

## 会话概述

本次会话（CNS-359）由AWS首席解决方案架构师Draj Mapatra和生成式AI解决方案架构师Hickey Park主讲，主题为"使用AWS无服务器技术构建、部署和运营智能体应用程序"。这是一个300级别的技术会话，重点讨论了从传统LLM推理到智能体架构的演进过程。

会话以一个实际的客户服务场景为例：客户在黑色星期五购物时遇到重复扣费、商品缺失等问题，需要紧急解决。通过这个案例，演讲者展示了如何从简单的RAG（检索增强生成）模式发展到工具调用，最终演进为完整的智能体系统。演讲者强调了从单体智能体向微服务化智能体架构的转变，类似于传统微服务架构的演进过程。

## 详细时间线和要点

### 开场介绍 (00:00-02:30)
- **00:00**: 会话开始，介绍演讲者Draj Mapatra（AWS首席专家解决方案架构师）和Hickey Park（生成式AI解决方案架构师）
- **01:15**: 确定会话主题：构建、部署和运营智能体应用程序
- **02:00**: 说明这是300级别会话，假设听众具备基础知识

### 客户案例和问题定义 (02:30-05:00)
- **02:30**: 引入客户服务场景：黑色星期五购物问题
- **03:00**: 详细描述问题：重复扣费、商品缺失、紧急需求
- **04:00**: 展示传统无服务器零售应用架构
- **04:30**: 介绍不同的API边界：订单、库存、支付、客服

### 传统解决方案的挑战 (05:00-08:00)
- **05:00**: 分析客户支持代理面临的挑战
- **05:30**: 多个分散系统的整合困难
- **06:00**: 客户体验和响应时间要求
- **07:00**: 引入LLM作为改进方案的可能性
- **07:30**: 讨论搜索增强的提示工程方法

### 从RAG到工具调用的演进 (08:00-12:00)
- **08:00**: 展示基于搜索的知识检索方法
- **08:30**: 应用程序编排信息检索流程
- **09:00**: 介绍动态工具调用方法
- **09:30**: LLM自主决定工具使用
- **10:00**: 展示增强提示的JSON结构
- **11:00**: 工具列表在提示中的作用
- **11:30**: 将无服务器API包装为工具调用

### 智能体架构核心概念 (12:00-16:00)
- **12:00**: 定义智能体与传统方法的区别
- **12:30**: 智能体循环的重复执行机制
- **13:00**: 框架处理循环次数的自动化
- **13:30**: 持续上下文检索的重要性
- **14:00**: 从单体智能体到微服务智能体的演进
- **15:00**: 领域智能体的扩展能力
- **15:30**: 库存智能体的产品推荐功能示例

### 实际实现演示 (16:00-25:00)
- **16:00**: Draj接手演示实际实现
- **16:30**: 回顾从LLM推理到智能体的演进路径
- **17:00**: 展示客户服务请求的处理流程
- **18:00**: 智能体循环的具体实现步骤
- **19:00**: Step Functions工作流实现方法
- **20:00**: 选择状态的关键作用
- **21:00**: Lambda函数的替代实现方案
- **22:00**: 分析传统方法的优势和局限性
- **23:00**: 紧耦合问题的识别
- **24:00**: 引入智能体框架的必要性

### Strands Agent SDK介绍 (25:00-32:00)
- **25:00**: 智能体自动工具选择能力
- **25:30**: Strands Agent开源SDK介绍
- **26:00**: 轻量级SDK的特点
- **26:30**: 模型驱动的智能体循环
- **27:00**: 简单的Python代码示例
- **28:00**: 订单智能体的具体实现
- **29:00**: 工具装饰器的使用方法
- **30:00**: 模型配置和会话设置
- **31:00**: 声明式vs命令式编程对比
- **31:30**: 内置错误处理和最佳实践

### 生产环境扩展考虑 (32:00-38:00)
- **32:00**: 模型和计算平台无关性
- **32:30**: 多种部署选项支持
- **33:00**: 生产环境的复杂性挑战
- **33:30**: 多智能体和工具的协作需求
- **34:00**: 部门、组织、外部工具的整合
- **35:00**: 避免重复开发的重要性
- **36:00**: 标准化协议的必要性
- **37:00**: 不同协议的集成复杂性
- **37:30**: 紧耦合问题的再现

### MCP协议标准化 (38:00-45:00)
- **38:00**: Model Context Protocol (MCP)介绍
- **38:30**: 统一不同标准的解决方案
- **39:00**: MCP客户端和服务器架构
- **39:30**: 智能体构建者的简化工作
- **40:00**: 工具提供者的标准化要求
- **41:00**: 智能体循环中的MCP应用
- **42:00**: Strands Agent的MCP客户端示例
- **43:00**: 远程MCP服务器调用演示
- **44:00**: 网络爬虫工具的实际应用
- **44:30**: 啤酒厂城市排名查询结果

### MCP服务器开发 (45:00-48:00)
- **45:00**: Fast MCP服务器构建方法
- **45:30**: 数学服务器示例实现
- **46:00**: MCP工具装饰器使用
- **46:30**: 服务器端口配置和启动
- **47:00**: MCP客户端调用准备
- **47:30**: 生产环境标准化通信

### 智能体间通信挑战 (48:00-52:00)
- **48:00**: 智能体到智能体通信需求
- **48:30**: 订单智能体和支付智能体协作
- **49:00**: 无标准情况下的范围蔓延
- **49:30**: 领域驱动设计原则回顾
- **50:00**: 边界上下文的重要性
- **50:30**: 所有权泄漏问题
- **51:00**: 认证授权复杂性
- **51:30**: 工具版本同步挑战

### A2A协议解决方案 (52:00-58:00)
- **52:00**: 支付智能体作为MCP服务器的局限性
- **52:30**: 工具发现和能力暴露问题
- **53:00**: MCP客户端和服务器双重角色
- **53:30**: Google A2A (Agent-to-Agent)协议介绍
- **54:00**: 智能体能力发现和任务交换
- **54:30**: 智能体卡片概念
- **55:00**: 能力、技能、模态描述
- **55:30**: 认证授权信息包含
- **56:00**: 任务创建和处理流程
- **57:00**: 同步异步通信支持
- **57:30**: 编排vs编舞模式类比

### 事件驱动架构集成 (58:00-结束)
- **58:00**: A2A和MCP的架构改进
- **58:30**: 专业化智能体的优势
- **59:00**: 领域知识封装
- **59:30**: 事件驱动架构的引入可能性
- **60:00**: API调用到事件生产者的转换
- **60:30**: Event Bridge事件代理
- **61:00**: 智能体间的事件通信
- **61:30**: WebSocket用户通知机制
- **62:00**: 完整的异步处理流程