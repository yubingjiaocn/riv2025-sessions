1
00:00:00,000 --> 00:00:02,100
- So just make sure you're
in the right session.

2
00:00:02,100 --> 00:00:04,020
This is DAT313.

3
00:00:04,020 --> 00:00:06,600
We're gonna talk about
supercharging app intelligence

4
00:00:06,600 --> 00:00:09,660
on DocumentDB with get
ready, brand new concept

5
00:00:09,660 --> 00:00:11,820
you haven't heard of
before, generative AI.

6
00:00:11,820 --> 00:00:12,690
I know this is new.

7
00:00:12,690 --> 00:00:14,550
We'll walk you through
it, explain what it is.

8
00:00:14,550 --> 00:00:16,890
Raise your hand if you
haven't been to 17 sessions

9
00:00:16,890 --> 00:00:19,650
today about gen AI, right, since lunch.

10
00:00:19,650 --> 00:00:20,640
No, I'm kidding.

11
00:00:20,640 --> 00:00:23,490
So what we're gonna talk about
is a couple different things.

12
00:00:23,490 --> 00:00:25,140
We're gonna go through gen AI.

13
00:00:25,140 --> 00:00:27,150
We're gonna introduce ourselves
in a second, I promise.

14
00:00:27,150 --> 00:00:28,980
We're gonna talk about generative AI,

15
00:00:28,980 --> 00:00:30,330
but from a database perspective.

16
00:00:30,330 --> 00:00:32,373
We wanna look at gen AI from DocumentDB,

17
00:00:33,924 --> 00:00:35,730
from your data stores.

18
00:00:35,730 --> 00:00:40,230
We're gonna talk about the
foundation of these on databases,

19
00:00:40,230 --> 00:00:41,340
on your vector embeddings.

20
00:00:41,340 --> 00:00:43,620
We're gonna go through the
important parts of this.

21
00:00:43,620 --> 00:00:46,230
We're gonna, we're kind
of explain the foundation

22
00:00:46,230 --> 00:00:47,280
of everything we're gonna show you,

23
00:00:47,280 --> 00:00:49,290
and that's those access patterns.

24
00:00:49,290 --> 00:00:51,750
I'm Cody Allen, I'm a
principal solution architect

25
00:00:51,750 --> 00:00:52,583
with DocumentDB.

26
00:00:52,583 --> 00:00:53,610
With me is.

27
00:00:53,610 --> 00:00:58,140
- I'm Doug Bonser, senior
DocumentDB solution architect.

28
00:00:58,140 --> 00:01:01,560
- And what Doug and I do
is we sit down with you.

29
00:01:01,560 --> 00:01:03,630
We talk to customers every single day.

30
00:01:03,630 --> 00:01:05,400
It's our favorite thing to do actually,

31
00:01:05,400 --> 00:01:07,193
talking about DocumentDB.

32
00:01:07,193 --> 00:01:10,830
And in these conversations
we talk about gen AI

33
00:01:10,830 --> 00:01:13,200
and what they're doing with
gen AI, the proof of concepts

34
00:01:13,200 --> 00:01:15,360
that they're doing, the
enterprise applications

35
00:01:15,360 --> 00:01:16,260
they're rolling out.

36
00:01:16,260 --> 00:01:17,190
And we wanna share that with you.

37
00:01:17,190 --> 00:01:18,780
We wanna tell you what we're seeing.

38
00:01:18,780 --> 00:01:20,070
We wanna show you some of the tools,

39
00:01:20,070 --> 00:01:22,230
walk you some demos of
what customers are doing

40
00:01:22,230 --> 00:01:23,760
and what we're doing with gen AI.

41
00:01:23,760 --> 00:01:25,829
We're gonna go through
those access patterns

42
00:01:25,829 --> 00:01:27,743
and we're gonna finish
off with best practices.

43
00:01:29,010 --> 00:01:30,870
It's overwhelming to say the least,

44
00:01:30,870 --> 00:01:33,840
building new generative AI applications.

45
00:01:33,840 --> 00:01:35,910
There's a lot of variables,
a lot of different factors

46
00:01:35,910 --> 00:01:36,743
that go into it.

47
00:01:36,743 --> 00:01:38,640
And we're gonna leave you
with some best practices,

48
00:01:38,640 --> 00:01:40,440
things that you can do to go back

49
00:01:40,440 --> 00:01:43,080
and start building these applications.

50
00:01:43,080 --> 00:01:45,600
With that said, let's go through

51
00:01:45,600 --> 00:01:46,830
a background of what gen AI is.

52
00:01:46,830 --> 00:01:47,663
I'm kidding.

53
00:01:47,663 --> 00:01:48,630
You know what gen AI is already.

54
00:01:48,630 --> 00:01:50,310
What's interesting is
there was a McKinsey study

55
00:01:50,310 --> 00:01:52,350
that said that gen AI is gonna add

56
00:01:52,350 --> 00:01:57,350
between 2.6 and $4.4 trillion
of global economy annually.

57
00:01:57,600 --> 00:01:58,433
That's nuts.

58
00:01:58,433 --> 00:02:00,030
I can't even fathom that types of number.

59
00:02:00,030 --> 00:02:04,500
But really what this is
saying is that gen AI apps

60
00:02:04,500 --> 00:02:06,150
are becoming an enterprise initiative.

61
00:02:06,150 --> 00:02:07,230
Everybody's talking about it.

62
00:02:07,230 --> 00:02:08,850
Who here works for a company

63
00:02:08,850 --> 00:02:11,460
that is not talking about gen AI?

64
00:02:11,460 --> 00:02:12,840
Yeah, exactly.

65
00:02:12,840 --> 00:02:14,040
Everybody's focusing on this.

66
00:02:14,040 --> 00:02:16,590
Finding what they can do
because it's disruptive, right?

67
00:02:16,590 --> 00:02:18,780
There's this massive amount of models

68
00:02:18,780 --> 00:02:20,610
that are available both on the cloud

69
00:02:20,610 --> 00:02:21,720
and that you can run locally.

70
00:02:21,720 --> 00:02:23,220
We'll show some of that.

71
00:02:23,220 --> 00:02:27,240
But the lifeblood of all of
these gen AI applications

72
00:02:27,240 --> 00:02:30,270
is data, secure data,
enrich data, your data.

73
00:02:30,270 --> 00:02:31,560
That's where it all starts.

74
00:02:31,560 --> 00:02:33,360
And that's the most important thing.

75
00:02:34,260 --> 00:02:36,330
Doug and I were up here
last year talking to you

76
00:02:36,330 --> 00:02:39,060
about generative AI on Amazon DocumentDB,

77
00:02:39,060 --> 00:02:41,160
going really deep on some vector indexes

78
00:02:41,160 --> 00:02:42,240
and how you utilize those.

79
00:02:42,240 --> 00:02:45,330
And the thing that we told
you then was that your data

80
00:02:45,330 --> 00:02:46,980
is a differentiator, and guess what?

81
00:02:46,980 --> 00:02:48,030
Nothing has changed.

82
00:02:48,030 --> 00:02:51,090
Your data is still the differentiator.

83
00:02:51,090 --> 00:02:52,740
That's what makes these
gen AI applications

84
00:02:52,740 --> 00:02:55,920
that are gonna be unique to your business.

85
00:02:55,920 --> 00:02:58,260
Now, generative AI applications are seen

86
00:02:58,260 --> 00:02:59,970
as a new application type that sits

87
00:02:59,970 --> 00:03:02,580
on top of your existing data foundation.

88
00:03:02,580 --> 00:03:04,620
That means that you wanna
plug into your existing data

89
00:03:04,620 --> 00:03:06,900
sources, your data lakes,
your data warehouses,

90
00:03:06,900 --> 00:03:08,970
your external or hybrid data source,

91
00:03:08,970 --> 00:03:11,100
your document data stores, right,

92
00:03:11,100 --> 00:03:12,930
in order to build these applications.

93
00:03:12,930 --> 00:03:14,330
Now, customers have
told us they don't want

94
00:03:14,330 --> 00:03:16,920
to create new data architectures

95
00:03:16,920 --> 00:03:19,710
for what is basically
a new application set.

96
00:03:19,710 --> 00:03:21,330
They want to take advantage of the systems

97
00:03:21,330 --> 00:03:23,460
that they already have, the
systems are already using

98
00:03:23,460 --> 00:03:24,930
in production environments.

99
00:03:24,930 --> 00:03:27,780
They want to leverage their
existing architectures

100
00:03:27,780 --> 00:03:30,000
to create these new gen AI workflows.

101
00:03:30,000 --> 00:03:31,860
And they want these new gen AI workflows

102
00:03:31,860 --> 00:03:34,530
and the applications to
follow their enterprise rules

103
00:03:34,530 --> 00:03:36,360
that they've already established.

104
00:03:36,360 --> 00:03:40,080
Now, keeping vectors as close as possible

105
00:03:40,080 --> 00:03:42,030
to that underlying data store

106
00:03:42,030 --> 00:03:44,760
is really gonna simplify
this architecture.

107
00:03:44,760 --> 00:03:46,530
It's gonna minimize the data movement,

108
00:03:46,530 --> 00:03:48,090
the ETL process that you have to do,

109
00:03:48,090 --> 00:03:50,130
it's gonna improve performance

110
00:03:50,130 --> 00:03:51,870
because has less places to stop.

111
00:03:51,870 --> 00:03:54,210
It even has the advantage of
decreasing licensing costs

112
00:03:54,210 --> 00:03:55,740
by introducing new applications.

113
00:03:55,740 --> 00:03:58,620
And speaking of that, when you
start adding these new type

114
00:03:58,620 --> 00:04:00,180
of applications layers, guess what?

115
00:04:00,180 --> 00:04:03,660
You have to learn new APIs,
you have to learn new SDKs.

116
00:04:03,660 --> 00:04:06,450
You have this overhead of
this new programming language

117
00:04:06,450 --> 00:04:07,850
in order to implement these.

118
00:04:09,270 --> 00:04:12,510
But once you have a vector store on top

119
00:04:12,510 --> 00:04:14,760
of an existing database,
you leverage that knowledge

120
00:04:14,760 --> 00:04:15,593
that you already have.

121
00:04:15,593 --> 00:04:18,150
So for example, if your
organization's familiar with

122
00:04:18,150 --> 00:04:19,320
and you store your data in Redis,

123
00:04:19,320 --> 00:04:22,680
well, MemoryDB's vector
functionality would be a good fit.

124
00:04:22,680 --> 00:04:24,370
This goes with Aurora, this goes with RDS

125
00:04:24,370 --> 00:04:26,760
and OpenSearch and Neptune Analytics.

126
00:04:26,760 --> 00:04:27,690
And guess what?

127
00:04:27,690 --> 00:04:30,540
The reason you're here, Amazon DocumentDB.

128
00:04:30,540 --> 00:04:33,150
Generally this allows
you to avoid introducing

129
00:04:33,150 --> 00:04:35,700
a new database component just to be able

130
00:04:35,700 --> 00:04:38,280
to build an AI application.

131
00:04:38,280 --> 00:04:40,380
And you get that confidence knowing

132
00:04:40,380 --> 00:04:42,300
that your existing data structures

133
00:04:42,300 --> 00:04:43,470
are already proven in production.

134
00:04:43,470 --> 00:04:45,060
They already meet your
security requirements.

135
00:04:45,060 --> 00:04:47,400
They already meet your
availability, your storage,

136
00:04:47,400 --> 00:04:50,520
and your compute requirements
by building on top of that.

137
00:04:50,520 --> 00:04:52,380
With that being said, let's
go to that first piece

138
00:04:52,380 --> 00:04:54,210
I was telling you about,
that foundational piece

139
00:04:54,210 --> 00:04:55,043
of vector embeddings.

140
00:04:55,043 --> 00:04:59,220
This is the key component
of vectors on databases.

141
00:04:59,220 --> 00:05:00,270
What is a vector embedding?

142
00:05:00,270 --> 00:05:03,720
Well, it's just a numerical
representation of your text,

143
00:05:03,720 --> 00:05:05,430
even your videos and your photos.

144
00:05:05,430 --> 00:05:08,403
But for the sake of
DocumentDB of your text.

145
00:05:10,080 --> 00:05:13,080
We all can look at what's on
the left and understand that.

146
00:05:13,080 --> 00:05:15,420
We can read those words
and understand the context,

147
00:05:15,420 --> 00:05:16,290
but computers can't.

148
00:05:16,290 --> 00:05:18,870
So what we have to do is we
have to turn it into numbers.

149
00:05:18,870 --> 00:05:20,070
Machines understand numbers,

150
00:05:20,070 --> 00:05:22,650
and we have to turn
that text into numbers.

151
00:05:22,650 --> 00:05:24,210
What this does is it allows

152
00:05:24,210 --> 00:05:26,100
these machines to understand
context in the way

153
00:05:26,100 --> 00:05:27,660
that we understand context.

154
00:05:27,660 --> 00:05:29,760
Words have different meanings

155
00:05:29,760 --> 00:05:31,110
when they're close to other words,

156
00:05:31,110 --> 00:05:33,330
when we ask questions in a certain cadence

157
00:05:33,330 --> 00:05:35,910
or a certain pattern, it
might change the meaning

158
00:05:35,910 --> 00:05:38,340
and therefore change the
results that we get back, right?

159
00:05:38,340 --> 00:05:39,960
It's not a binary search
where I'm just searching

160
00:05:39,960 --> 00:05:42,180
for a name and address and email address.

161
00:05:42,180 --> 00:05:43,560
We're looking for context.

162
00:05:43,560 --> 00:05:45,450
That natural query language.

163
00:05:45,450 --> 00:05:47,910
Now like I said, Doug and I,

164
00:05:47,910 --> 00:05:50,100
we talk to customers all the time

165
00:05:50,100 --> 00:05:52,140
and what we see customers doing

166
00:05:52,140 --> 00:05:54,780
is building these gen AI POCs

167
00:05:54,780 --> 00:05:55,860
and rolling things into production.

168
00:05:55,860 --> 00:05:57,330
But really their goal in doing this

169
00:05:57,330 --> 00:05:59,460
is to improve their customer experience.

170
00:05:59,460 --> 00:06:03,030
They want to improve their
employee productivity.

171
00:06:03,030 --> 00:06:05,250
We see this a lot internally at AWS.

172
00:06:05,250 --> 00:06:06,960
They wanna create brand new content

173
00:06:06,960 --> 00:06:10,800
or they even want to improve
their business operations.

174
00:06:10,800 --> 00:06:14,280
This is across every
business that we talk to,

175
00:06:14,280 --> 00:06:16,710
whether it's financial or engineering

176
00:06:16,710 --> 00:06:19,203
or customer support or sales or marketing.

177
00:06:20,130 --> 00:06:21,960
Customers are running these pilot programs

178
00:06:21,960 --> 00:06:23,580
just to try it out, see what they can do.

179
00:06:23,580 --> 00:06:26,160
They're experimenting with gen AI.

180
00:06:26,160 --> 00:06:27,930
We have very strategic customers

181
00:06:27,930 --> 00:06:29,400
that are building chatbots.

182
00:06:29,400 --> 00:06:30,600
They're doing virtual assistance,

183
00:06:30,600 --> 00:06:31,980
they're doing conversational search

184
00:06:31,980 --> 00:06:34,710
and natural query language
and code generation.

185
00:06:34,710 --> 00:06:37,980
Man, I used to be a terrible
programmer before gen AI.

186
00:06:37,980 --> 00:06:39,930
Now I'm a terrible programmer with gen AI,

187
00:06:39,930 --> 00:06:41,010
but gen AI fixes it for me.

188
00:06:41,010 --> 00:06:41,843
It's wonderful.

189
00:06:41,843 --> 00:06:43,980
I'm amazing, I believe.

190
00:06:43,980 --> 00:06:45,180
I don't think so.

191
00:06:45,180 --> 00:06:46,590
Let's talk about these access patterns.

192
00:06:46,590 --> 00:06:48,000
What are some things that
you can do with this?

193
00:06:48,000 --> 00:06:50,820
Well, the first thing we're
gonna look at is building a tool

194
00:06:50,820 --> 00:06:52,680
that helps us with DocumentDB

195
00:06:52,680 --> 00:06:56,190
using some of our gen AI tools.

196
00:06:56,190 --> 00:06:59,670
We built this Amazon Bedrock-powered
DocumentDB TSQL plugin

197
00:06:59,670 --> 00:07:00,540
for Mongo shell.

198
00:07:00,540 --> 00:07:02,010
Whew, that rolls off the tongue.

199
00:07:02,010 --> 00:07:03,510
It's like 72 lines long.

200
00:07:03,510 --> 00:07:04,908
Clearly I'm not in marketing.

201
00:07:04,908 --> 00:07:05,940
(audience laughs)

202
00:07:05,940 --> 00:07:09,300
Who here is a relational database person?

203
00:07:09,300 --> 00:07:11,553
Either DBA or that's what you know, right?

204
00:07:12,690 --> 00:07:13,800
Me too.

205
00:07:13,800 --> 00:07:17,043
SQL Server, Oracle, MySQL, Postgres.

206
00:07:17,910 --> 00:07:18,930
That's my bread and butter, right?

207
00:07:18,930 --> 00:07:22,200
I look at this minus the
flickering lines there.

208
00:07:22,200 --> 00:07:24,660
I look at this and this
is home to me, right?

209
00:07:24,660 --> 00:07:26,250
This is a warm cup of coffee

210
00:07:26,250 --> 00:07:28,770
on a nice cold day and a nook, right?

211
00:07:28,770 --> 00:07:29,640
Like that makes sense.

212
00:07:29,640 --> 00:07:30,473
Holy cow.

213
00:07:30,473 --> 00:07:31,890
That no longer makes sense.

214
00:07:31,890 --> 00:07:33,630
Hey, it makes sense again.

215
00:07:33,630 --> 00:07:35,160
Select star from table.

216
00:07:35,160 --> 00:07:37,980
Join to this other table where
field equals field, right?

217
00:07:37,980 --> 00:07:42,030
So imagine when I started
my MongoDB journey,

218
00:07:42,030 --> 00:07:44,280
my DocumentDB journey and I had to learn

219
00:07:44,280 --> 00:07:47,610
MongoDB query language, MQL and that bread

220
00:07:47,610 --> 00:07:50,463
and butter nice cup of coffee became this.

221
00:07:51,360 --> 00:07:52,193
Yes, exactly.

222
00:07:52,193 --> 00:07:54,300
It just got all skewed, right?

223
00:07:54,300 --> 00:07:55,800
Doesn't make sense to me anymore.

224
00:07:55,800 --> 00:07:57,060
It's I have to do the lookup,

225
00:07:57,060 --> 00:07:58,170
what the heck's the dollar lookup.

226
00:07:58,170 --> 00:07:59,850
I have to do this dollar project.

227
00:07:59,850 --> 00:08:01,200
I'm not a project manager.

228
00:08:01,200 --> 00:08:02,940
Why do I have to care about project?

229
00:08:02,940 --> 00:08:04,590
And it didn't get any easier

230
00:08:04,590 --> 00:08:06,420
when I had to do update statements.

231
00:08:06,420 --> 00:08:09,060
Again, it's home.

232
00:08:09,060 --> 00:08:10,290
I get this, it feels good.

233
00:08:10,290 --> 00:08:12,840
Like even this far gone
from it, it feels good.

234
00:08:12,840 --> 00:08:16,980
And then I had to go do something
like this on MQL, right?

235
00:08:16,980 --> 00:08:19,320
I have to do that dollar
lookup again for each.

236
00:08:19,320 --> 00:08:21,180
I have to do a function to update this.

237
00:08:21,180 --> 00:08:23,010
Like my simple lizard brain,

238
00:08:23,010 --> 00:08:24,780
my relational brain didn't get this.

239
00:08:24,780 --> 00:08:29,400
So we created this tool that translates

240
00:08:29,400 --> 00:08:31,920
these TSQL commands
into DocumentDB commands

241
00:08:31,920 --> 00:08:33,990
within the Mongo shell environment.

242
00:08:33,990 --> 00:08:36,844
And they're set up to automatically handle

243
00:08:36,844 --> 00:08:39,030
all the supported APIs, operators

244
00:08:39,030 --> 00:08:40,290
and data types in DocumentDB.

245
00:08:40,290 --> 00:08:41,160
And guess what?

246
00:08:41,160 --> 00:08:42,390
We actually made two versions.

247
00:08:42,390 --> 00:08:44,340
We have one that reaches out to Bedrock

248
00:08:44,340 --> 00:08:45,840
and we have one that you can customize

249
00:08:45,840 --> 00:08:48,270
the prompt to the LLM
for that uses Ollama.

250
00:08:48,270 --> 00:08:51,510
So you can actually use
this locally on your machine

251
00:08:51,510 --> 00:08:53,510
if you don't wanna reach out to Bedrock.

252
00:08:54,355 --> 00:08:57,870
(audience chattering)

253
00:08:57,870 --> 00:08:59,550
Dramatic pause.

254
00:08:59,550 --> 00:09:00,600
Let's go into a demo.

255
00:09:02,760 --> 00:09:06,690
Alright, so this is available
out in our GitHub repository

256
00:09:06,690 --> 00:09:09,270
and we have our two
different packages here.

257
00:09:09,270 --> 00:09:12,300
And we're gonna start off by
looking at our Ollama plugin.

258
00:09:12,300 --> 00:09:14,670
We go in that directory
and we're gonna run

259
00:09:14,670 --> 00:09:15,810
our shell script to set this up.

260
00:09:15,810 --> 00:09:17,130
And what this is gonna do is gonna install

261
00:09:17,130 --> 00:09:19,410
all of our dependencies
and it's gonna download

262
00:09:19,410 --> 00:09:20,757
an Ollama LLM for us.

263
00:09:20,757 --> 00:09:23,040
And we'll see that in just one second.

264
00:09:23,040 --> 00:09:25,800
It handles compatibility
using our compatibility tool

265
00:09:25,800 --> 00:09:28,350
to reference what operators it should use

266
00:09:28,350 --> 00:09:32,040
in these Mongo shell
commands against DocumentDB.

267
00:09:32,040 --> 00:09:35,640
And once we do that, we can
see that it's installed.

268
00:09:35,640 --> 00:09:37,260
The Code Llama 7B library.

269
00:09:37,260 --> 00:09:39,510
Now it's a very large library, 3.8 gigs.

270
00:09:39,510 --> 00:09:40,343
It takes a while.

271
00:09:40,343 --> 00:09:43,110
It's not as fast in the real
world as it is the demo,

272
00:09:43,110 --> 00:09:45,270
but that allows us to make
all these calls locally.

273
00:09:45,270 --> 00:09:46,620
We don't have to reach out to Bedrock

274
00:09:46,620 --> 00:09:49,290
or out to the internet at all.

275
00:09:49,290 --> 00:09:51,180
We can see that it was installed.

276
00:09:51,180 --> 00:09:53,550
We had that Ollama-powered
plugin and we just,

277
00:09:53,550 --> 00:09:56,160
and within Mongo shell
we use this TSQL wrapper

278
00:09:56,160 --> 00:09:57,720
to do that query.

279
00:09:57,720 --> 00:09:59,820
So let's go ahead and launch Mongo shell.

280
00:09:59,820 --> 00:10:02,940
It's gonna call on that JS file

281
00:10:02,940 --> 00:10:05,640
that tells us to use it, that it's loaded.

282
00:10:05,640 --> 00:10:08,310
We have a couple name
spaces for this demo.

283
00:10:08,310 --> 00:10:10,740
We have some customers,
some orders, some products,

284
00:10:10,740 --> 00:10:13,410
about a hundred documents
in the customers and orders.

285
00:10:13,410 --> 00:10:15,420
We have a products table that combines

286
00:10:15,420 --> 00:10:16,830
the customers and orders together.

287
00:10:16,830 --> 00:10:19,980
That nasty dollar lookup thing
we were looking at before.

288
00:10:19,980 --> 00:10:23,640
And what we'll do is we'll
run this, this wrapper,

289
00:10:23,640 --> 00:10:24,900
this TSQL wrapper.

290
00:10:24,900 --> 00:10:28,920
And we're gonna do a TSQL
select star from table

291
00:10:28,920 --> 00:10:31,440
where field equals value, right?

292
00:10:31,440 --> 00:10:32,850
Simple, makes sense.

293
00:10:32,850 --> 00:10:34,320
Auto execute false at the end.

294
00:10:34,320 --> 00:10:36,330
That just means that
don't actually run that,

295
00:10:36,330 --> 00:10:38,070
just translate it for me.

296
00:10:38,070 --> 00:10:39,750
So we can see it's review mode.

297
00:10:39,750 --> 00:10:43,160
The commands are not executed
and there is the MQL.

298
00:10:43,160 --> 00:10:46,770
So we're just gonna copy
that, paste that in.

299
00:10:46,770 --> 00:10:47,603
And guess what?

300
00:10:47,603 --> 00:10:50,730
There's no missing quotes,
missing curly brackets.

301
00:10:50,730 --> 00:10:52,050
It just works.

302
00:10:52,050 --> 00:10:53,490
That would've taken me three tries.

303
00:10:53,490 --> 00:10:54,780
It's like plugging in the USB port.

304
00:10:54,780 --> 00:10:56,760
I always get it the third time.

305
00:10:56,760 --> 00:10:57,930
We're gonna make it a little more complex.

306
00:10:57,930 --> 00:10:59,580
We're gonna do select multiple fields

307
00:10:59,580 --> 00:11:00,570
instead of select star.

308
00:11:00,570 --> 00:11:02,550
We're gonna add an extra
wear clause to this

309
00:11:02,550 --> 00:11:04,020
and we're gonna say, Hey,
translate this for me,

310
00:11:04,020 --> 00:11:06,372
all within the Mongo shell environment,

311
00:11:06,372 --> 00:11:08,760
again using Ollama locally.

312
00:11:08,760 --> 00:11:10,920
And here we have all these extra ones

313
00:11:10,920 --> 00:11:12,930
and curly brackets and quotes.

314
00:11:12,930 --> 00:11:14,340
We're gonna copy that.

315
00:11:14,340 --> 00:11:15,660
Hopefully the syntax is correct.

316
00:11:15,660 --> 00:11:16,493
Guess what?

317
00:11:16,493 --> 00:11:18,090
It's a recorded demo, so it's gonna work.

318
00:11:18,090 --> 00:11:20,580
And we have our value there.

319
00:11:20,580 --> 00:11:22,290
Let's take it a little bit further.

320
00:11:22,290 --> 00:11:24,750
So we did select star,
we did select fields.

321
00:11:24,750 --> 00:11:28,200
Let's do a select count from this table.

322
00:11:28,200 --> 00:11:30,120
Same criteria, same filter criteria.

323
00:11:30,120 --> 00:11:32,550
We're not gonna execute it,
we just want it to translate.

324
00:11:32,550 --> 00:11:36,390
And when we run this, we don't
get the find operator back.

325
00:11:36,390 --> 00:11:37,440
We get an aggregation.

326
00:11:37,440 --> 00:11:39,900
Oh man, this would've
taken me like 30 minutes

327
00:11:39,900 --> 00:11:41,970
to mistype every single time.

328
00:11:41,970 --> 00:11:43,950
But now I can just copy that,

329
00:11:43,950 --> 00:11:46,560
paste that in and I get my results. 75.

330
00:11:46,560 --> 00:11:48,870
It did a dollar match with a dollar count.

331
00:11:48,870 --> 00:11:50,880
Like I said, you can customize
the LLM with this tool.

332
00:11:50,880 --> 00:11:53,490
So what we're gonna do is instead of using

333
00:11:53,490 --> 00:11:56,730
that Code Llama 3B or LLM,

334
00:11:56,730 --> 00:11:59,070
we're gonna use that 13B,
about twice the size,

335
00:11:59,070 --> 00:12:00,900
7.4 gigs versus that four.

336
00:12:00,900 --> 00:12:03,660
Again, the trade off here is
you use a lot of space locally,

337
00:12:03,660 --> 00:12:05,490
but you're doing it locally.

338
00:12:05,490 --> 00:12:07,200
Again, demo, this is preloaded.

339
00:12:07,200 --> 00:12:09,780
Might take you a minute to
download that on your machine.

340
00:12:09,780 --> 00:12:11,790
We need to go update our JSON file

341
00:12:11,790 --> 00:12:13,440
that Mongo shell is calling on.

342
00:12:13,440 --> 00:12:14,451
So tell it, instead of using

343
00:12:14,451 --> 00:12:16,620
that Code Llama 7B library,

344
00:12:16,620 --> 00:12:19,710
let's switch over to the Code Llama 13B.

345
00:12:19,710 --> 00:12:21,607
Once we change that, the
cool thing is we don't have

346
00:12:21,607 --> 00:12:23,250
to recompile it anything, right?

347
00:12:23,250 --> 00:12:26,190
This is just a flat file within JS,

348
00:12:26,190 --> 00:12:27,690
and when we launch Mongo shell,

349
00:12:27,690 --> 00:12:30,510
it's gonna be referencing
this new library for us.

350
00:12:30,510 --> 00:12:31,910
So we'll launch Mongo shell.

351
00:12:35,400 --> 00:12:37,290
We will go back into that
demo name space again,

352
00:12:37,290 --> 00:12:38,700
the same place we were before.

353
00:12:38,700 --> 00:12:39,870
You can see nothing's changed here.

354
00:12:39,870 --> 00:12:41,970
We're still using the Ollama.

355
00:12:41,970 --> 00:12:44,940
And we will run the exact
same query we just ran.

356
00:12:44,940 --> 00:12:47,880
That select count IDs from
table with a two wear clauses.

357
00:12:47,880 --> 00:12:50,550
Remember we had a dollar match
and we had a dollar count,

358
00:12:50,550 --> 00:12:51,570
slightly different.

359
00:12:51,570 --> 00:12:54,570
Dollar match, dollar ad fields,
dollar match, dollar count.

360
00:12:54,570 --> 00:12:57,180
But when we run that,
we get the same results.

361
00:12:57,180 --> 00:12:59,880
We still get those 75 results back.

362
00:12:59,880 --> 00:13:01,350
So customize that LLM.

363
00:13:01,350 --> 00:13:02,220
Well, let's switch over.

364
00:13:02,220 --> 00:13:03,450
That was the local version.

365
00:13:03,450 --> 00:13:05,130
Let's switch over to the Bedrock version.

366
00:13:05,130 --> 00:13:07,860
And just like before, we're
gonna run our shell script

367
00:13:07,860 --> 00:13:09,420
to install the dependencies on this.

368
00:13:09,420 --> 00:13:10,680
And this one's gonna go a lot faster

369
00:13:10,680 --> 00:13:13,140
because you're not
installing any local LLM.

370
00:13:13,140 --> 00:13:15,240
It's gonna reach out to Bedrock.

371
00:13:15,240 --> 00:13:17,580
When we run this exact
same process as before,

372
00:13:17,580 --> 00:13:20,190
it's gonna ask us where is
that compatibility tool file.

373
00:13:20,190 --> 00:13:22,320
So it can tell us, give us recommendations

374
00:13:22,320 --> 00:13:24,090
based on supported APIs.

375
00:13:24,090 --> 00:13:28,470
We plug that in, it very quickly
installs everything else.

376
00:13:28,470 --> 00:13:30,630
Now, our next steps
are slightly different.

377
00:13:30,630 --> 00:13:32,700
The first thing we have
to do is run AWS configure

378
00:13:32,700 --> 00:13:34,802
because we are making
calls to Bedrock with this

379
00:13:34,802 --> 00:13:36,240
and we have to have
credentials to do that.

380
00:13:36,240 --> 00:13:38,700
That second item, ensure you have access.

381
00:13:38,700 --> 00:13:39,570
You don't have to do that anymore.

382
00:13:39,570 --> 00:13:41,430
About two, three weeks ago we changed that

383
00:13:41,430 --> 00:13:43,500
and you have access to
all models by default.

384
00:13:43,500 --> 00:13:44,940
So it's old already.

385
00:13:44,940 --> 00:13:45,773
We need to update that.

386
00:13:45,773 --> 00:13:49,200
But you can see it's
using Claude 3 for this.

387
00:13:49,200 --> 00:13:50,640
The interaction is exactly the same.

388
00:13:50,640 --> 00:13:51,960
We have a TSQL wrapper.

389
00:13:51,960 --> 00:13:54,540
So we will go back into Mongo shell

390
00:13:54,540 --> 00:13:56,130
and we can see when we connect

391
00:13:56,130 --> 00:13:58,890
that we are now using the
Bedrock-powered plugin.

392
00:13:58,890 --> 00:14:00,990
We're gonna go into the same name space.

393
00:14:00,990 --> 00:14:03,600
We'll run that same query,
the count ID from table

394
00:14:03,600 --> 00:14:06,420
with these two where clauses.

395
00:14:06,420 --> 00:14:07,470
Now we don't have an aggregate.

396
00:14:07,470 --> 00:14:10,050
We have a count document,
slightly different.

397
00:14:10,050 --> 00:14:11,670
So you can see we're
getting slightly different

398
00:14:11,670 --> 00:14:12,720
results from each of these.

399
00:14:12,720 --> 00:14:16,290
But we have the same number of queries.

400
00:14:16,290 --> 00:14:17,440
What's cool about this?

401
00:14:18,870 --> 00:14:20,250
Oh, I forgot about this one.

402
00:14:20,250 --> 00:14:22,170
So this one you can see we got results.

403
00:14:22,170 --> 00:14:24,420
We left that auto execute false off of it.

404
00:14:24,420 --> 00:14:25,680
So when you leave that off of it,

405
00:14:25,680 --> 00:14:27,300
not only is it gonna
give you the translation,

406
00:14:27,300 --> 00:14:29,250
it's gonna give you the result as well.

407
00:14:30,240 --> 00:14:33,150
This is, it's pretty
powerful For somebody like me

408
00:14:33,150 --> 00:14:35,430
who cannot write a MQL statement

409
00:14:35,430 --> 00:14:36,870
correctly the first 12 times.

410
00:14:36,870 --> 00:14:37,920
It saves me a lot of times.

411
00:14:37,920 --> 00:14:40,230
But what this can get
pretty gnarly, right?

412
00:14:40,230 --> 00:14:42,687
We can put some pretty big
TSQL statements in here

413
00:14:42,687 --> 00:14:44,310
and it'll translate it for us.

414
00:14:44,310 --> 00:14:47,790
So for example, we have this, select star

415
00:14:47,790 --> 00:14:51,270
with a bunch of wheres and
and statements in an order by,

416
00:14:51,270 --> 00:14:52,110
and there we go.

417
00:14:52,110 --> 00:14:53,550
It turns that into a find,

418
00:14:53,550 --> 00:14:55,620
it has some regex searches for us,

419
00:14:55,620 --> 00:14:57,420
has some dollar endless for us.

420
00:14:57,420 --> 00:14:59,190
It has some sort criteria.

421
00:14:59,190 --> 00:15:00,810
It takes care of all of this for us.

422
00:15:00,810 --> 00:15:02,670
So very quickly, instead of Cody crying

423
00:15:02,670 --> 00:15:06,930
and being upset and yelling
at the dogs and children

424
00:15:06,930 --> 00:15:08,760
for not knowing what he's doing,

425
00:15:08,760 --> 00:15:10,380
very quickly we have
the results back there.

426
00:15:10,380 --> 00:15:11,820
So this is really an example

427
00:15:11,820 --> 00:15:14,820
of how you can use these
gen AI tools with DocumentDB

428
00:15:14,820 --> 00:15:17,670
to improve your developer
experience, right?

429
00:15:17,670 --> 00:15:19,560
Make things easier and more productive

430
00:15:19,560 --> 00:15:21,063
for those internal teams.

431
00:15:21,900 --> 00:15:25,470
Next thing we're gonna talk
about are RAG architectures.

432
00:15:25,470 --> 00:15:28,233
Again, dramatic pause
'cause I'm losing my voice.

433
00:15:31,560 --> 00:15:35,130
Now, earlier I told you
that there is a key element

434
00:15:35,130 --> 00:15:38,010
that is the differentiator
for these new gen AI apps.

435
00:15:38,010 --> 00:15:41,430
That key differentiator
is your data, right?

436
00:15:41,430 --> 00:15:44,130
Your data is what makes
gen AI applications

437
00:15:44,130 --> 00:15:45,960
that are unique to your business.

438
00:15:45,960 --> 00:15:48,600
Everybody here has access

439
00:15:48,600 --> 00:15:50,580
to the exact same foundational models.

440
00:15:50,580 --> 00:15:54,120
Just like we saw, you
can get Llama models,

441
00:15:54,120 --> 00:15:56,310
you can get Bedrock models, right?

442
00:15:56,310 --> 00:15:58,950
But only the folks here
that are using their data

443
00:15:58,950 --> 00:16:02,370
to build Gen AI apps are
gonna be creating real value,

444
00:16:02,370 --> 00:16:04,140
that are gonna be creating
something that you can build on

445
00:16:04,140 --> 00:16:05,880
that is gonna improve
your customer's experience

446
00:16:05,880 --> 00:16:07,560
and your employee's experience, right?

447
00:16:07,560 --> 00:16:09,630
Your data is the differentiator

448
00:16:09,630 --> 00:16:11,640
between just generic gen AI app,

449
00:16:11,640 --> 00:16:13,710
like something like ChatGPT and something

450
00:16:13,710 --> 00:16:16,620
that knows your business and
your customers extremely well.

451
00:16:16,620 --> 00:16:18,450
But the good thing is you don't have

452
00:16:18,450 --> 00:16:19,980
to build your own model.

453
00:16:19,980 --> 00:16:22,680
We have some customers that have three,

454
00:16:22,680 --> 00:16:24,360
four decades of documents.

455
00:16:24,360 --> 00:16:26,250
They have billions of documents
that they can refer back to

456
00:16:26,250 --> 00:16:28,290
and they can hire data
scientists, create LLMs.

457
00:16:28,290 --> 00:16:29,730
You don't have to do that, right?

458
00:16:29,730 --> 00:16:31,650
You can use your organizational data

459
00:16:31,650 --> 00:16:34,230
to fine tune these foundational
models through this process

460
00:16:34,230 --> 00:16:37,860
called retrieval augmented
generation or RAG.

461
00:16:37,860 --> 00:16:39,930
And to get very, very technical with you,

462
00:16:39,930 --> 00:16:41,160
what does that mean?

463
00:16:41,160 --> 00:16:43,050
You fetch the relevant information,

464
00:16:43,050 --> 00:16:46,950
you add that to your context
and you generate a response.

465
00:16:46,950 --> 00:16:47,783
Whew.

466
00:16:47,783 --> 00:16:49,260
That's some level 400 stuff.

467
00:16:49,260 --> 00:16:51,780
I'll try to keep it down from
there, folks. I apologize.

468
00:16:51,780 --> 00:16:53,220
Give you an example.

469
00:16:53,220 --> 00:16:55,410
Let's say that you have
this online shoe store

470
00:16:55,410 --> 00:16:57,330
and you want to help out
with an interactive agent.

471
00:16:57,330 --> 00:17:00,240
For example, they say,
can I return my shoes?

472
00:17:00,240 --> 00:17:01,770
I wanna get a refund.

473
00:17:01,770 --> 00:17:03,630
This is where your operational
data store comes in.

474
00:17:03,630 --> 00:17:06,030
So the agent is gonna do a fact lookup

475
00:17:06,030 --> 00:17:09,210
against your database
that has your inventory

476
00:17:09,210 --> 00:17:10,980
or your database that holds
that order information

477
00:17:10,980 --> 00:17:12,630
to get the relevant details.

478
00:17:12,630 --> 00:17:15,150
Then it's gonna do a
vector similarity search

479
00:17:15,150 --> 00:17:17,850
against your collection that
holds your policy documents.

480
00:17:17,850 --> 00:17:20,610
Maybe there's a fee that you charge

481
00:17:20,610 --> 00:17:22,590
if they've ordered it
more than 30 days ago

482
00:17:22,590 --> 00:17:25,080
or maybe they get a free upgrade

483
00:17:25,080 --> 00:17:27,480
if it's within seven days,
whatever it is, right?

484
00:17:27,480 --> 00:17:30,090
You're doing a similarity
search against your data store

485
00:17:30,090 --> 00:17:32,370
as that knowledge repository to be able

486
00:17:32,370 --> 00:17:35,250
to make a decision to replace their shoe.

487
00:17:35,250 --> 00:17:36,210
That's high level.

488
00:17:36,210 --> 00:17:37,050
Let's look at the back end.

489
00:17:37,050 --> 00:17:37,883
Let's look at the architecture

490
00:17:37,883 --> 00:17:38,730
and kind of walk through that.

491
00:17:38,730 --> 00:17:42,390
So number one, that user
is gonna ask the question.

492
00:17:42,390 --> 00:17:44,040
You're gonna have a
prompt that handles that,

493
00:17:44,040 --> 00:17:47,040
but this is where there
the interaction starts.

494
00:17:47,040 --> 00:17:50,880
Next, there is going to be a repository

495
00:17:50,880 --> 00:17:52,020
to hold their conversation history.

496
00:17:52,020 --> 00:17:54,510
A lot of times that conversation

497
00:17:54,510 --> 00:17:56,520
was part of an ongoing conversation.

498
00:17:56,520 --> 00:17:58,140
You have to take the kids
to lacrosse practice.

499
00:17:58,140 --> 00:18:00,900
You have to go cook dinner
or there, whatever, right?

500
00:18:00,900 --> 00:18:03,150
You get distracted, you come back.

501
00:18:03,150 --> 00:18:05,040
You want to hold onto that.

502
00:18:05,040 --> 00:18:06,690
Next, the application needs a query

503
00:18:06,690 --> 00:18:08,160
for your situational data

504
00:18:08,160 --> 00:18:09,420
and that's gonna be outta your data store.

505
00:18:09,420 --> 00:18:10,710
That's what we were talking about earlier,

506
00:18:10,710 --> 00:18:13,320
like the inventory, the order status.

507
00:18:13,320 --> 00:18:15,840
Application's gonna tokenize
that original question

508
00:18:15,840 --> 00:18:19,383
using an LLM to generate
the question embedding.

509
00:18:20,310 --> 00:18:21,840
With that, it's gonna perform

510
00:18:21,840 --> 00:18:24,570
that similarity search
and the vector data store

511
00:18:24,570 --> 00:18:26,760
that's gonna use some kind of algorithm.

512
00:18:26,760 --> 00:18:27,930
Approximate nearest neighbor.

513
00:18:27,930 --> 00:18:29,760
We'll see that later.

514
00:18:29,760 --> 00:18:31,920
Then it's gonna synthesize all of that

515
00:18:31,920 --> 00:18:33,420
into an engineered prompt to send back

516
00:18:33,420 --> 00:18:35,100
to the LLM to get a response.

517
00:18:35,100 --> 00:18:37,440
We had to go update that
conversation again, and guess what?

518
00:18:37,440 --> 00:18:39,660
We end by returning response.

519
00:18:39,660 --> 00:18:42,240
It's kind of the data flow
that we go through there.

520
00:18:42,240 --> 00:18:45,420
Now, this is where DocumentDB comes in.

521
00:18:45,420 --> 00:18:48,420
So with its support of vector
search through vector indexes,

522
00:18:50,970 --> 00:18:53,310
this is gonna run all your vector search

523
00:18:53,310 --> 00:18:54,480
and your data source search are gonna run

524
00:18:54,480 --> 00:18:57,267
against the same repository
because DocumentDB

525
00:18:58,800 --> 00:19:00,240
is your operational data store.

526
00:19:00,240 --> 00:19:02,850
And on top of that, even
though conversation history's

527
00:19:02,850 --> 00:19:04,890
up there by itself, all by its lonesome,

528
00:19:04,890 --> 00:19:06,270
that can sit in DocumentDB.

529
00:19:06,270 --> 00:19:08,700
You just severely decrease the complexity

530
00:19:08,700 --> 00:19:10,200
of that architecture with that support

531
00:19:10,200 --> 00:19:13,023
of vector indexes on Amazon DocumentDB.

532
00:19:15,150 --> 00:19:15,983
Let's go into a demo.

533
00:19:15,983 --> 00:19:17,580
Let's take a look at this one.

534
00:19:17,580 --> 00:19:20,433
So here have a black screen.

535
00:19:21,330 --> 00:19:22,650
It's very nice.

536
00:19:22,650 --> 00:19:23,490
There we go.

537
00:19:23,490 --> 00:19:26,340
Here, what we're gonna do is
create a DocumentDB chatbot,

538
00:19:28,200 --> 00:19:29,070
hopefully.

539
00:19:29,070 --> 00:19:31,020
First thing we gotta do
is install some libraries.

540
00:19:31,020 --> 00:19:32,790
So the two big libraries we're gonna use

541
00:19:32,790 --> 00:19:34,623
is that Gradio, and that's
just for interaction with it

542
00:19:34,623 --> 00:19:37,013
just for the demo and LangChain.

543
00:19:37,013 --> 00:19:38,910
LangChain is what we're gonna
use to create our vectors

544
00:19:38,910 --> 00:19:42,750
that are gonna go into Amazon DocumentDB.

545
00:19:42,750 --> 00:19:44,850
Once we have those established, we have

546
00:19:44,850 --> 00:19:48,870
to set up some variables
for the vector itself.

547
00:19:48,870 --> 00:19:50,700
We have to say how many
embeddings we need.

548
00:19:50,700 --> 00:19:52,380
We have to set some
parameters for the index

549
00:19:52,380 --> 00:19:54,180
that we'll create in just one second.

550
00:19:54,180 --> 00:19:56,370
We're gonna touch on those
values a little bit later.

551
00:19:56,370 --> 00:19:58,890
We won't read too much
into it at this point.

552
00:19:58,890 --> 00:20:00,990
Then we have to establish the index

553
00:20:00,990 --> 00:20:03,150
that we're gonna create
on Amazon DocumentDB.

554
00:20:03,150 --> 00:20:05,130
Here we're gonna create an HNSW index

555
00:20:05,130 --> 00:20:07,410
with cosine similarity
and we're gonna pass

556
00:20:07,410 --> 00:20:11,070
in some of those values
that we established earlier.

557
00:20:11,070 --> 00:20:12,660
Once we have that
established, we can go ahead

558
00:20:12,660 --> 00:20:14,850
and create our Mongo client connection

559
00:20:14,850 --> 00:20:16,590
to our DocumentDB database.

560
00:20:16,590 --> 00:20:20,310
This is using Pi Mongo, MongoDB API.

561
00:20:20,310 --> 00:20:22,740
We're just setting our
pool size, our timeouts.

562
00:20:22,740 --> 00:20:23,820
Then we have to chunk up our data.

563
00:20:23,820 --> 00:20:27,210
We have to put our data into
DocumentDB with the vectors.

564
00:20:27,210 --> 00:20:28,890
And so what we're gonna do
is we're gonna chunk our data

565
00:20:28,890 --> 00:20:32,190
into thousand characters with
200 characters of overlap

566
00:20:32,190 --> 00:20:33,270
'cause we want to keep the meaning.

567
00:20:33,270 --> 00:20:35,190
We don't wanna lose the meaning.

568
00:20:35,190 --> 00:20:36,090
What are the data?

569
00:20:36,090 --> 00:20:38,610
What's the data that we're
going to be processing?

570
00:20:38,610 --> 00:20:41,790
Well, we have the entire 1500 page

571
00:20:41,790 --> 00:20:43,200
developer guide of DocumentDB.

572
00:20:43,200 --> 00:20:45,870
We have our data modeling guide and PDF

573
00:20:45,870 --> 00:20:47,100
and that's what we're
using Lang Chain for.

574
00:20:47,100 --> 00:20:50,280
We're gonna break those apart
into thousand character chunks

575
00:20:50,280 --> 00:20:51,840
with 200 characters of overlap

576
00:20:51,840 --> 00:20:54,600
and then create an embedding off those.

577
00:20:54,600 --> 00:20:56,040
On top of that, we're gonna go parse

578
00:20:56,040 --> 00:20:58,800
every single DocumentDB
blog that's out there

579
00:20:58,800 --> 00:21:00,870
and we're gonna grab all
that information as well

580
00:21:00,870 --> 00:21:03,090
and put that into
thousand character chunks.

581
00:21:03,090 --> 00:21:05,820
Once we have all that
and we're gonna take it

582
00:21:05,820 --> 00:21:08,970
and we're going to feed
that through our, oh yeah,

583
00:21:08,970 --> 00:21:10,827
we're also gonna get the
pricing page and the FAQ page

584
00:21:10,827 --> 00:21:12,420
and the features page, right?

585
00:21:12,420 --> 00:21:14,850
Think of this as your operational data.

586
00:21:14,850 --> 00:21:17,700
Now all this is public,
but for the sake of a demo,

587
00:21:17,700 --> 00:21:19,980
imagine this is your internal information.

588
00:21:19,980 --> 00:21:20,813
We're gonna pass that through

589
00:21:20,813 --> 00:21:22,860
that Titan Text Embedding v2 model

590
00:21:22,860 --> 00:21:24,720
in order to create those embeddings.

591
00:21:24,720 --> 00:21:26,940
We're gonna keep the
original text document,

592
00:21:26,940 --> 00:21:28,440
the thousand characters.

593
00:21:28,440 --> 00:21:31,050
We're gonna keep the vector
content, all those numbers

594
00:21:31,050 --> 00:21:33,060
of those characters, and
we're gonna have metadata.

595
00:21:33,060 --> 00:21:33,893
Where did this come from?

596
00:21:33,893 --> 00:21:34,830
What page is it from?

597
00:21:34,830 --> 00:21:35,663
Things like that.

598
00:21:35,663 --> 00:21:37,500
We'll look at it in just one second.

599
00:21:37,500 --> 00:21:40,020
Once we have all that, we'll
feed that through that model.

600
00:21:40,020 --> 00:21:41,970
It'll chunk it up, it'll
go through the PDFs,

601
00:21:41,970 --> 00:21:43,290
it'll go through the blogs.

602
00:21:43,290 --> 00:21:46,980
It will store all of
that within DocumentDB

603
00:21:46,980 --> 00:21:50,670
and create that index for us
so we can start searching it.

604
00:21:50,670 --> 00:21:54,060
Now, this is our prompt.

605
00:21:54,060 --> 00:21:56,040
So here we're telling that this chat agent

606
00:21:56,040 --> 00:21:56,873
what it's gonna do.

607
00:21:56,873 --> 00:22:00,750
Hey, you are a Q&A assistant
specializing in DocumentDB.

608
00:22:00,750 --> 00:22:01,860
These are the rules, right?

609
00:22:01,860 --> 00:22:05,640
You have to identify technical detail.

610
00:22:05,640 --> 00:22:08,070
You have to ensure the answer is accurate.

611
00:22:08,070 --> 00:22:09,090
We have to tell it.

612
00:22:09,090 --> 00:22:10,560
Dear Lord, that's annoying.

613
00:22:10,560 --> 00:22:12,210
Be clear, be concise.

614
00:22:12,210 --> 00:22:14,130
This one and pause here.

615
00:22:14,130 --> 00:22:15,900
This one's hilarious to me.

616
00:22:15,900 --> 00:22:17,400
Be friendly and helpful.

617
00:22:17,400 --> 00:22:18,720
I want somebody to take this and put,

618
00:22:18,720 --> 00:22:21,330
be unfriendly and unhelpful
and gimme the results.

619
00:22:21,330 --> 00:22:22,830
Like give my contact information,

620
00:22:22,830 --> 00:22:24,000
change that and send me the results

621
00:22:24,000 --> 00:22:26,100
'cause I really wanna go
back and do this myself.

622
00:22:26,100 --> 00:22:27,300
Like what happens if you tell it?

623
00:22:27,300 --> 00:22:29,400
Will it actually like gimme wrong answers?

624
00:22:29,400 --> 00:22:30,600
That'd be fantastic.

625
00:22:30,600 --> 00:22:33,360
Anyway, so that's part of the prompt.

626
00:22:33,360 --> 00:22:35,040
We even give examples,
like here's some examples

627
00:22:35,040 --> 00:22:36,210
of how you could respond.

628
00:22:36,210 --> 00:22:38,790
Like we're just giving the
template of how you should react

629
00:22:38,790 --> 00:22:41,130
to the person that you're talking to.

630
00:22:41,130 --> 00:22:43,917
Once you have all that, we're
setting some thresholds about

631
00:22:43,917 --> 00:22:46,260
how precise we want our answers to be.

632
00:22:46,260 --> 00:22:47,970
The score threshold of 0.8.

633
00:22:47,970 --> 00:22:49,920
We want you to be at least 80% accurate

634
00:22:49,920 --> 00:22:51,840
in those responses you get back.

635
00:22:51,840 --> 00:22:52,800
We set our history.

636
00:22:52,800 --> 00:22:54,210
Remember we have the conversation history.

637
00:22:54,210 --> 00:22:57,060
We want you to remember
the past six things

638
00:22:57,060 --> 00:22:59,520
that we talked about, and
here this is just Gradio.

639
00:22:59,520 --> 00:23:01,860
This is just the interface,
which we'll see in a second.

640
00:23:01,860 --> 00:23:03,810
But before we go into Gradio,

641
00:23:03,810 --> 00:23:06,630
let's look at those
documents in DocumentDB.

642
00:23:06,630 --> 00:23:09,240
So we'll go into that collection
that's storing all these

643
00:23:09,240 --> 00:23:12,210
and we're gonna look at some projections.

644
00:23:12,210 --> 00:23:15,360
So we have about 5,400
documents from those PDFs.

645
00:23:15,360 --> 00:23:16,290
All those blogs.

646
00:23:16,290 --> 00:23:19,800
They got parsed into
5400 different documents.

647
00:23:19,800 --> 00:23:21,090
Those documents look like this.

648
00:23:21,090 --> 00:23:23,340
You have your text content,
there's that metadata

649
00:23:23,340 --> 00:23:24,540
that tells you where it came from.

650
00:23:24,540 --> 00:23:27,603
So for example, this one came
from the developer guide PDF.

651
00:23:28,776 --> 00:23:31,863
We will skip a few,
look at a different one.

652
00:23:32,730 --> 00:23:34,710
This one is about vector embeddings

653
00:23:34,710 --> 00:23:36,240
and it came from a, funny enough,

654
00:23:36,240 --> 00:23:38,220
it came from a blog
about vector embeddings.

655
00:23:38,220 --> 00:23:39,540
How topical.

656
00:23:39,540 --> 00:23:40,860
Again, this is a demo prerecorded.

657
00:23:40,860 --> 00:23:41,693
This is all set up.

658
00:23:41,693 --> 00:23:43,320
It's not a coincidence.

659
00:23:43,320 --> 00:23:44,700
Let's look at a full document.

660
00:23:44,700 --> 00:23:46,530
So what I'm doing is I'm just
showing you a couple fields,

661
00:23:46,530 --> 00:23:47,940
but if we look at the entire document

662
00:23:47,940 --> 00:23:49,170
of what these documents look like

663
00:23:49,170 --> 00:23:51,810
when they're in DocumentDB,
we have our text content.

664
00:23:51,810 --> 00:23:52,643
There are those numbers.

665
00:23:52,643 --> 00:23:53,670
They mean nothing to us.

666
00:23:53,670 --> 00:23:56,220
That's what the computer's
using for that vector index.

667
00:23:56,220 --> 00:23:59,040
We have our metadata, the
title where it came from,

668
00:23:59,040 --> 00:24:00,420
the page, the link.

669
00:24:00,420 --> 00:24:03,840
So here we're gonna ask
it a very simple question.

670
00:24:03,840 --> 00:24:06,150
Does DocumentDB offer
serverless instances?

671
00:24:06,150 --> 00:24:06,983
This is simple, right?

672
00:24:06,983 --> 00:24:08,520
I can just read the dev
guide and figure this out,

673
00:24:08,520 --> 00:24:10,140
but hey, I have a chatbot.

674
00:24:10,140 --> 00:24:12,930
It's fun, it's exciting,
it's supposed to be helpful.

675
00:24:12,930 --> 00:24:15,210
Remember, I wanna see what it's
like when it's not helpful.

676
00:24:15,210 --> 00:24:17,040
We can make it a little
bit more complex, right?

677
00:24:17,040 --> 00:24:20,700
We can say, how do I audit
logins in the cluster, right?

678
00:24:20,700 --> 00:24:22,410
I need to know the use that I connected.

679
00:24:22,410 --> 00:24:23,760
I need to know the time and the date

680
00:24:23,760 --> 00:24:25,470
that they connected, right?

681
00:24:25,470 --> 00:24:27,327
Again, this vector
search is gonna come back

682
00:24:27,327 --> 00:24:29,670
and it's going to give
me the exact answer.

683
00:24:29,670 --> 00:24:31,710
It's gonna say, Hey, do this to enable it.

684
00:24:31,710 --> 00:24:33,420
And by the way, when you enable it,

685
00:24:33,420 --> 00:24:35,670
these logs are go to CloudWatch
and these are the fields

686
00:24:35,670 --> 00:24:36,900
in CloudWatch that you're gonna have.

687
00:24:36,900 --> 00:24:40,950
And by the way, if's a query
that you can run in CloudWatch.

688
00:24:40,950 --> 00:24:42,930
If there's something
I'm worse at than MQL,

689
00:24:42,930 --> 00:24:44,550
it's CloudWatch filtering.

690
00:24:44,550 --> 00:24:45,383
And so there you go.

691
00:24:45,383 --> 00:24:47,403
You have that CloudWatch filter there.

692
00:24:48,270 --> 00:24:50,280
Increasing the complexity.

693
00:24:50,280 --> 00:24:51,930
We can ask about indexes.

694
00:24:51,930 --> 00:24:54,120
I need a partial indexes
on my customer collection.

695
00:24:54,120 --> 00:24:56,190
It filters for this address sate of Texas.

696
00:24:56,190 --> 00:24:57,870
Any Texans here?

697
00:24:57,870 --> 00:24:59,073
Yeehaw, I'm glad.

698
00:25:00,930 --> 00:25:01,860
And it's gonna go back.

699
00:25:01,860 --> 00:25:02,693
It's gonna parse that.

700
00:25:02,693 --> 00:25:06,300
It's gonna look through
it again using our data

701
00:25:06,300 --> 00:25:08,223
to augment that LLM and it's
gonna give us the information,

702
00:25:08,223 --> 00:25:10,230
it's gonna tell us how to do that.

703
00:25:10,230 --> 00:25:12,480
You need to put this
partial filtered expression.

704
00:25:12,480 --> 00:25:13,313
What's cool.

705
00:25:13,313 --> 00:25:14,187
It even tells us exactly what it's doing

706
00:25:14,187 --> 00:25:15,480
and the key points about it.

707
00:25:15,480 --> 00:25:17,100
So it's gonna give us
additional information.

708
00:25:17,100 --> 00:25:20,880
Again, this response can be
customized by your prompt.

709
00:25:20,880 --> 00:25:23,550
Here we're gonna say, I
need to join my orders

710
00:25:23,550 --> 00:25:25,440
and customers collection
by my top three customers.

711
00:25:25,440 --> 00:25:27,900
This was that query we saw earlier.

712
00:25:27,900 --> 00:25:30,570
Again, we saw the TSQL tool
that can do something similar.

713
00:25:30,570 --> 00:25:32,760
But here we're doing
it in natural language

714
00:25:32,760 --> 00:25:34,200
to get this answer.

715
00:25:34,200 --> 00:25:36,570
What I like about this one,
it walks us through it.

716
00:25:36,570 --> 00:25:39,210
It walks us through each stage
of that aggregation again.

717
00:25:39,210 --> 00:25:41,160
So my old lizard relational brain

718
00:25:41,160 --> 00:25:42,510
can understand what the heck it's doing.

719
00:25:42,510 --> 00:25:44,370
Well, you're gonna start
off by doing a dollar lookup

720
00:25:44,370 --> 00:25:46,080
and then you're gonna do a dollar unwind.

721
00:25:46,080 --> 00:25:47,820
You're gonna do a group, right?

722
00:25:47,820 --> 00:25:50,520
It uses all that knowledge
base of what we fed it

723
00:25:50,520 --> 00:25:53,760
to give us this answer that's
specific to DocumentDB.

724
00:25:53,760 --> 00:25:56,040
We can get more complex, right?

725
00:25:56,040 --> 00:25:58,500
The next question we're gonna ask.

726
00:25:58,500 --> 00:25:59,700
Whoever's running this demo is terrible.

727
00:25:59,700 --> 00:26:00,600
Come on, hurry up.

728
00:26:02,250 --> 00:26:03,630
Here's a fun one.

729
00:26:03,630 --> 00:26:06,060
We have an e-commerce platform
currently using Postgres

730
00:26:06,060 --> 00:26:08,550
with separate tables for
products, inventories, orders,

731
00:26:08,550 --> 00:26:10,230
shipping, and customer reviews.

732
00:26:10,230 --> 00:26:12,300
And there's multiple variants
and there's categories.

733
00:26:12,300 --> 00:26:13,850
I have a hundred thousand SKUs.

734
00:26:14,790 --> 00:26:15,990
Watch this on YouTube later.

735
00:26:15,990 --> 00:26:17,220
Pause the video if you
wanna read all that.

736
00:26:17,220 --> 00:26:18,199
I'm not gonna go through
it, but we have this.

737
00:26:18,199 --> 00:26:19,032
(audience member sneezes)

738
00:26:19,032 --> 00:26:19,865
Bless you.

739
00:26:19,865 --> 00:26:22,020
We have this very complex
question that we're gonna ask it.

740
00:26:22,020 --> 00:26:24,720
Let's feed that and see what it tells us.

741
00:26:24,720 --> 00:26:25,553
Well, there we go.

742
00:26:25,553 --> 00:26:26,670
Remember one of the documents we fed it

743
00:26:26,670 --> 00:26:29,097
was a schema design
document with DocumentDB.

744
00:26:29,097 --> 00:26:30,897
And it's gonna use that
to come back and tell us

745
00:26:30,897 --> 00:26:32,910
this is what your product collection

746
00:26:32,910 --> 00:26:34,140
should look like, right?

747
00:26:34,140 --> 00:26:35,520
This is what your
product review collection

748
00:26:35,520 --> 00:26:36,353
should look like.

749
00:26:36,353 --> 00:26:37,470
This is what your inventory document,

750
00:26:37,470 --> 00:26:38,910
your orders collection.

751
00:26:38,910 --> 00:26:40,950
Put this in the hands of
your developers, right?

752
00:26:40,950 --> 00:26:43,247
It's going to streamline their interaction

753
00:26:43,247 --> 00:26:44,864
with document to be in document databases.

754
00:26:44,864 --> 00:26:45,870
(audience member sneezes)

755
00:26:45,870 --> 00:26:46,703
Bless you.

756
00:26:47,790 --> 00:26:49,540
We'll ask it another question about

757
00:26:51,300 --> 00:26:53,640
a more complex situation.

758
00:26:53,640 --> 00:26:55,650
We're saying that we
have a gaming platform.

759
00:26:55,650 --> 00:26:57,540
We track player progress and achievements

760
00:26:57,540 --> 00:27:00,270
and we have 15 normalized
tables and a million daily play.

761
00:27:00,270 --> 00:27:01,560
We're feeding an information about

762
00:27:01,560 --> 00:27:02,967
our rate of operations, right?

763
00:27:02,967 --> 00:27:05,130
And it's taking this in consideration.

764
00:27:05,130 --> 00:27:05,963
These are the things I need.

765
00:27:05,963 --> 00:27:07,470
I need real time player leaderboards.

766
00:27:07,470 --> 00:27:08,880
I need cross game achievement tracking.

767
00:27:08,880 --> 00:27:10,800
I need in-game purchase history.

768
00:27:10,800 --> 00:27:12,240
We're giving it all these requirements.

769
00:27:12,240 --> 00:27:13,290
Figure this out for me, right?

770
00:27:13,290 --> 00:27:14,670
And this is why I'm such a good programmer

771
00:27:14,670 --> 00:27:16,485
'cause I have tools like this.

772
00:27:16,485 --> 00:27:17,318
And it does that.

773
00:27:17,318 --> 00:27:19,470
It gives us a schema, it tells
us how to interact with it.

774
00:27:19,470 --> 00:27:21,330
It tells us where to store the data,

775
00:27:21,330 --> 00:27:22,320
the schema to store the data.

776
00:27:22,320 --> 00:27:25,440
How that data's gonna
interact with each other.

777
00:27:25,440 --> 00:27:28,140
It takes, again, all that
information we fed it

778
00:27:28,140 --> 00:27:31,140
to give us a customized
response for DocumentDB.

779
00:27:31,140 --> 00:27:32,850
The last one I wanna show you is one

780
00:27:32,850 --> 00:27:34,600
I think that gets overlooked a lot.

781
00:27:35,520 --> 00:27:37,440
Something that's really powerful.

782
00:27:37,440 --> 00:27:40,260
We work with a lot of
very large enterprises

783
00:27:40,260 --> 00:27:41,730
that work across the globe.

784
00:27:41,730 --> 00:27:43,590
We have companies that
are based in Nebraska

785
00:27:43,590 --> 00:27:45,300
with developers in Spain and London.

786
00:27:45,300 --> 00:27:47,520
We have customers that
are headquartered in Chile

787
00:27:47,520 --> 00:27:49,593
with developers in Argentina and Brazil.

788
00:27:50,430 --> 00:27:51,870
It's multilingual, right?

789
00:27:51,870 --> 00:27:52,860
That's a great thing about this.

790
00:27:52,860 --> 00:27:54,570
So for example, I'm asking
what language is this?

791
00:27:54,570 --> 00:27:55,830
Does anybody know?

792
00:27:55,830 --> 00:27:57,150
Anybody speak this?

793
00:27:57,150 --> 00:27:57,983
- [Audience Member] Portuguese.

794
00:27:57,983 --> 00:27:59,040
- Portuguese

795
00:27:59,040 --> 00:28:01,140
This is saying is DocumentDB

796
00:28:01,140 --> 00:28:02,910
supported in the Sao Paulo region?

797
00:28:02,910 --> 00:28:04,530
And what it's gonna do, it's
gonna translate that for us.

798
00:28:04,530 --> 00:28:05,970
It's gonna go to our
operational data source.

799
00:28:05,970 --> 00:28:10,050
Say yes, DocumentDB is supported
in the Sao Paulo region.

800
00:28:10,050 --> 00:28:12,780
So now if you have
developers across the globe

801
00:28:12,780 --> 00:28:14,850
using multiple languages,
they can interact with a tool

802
00:28:14,850 --> 00:28:17,280
like this in their native
language and it handles that.

803
00:28:17,280 --> 00:28:19,740
It's gonna answer them the
same way it answers your person

804
00:28:19,740 --> 00:28:22,530
in Nebraska and Spain and
England and Chile and Argentina.

805
00:28:22,530 --> 00:28:24,660
You get those same answers.

806
00:28:24,660 --> 00:28:26,730
So for the next excess pattern,

807
00:28:26,730 --> 00:28:28,283
I'm gonna hand this over to Doug.

808
00:28:31,050 --> 00:28:32,118
Are we gonna?

809
00:28:32,118 --> 00:28:32,951
- Yeah, adjust things

810
00:28:32,951 --> 00:28:34,650
Alright, everybody, still hear me?

811
00:28:34,650 --> 00:28:35,940
Alright, thanks, Cody.

812
00:28:35,940 --> 00:28:39,150
Okay, so we're gonna talk
about third access pattern.

813
00:28:39,150 --> 00:28:44,150
Cody talked about the TSQL
plugin for Mongo shell,

814
00:28:44,160 --> 00:28:46,740
talked about RAG architecture.

815
00:28:46,740 --> 00:28:50,070
So now we're gonna talk
about model context protocol

816
00:28:50,070 --> 00:28:51,960
or MCP servers.

817
00:28:51,960 --> 00:28:55,413
How many of you have not heard of MCP?

818
00:28:57,060 --> 00:28:57,893
Okay, a few.

819
00:28:57,893 --> 00:29:01,230
So most folks are familiar
with it, some not so familiar.

820
00:29:01,230 --> 00:29:04,020
So we'll do a little bit
of introduction about MCP

821
00:29:04,020 --> 00:29:06,930
and how this relates to DocumentDB.

822
00:29:06,930 --> 00:29:09,600
But to put it into to context

823
00:29:09,600 --> 00:29:11,850
like with RAG and the TSQL plugin.

824
00:29:11,850 --> 00:29:14,580
Alright, so maybe you know
how to access the data.

825
00:29:14,580 --> 00:29:19,290
You're familiar with querying
data through Mongo APIs,

826
00:29:19,290 --> 00:29:23,430
but you've got data you, you
really need to dive deep into.

827
00:29:23,430 --> 00:29:25,410
So it's like, you know, where do I start?

828
00:29:25,410 --> 00:29:27,390
Alright, I could start
writing a bunch of queries

829
00:29:27,390 --> 00:29:29,640
and things like that,
but I'm gonna take a look

830
00:29:29,640 --> 00:29:34,230
at MCP servers and how
that might help you.

831
00:29:34,230 --> 00:29:35,816
So, sorry about that.

832
00:29:35,816 --> 00:29:38,070
So just a little bit about MCP model

833
00:29:38,070 --> 00:29:40,380
context protocol servers.

834
00:29:40,380 --> 00:29:43,080
So if you're not familiar
with it, good way to think

835
00:29:43,080 --> 00:29:47,820
of MCP is, it's a way to
provide seamless integration

836
00:29:47,820 --> 00:29:51,750
between your agentic AI
components and applications

837
00:29:51,750 --> 00:29:54,630
with existing tools or systems.

838
00:29:54,630 --> 00:29:57,600
At even simpler, it's
just a standardized way

839
00:29:57,600 --> 00:30:00,603
to access capabilities
that you already have.

840
00:30:01,500 --> 00:30:03,840
So, it is a client server architecture.

841
00:30:03,840 --> 00:30:05,580
And like you see in the screen here,

842
00:30:05,580 --> 00:30:06,720
there's a couple components.

843
00:30:06,720 --> 00:30:09,060
There's four main things to be aware of.

844
00:30:09,060 --> 00:30:11,580
So, there's a host, alright,

845
00:30:11,580 --> 00:30:14,520
the host is an application
that coordinates

846
00:30:14,520 --> 00:30:17,460
and manages multiple MCP clients.

847
00:30:17,460 --> 00:30:20,610
Host could be an agentic AI application

848
00:30:20,610 --> 00:30:21,570
that you've developed.

849
00:30:21,570 --> 00:30:24,360
A host may be Visual Studio Code

850
00:30:24,360 --> 00:30:25,860
like with Klein running in it,

851
00:30:25,860 --> 00:30:27,660
which is what you'll see
in the demo, alright?

852
00:30:27,660 --> 00:30:30,540
But the point is there's
a lot of different hosts,

853
00:30:30,540 --> 00:30:33,120
but they host MCP clients.

854
00:30:33,120 --> 00:30:36,480
What MCP clients do is it maintains

855
00:30:36,480 --> 00:30:39,840
a one-to-one relationship
with an MCP server

856
00:30:39,840 --> 00:30:42,690
or a one-to-one connection
with an MCP server.

857
00:30:42,690 --> 00:30:45,990
So your host will understand
that, hey, I need to reach out

858
00:30:45,990 --> 00:30:48,810
to this server for it to take some action.

859
00:30:48,810 --> 00:30:51,540
That'll create a client,
establish that connection,

860
00:30:51,540 --> 00:30:53,010
and now the host is gonna keep track

861
00:30:53,010 --> 00:30:54,600
of all of the different clients

862
00:30:54,600 --> 00:30:56,613
and which servers they're connected to.

863
00:30:57,840 --> 00:31:00,510
So the server is a lightweight program

864
00:31:00,510 --> 00:31:04,050
that exposes some capabilities, right?

865
00:31:04,050 --> 00:31:07,080
Typically not a lot, but it
exposes some capabilities

866
00:31:07,080 --> 00:31:09,030
through a standard interface

867
00:31:09,030 --> 00:31:11,670
through JSON RPC interface.

868
00:31:11,670 --> 00:31:12,810
And then over on the far right

869
00:31:12,810 --> 00:31:15,450
are your existing data sources.

870
00:31:15,450 --> 00:31:17,580
They could be maybe local data,

871
00:31:17,580 --> 00:31:21,150
local sources like databases or files.

872
00:31:21,150 --> 00:31:22,980
It could be remote data sources,

873
00:31:22,980 --> 00:31:26,430
maybe it's a web service or another API.

874
00:31:26,430 --> 00:31:30,060
But the point is MCP
servers can access all kinds

875
00:31:30,060 --> 00:31:33,573
of sources, whether locally or remotely.

876
00:31:34,880 --> 00:31:39,880
So I wanna focus on MCP servers
here just a little bit more.

877
00:31:41,130 --> 00:31:45,960
So MCP servers have three
different kinds of features,

878
00:31:45,960 --> 00:31:49,470
resources, prompts and tools.

879
00:31:49,470 --> 00:31:53,730
So resources, they're
read-only persistent data

880
00:31:53,730 --> 00:31:56,400
that the server can expose to clients.

881
00:31:56,400 --> 00:32:00,060
So think of it maybe as
some files that you have,

882
00:32:00,060 --> 00:32:01,470
some static files.

883
00:32:01,470 --> 00:32:03,990
You wanna be able to expose
it through an MCP server.

884
00:32:03,990 --> 00:32:04,823
You can do that.

885
00:32:04,823 --> 00:32:07,890
You can define a resource
in your MCP server

886
00:32:07,890 --> 00:32:10,380
and now the clients that
are running in the host,

887
00:32:10,380 --> 00:32:13,140
alright, through maybe a
natural language interface,

888
00:32:13,140 --> 00:32:15,540
you can ask it, Hey,
who's the engineering lead

889
00:32:15,540 --> 00:32:17,310
for the mobile app team?

890
00:32:17,310 --> 00:32:20,010
Alright, you have all
of the HR information

891
00:32:20,010 --> 00:32:22,860
in these static files, you've exposed it,

892
00:32:22,860 --> 00:32:25,350
this resource through an MCP server.

893
00:32:25,350 --> 00:32:27,660
Now you can have that kind of interaction

894
00:32:27,660 --> 00:32:29,970
with these static resources.

895
00:32:29,970 --> 00:32:32,820
Resources don't perform
any kind of actions, right?

896
00:32:32,820 --> 00:32:34,380
They're not gonna take any action

897
00:32:34,380 --> 00:32:37,740
on any other resources
or external systems.

898
00:32:37,740 --> 00:32:39,243
They're simply read only.

899
00:32:40,500 --> 00:32:43,860
Second feature of MCP servers are prompts.

900
00:32:43,860 --> 00:32:47,100
So as you see here, they're
predefined instructions,

901
00:32:47,100 --> 00:32:50,250
they're templates that the server provides

902
00:32:50,250 --> 00:32:55,140
to the clients to understand
what tools do you provide?

903
00:32:55,140 --> 00:32:57,300
What capabilities do you provide?

904
00:32:57,300 --> 00:32:58,920
What does the interface look like?

905
00:32:58,920 --> 00:33:00,930
What information do I need to give to you

906
00:33:00,930 --> 00:33:01,830
to take this action?

907
00:33:01,830 --> 00:33:04,023
What information do you give back to me?

908
00:33:05,310 --> 00:33:06,900
And then the tools, these are the things

909
00:33:06,900 --> 00:33:08,610
that will actually do the work.

910
00:33:08,610 --> 00:33:10,950
So they will take some sort of action.

911
00:33:10,950 --> 00:33:14,460
They could read, they
could write, alright,

912
00:33:14,460 --> 00:33:16,530
but again, they're defined by a schema.

913
00:33:16,530 --> 00:33:19,590
So it's well-defined what this tool does,

914
00:33:19,590 --> 00:33:21,480
the interface to the tool.

915
00:33:21,480 --> 00:33:24,840
And really important point on the bottom.

916
00:33:24,840 --> 00:33:29,700
By default execution requires
explicit user approval, right?

917
00:33:29,700 --> 00:33:33,570
Because most likely you don't
want your agentic AI tool

918
00:33:33,570 --> 00:33:36,150
just running off and
doing all kinds of things,

919
00:33:36,150 --> 00:33:40,230
making changes, dropping
tables, changing data, right?

920
00:33:40,230 --> 00:33:42,570
Now, as you'll see in the
demo, you can set things

921
00:33:42,570 --> 00:33:44,100
to auto approve and things like that,

922
00:33:44,100 --> 00:33:47,520
but by default with MCP servers,

923
00:33:47,520 --> 00:33:50,103
you do need to provide explicit approval.

924
00:33:52,470 --> 00:33:55,320
Okay, so, and now let's just focus on

925
00:33:55,320 --> 00:33:57,327
maybe a particular MCP server.

926
00:33:57,327 --> 00:34:00,150
And this is actually what
you'll see in the demo.

927
00:34:00,150 --> 00:34:02,910
It's a maybe a condensed view

928
00:34:02,910 --> 00:34:06,570
of the Amazon DocumentDB MCP server.

929
00:34:06,570 --> 00:34:09,690
And we'll have a QR code
with a link to it at the end.

930
00:34:09,690 --> 00:34:12,120
But as you see here, we have a client

931
00:34:12,120 --> 00:34:13,473
that's running in a host.

932
00:34:14,550 --> 00:34:17,430
That client connects to the MCP server,

933
00:34:17,430 --> 00:34:19,590
the Amazon DocumentDB, MCP server,

934
00:34:19,590 --> 00:34:22,860
which has all of the different
tools that it exposes

935
00:34:22,860 --> 00:34:25,830
and the logic needed to
implement those tools.

936
00:34:25,830 --> 00:34:29,190
So for example, there's a
tool to allow you to connect

937
00:34:29,190 --> 00:34:31,620
to an Amazon DocumentDB cluster.

938
00:34:31,620 --> 00:34:33,930
There's a tool that will allow you to list

939
00:34:33,930 --> 00:34:35,910
all of the databases in the cluster,

940
00:34:35,910 --> 00:34:38,460
list all of the collections
in the databases.

941
00:34:38,460 --> 00:34:40,230
There's a tool that will allow you

942
00:34:40,230 --> 00:34:42,870
to query the data in the database.

943
00:34:42,870 --> 00:34:45,780
Again, the idea is makes it easier for you

944
00:34:45,780 --> 00:34:48,840
to maybe start exploring a
new data set or a database

945
00:34:48,840 --> 00:34:50,730
that maybe you don't
know a whole lot about,

946
00:34:50,730 --> 00:34:52,743
what's in there, how can I use it?

947
00:34:54,030 --> 00:34:58,470
So with that, let's take
a look at this demo here.

948
00:34:58,470 --> 00:35:01,890
So in this demo I'm using
Klein in Visual Studio Code.

949
00:35:01,890 --> 00:35:04,590
So that's my host and I'm connecting

950
00:35:04,590 --> 00:35:09,270
to the AWS DocumentDB MCP server.

951
00:35:09,270 --> 00:35:11,340
And if you see at the very bottom there,

952
00:35:11,340 --> 00:35:12,420
I've got it configured.

953
00:35:12,420 --> 00:35:17,420
I'm using the Claude, Anthropic
Claude 3.7 Sonnet model.

954
00:35:20,700 --> 00:35:23,460
So, oh, I forgot to press play.

955
00:35:23,460 --> 00:35:25,740
Okay, so we're gonna take a look

956
00:35:25,740 --> 00:35:28,560
at the MCP server itself, right?

957
00:35:28,560 --> 00:35:31,820
There's the Amazon DocumentDB MCP server.

958
00:35:31,820 --> 00:35:35,520
In this case it exposes
16 different tools.

959
00:35:35,520 --> 00:35:36,930
I'm not gonna go through all of them,

960
00:35:36,930 --> 00:35:39,660
but for example, you see
one here, a connect tool

961
00:35:39,660 --> 00:35:43,020
to allow you to connect to
an Amazon DocumentDB cluster.

962
00:35:43,020 --> 00:35:44,730
And this has already set to auto approve

963
00:35:44,730 --> 00:35:47,640
'cause I've been using it
and it's okay to connect

964
00:35:47,640 --> 00:35:50,550
to a cluster, it's not
destructive in any way.

965
00:35:50,550 --> 00:35:53,433
But again, they will default
that those are unchecked.

966
00:35:55,470 --> 00:35:58,290
And then you can see a description
of what that tool does.

967
00:35:58,290 --> 00:36:02,280
Here's another tool, a disconnect
tool that will go ahead,

968
00:36:02,280 --> 00:36:03,450
disconnect from the database.

969
00:36:03,450 --> 00:36:04,770
There's a find tool.

970
00:36:04,770 --> 00:36:06,360
This one I don't have auto approved.

971
00:36:06,360 --> 00:36:07,980
Maybe, you know, I'm not comfortable

972
00:36:07,980 --> 00:36:11,580
with letting it run queries
before I take a look at them.

973
00:36:11,580 --> 00:36:14,220
So again, the point is, through your host,

974
00:36:14,220 --> 00:36:18,003
you'll have this option to
approve, auto approve or not.

975
00:36:18,840 --> 00:36:21,300
So now your role, you're a developer

976
00:36:21,300 --> 00:36:26,300
in an e-commerce company and
you're tasked with trying

977
00:36:27,810 --> 00:36:30,960
to analyze some sales trends
from past holiday seasons.

978
00:36:30,960 --> 00:36:34,230
So your first step is, well,
what's in this database, right?

979
00:36:34,230 --> 00:36:36,760
So you can ask through Klein

980
00:36:37,830 --> 00:36:39,750
what collections are in this database.

981
00:36:39,750 --> 00:36:42,870
So through the MCP server,
you can see it's gone out,

982
00:36:42,870 --> 00:36:45,600
taking a look at it, it's
like, okay, I've got addresses,

983
00:36:45,600 --> 00:36:48,360
customers, orders, products, reviews.

984
00:36:48,360 --> 00:36:50,040
This looks like it has the information

985
00:36:50,040 --> 00:36:53,250
I would need to find what I want to.

986
00:36:53,250 --> 00:36:55,710
So I'll just ask it, okay, well,

987
00:36:55,710 --> 00:36:58,860
what are the most popular
products over the past few years

988
00:36:58,860 --> 00:37:00,243
during the holiday season.

989
00:37:01,800 --> 00:37:03,750
So it goes off, starts working.

990
00:37:03,750 --> 00:37:06,270
Now we're running a new tool
that we haven't run before.

991
00:37:06,270 --> 00:37:09,480
So server exposes and analyze schema tool

992
00:37:09,480 --> 00:37:12,450
to take a look at the
documents, what's in there.

993
00:37:12,450 --> 00:37:15,120
I go ahead and auto approve
it because I'm, okay,

994
00:37:15,120 --> 00:37:17,130
we'll let it just do this every time.

995
00:37:17,130 --> 00:37:18,570
So you can see it's going through,

996
00:37:18,570 --> 00:37:21,840
it's checking the orders collection,

997
00:37:21,840 --> 00:37:25,410
the products collection,
customer's collection,

998
00:37:25,410 --> 00:37:27,150
taking a look at what's in there.

999
00:37:27,150 --> 00:37:30,183
And after it goes off and
does this a little bit,

1000
00:37:31,320 --> 00:37:33,690
it'll give us some information.

1001
00:37:33,690 --> 00:37:36,090
Now, here we go.

1002
00:37:36,090 --> 00:37:38,970
Another new tool, an
aggregate tool, right?

1003
00:37:38,970 --> 00:37:41,550
So MCP servers smart enough to know

1004
00:37:41,550 --> 00:37:44,790
I've gotta now do some
aggregations to figure out,

1005
00:37:44,790 --> 00:37:47,040
you know, what are the top products.

1006
00:37:47,040 --> 00:37:49,381
So I'm gonna give it approval to do that.

1007
00:37:49,381 --> 00:37:51,120
And then we can see here
what it's thinking, alright?

1008
00:37:51,120 --> 00:37:53,070
I'm gonna group the orders by state,

1009
00:37:53,070 --> 00:37:55,720
then I'm gonna calculate
the total revenue per state,

1010
00:37:56,580 --> 00:37:59,400
go ahead and sort those and
again, get the top products

1011
00:37:59,400 --> 00:38:01,920
and get the details about those products.

1012
00:38:01,920 --> 00:38:03,480
So I go ahead and approve that.

1013
00:38:03,480 --> 00:38:05,340
It'll continue through the process.

1014
00:38:05,340 --> 00:38:08,040
So you can see it's going
by pretty quick, right?

1015
00:38:08,040 --> 00:38:10,350
But you can see what it's doing,
the different aggregations

1016
00:38:10,350 --> 00:38:13,380
and some of the information
that's coming back.

1017
00:38:13,380 --> 00:38:16,710
So now it's got some of the top products.

1018
00:38:16,710 --> 00:38:18,000
So it's trying to do a find

1019
00:38:18,000 --> 00:38:19,830
to get the information
about these products,

1020
00:38:19,830 --> 00:38:22,170
but again, need to approve it

1021
00:38:22,170 --> 00:38:24,900
'cause of the default is
won't run without approval.

1022
00:38:24,900 --> 00:38:26,580
So I'm gonna set it to auto approve

1023
00:38:26,580 --> 00:38:29,013
so the next time it'll just carry on.

1024
00:38:29,880 --> 00:38:33,303
So I was gonna go ahead,
execute that find.

1025
00:38:36,690 --> 00:38:39,930
And we see now that it's processing a lot.

1026
00:38:39,930 --> 00:38:42,720
And here's a report.

1027
00:38:42,720 --> 00:38:44,280
So basically it took all the information

1028
00:38:44,280 --> 00:38:47,760
it got from DocumentDB,
ran it through the LLM

1029
00:38:47,760 --> 00:38:49,950
to create this report.

1030
00:38:49,950 --> 00:38:52,920
So we can see the top
five states by revenue,

1031
00:38:52,920 --> 00:38:55,170
the most popular product
in each of these states

1032
00:38:55,170 --> 00:38:56,820
based on quantities.

1033
00:38:56,820 --> 00:38:59,370
We see Mississippi
likes the immediate tub,

1034
00:38:59,370 --> 00:39:02,550
Maine likes the puny sandpaper and so on.

1035
00:39:02,550 --> 00:39:06,510
So, we've got all the
information that we need there.

1036
00:39:06,510 --> 00:39:10,320
Now, while you were
doing this, you realize,

1037
00:39:10,320 --> 00:39:12,630
okay, you're gonna need
to do this every year.

1038
00:39:12,630 --> 00:39:15,480
So if you're like me, you'll
forget how you did this.

1039
00:39:15,480 --> 00:39:18,750
So I can just say, hey, gimme
some Python code to do this.

1040
00:39:18,750 --> 00:39:22,077
So you can ask, ask client to do that.

1041
00:39:22,077 --> 00:39:24,780
You can see it's creating the Python code

1042
00:39:24,780 --> 00:39:27,183
needed to generate this report.

1043
00:39:30,930 --> 00:39:32,820
It's generating quite a bit of code,

1044
00:39:32,820 --> 00:39:36,030
but you can see when you
look at it, all of the code

1045
00:39:36,030 --> 00:39:38,520
to handle the different steps, alright?

1046
00:39:38,520 --> 00:39:41,640
Code to find the states
with the top revenue

1047
00:39:41,640 --> 00:39:44,520
and then to find, okay, based on state,

1048
00:39:44,520 --> 00:39:46,377
what's the popular products
in that state, right?

1049
00:39:46,377 --> 00:39:48,120
And you can see the aggregations

1050
00:39:48,120 --> 00:39:50,340
and queries there for our product.

1051
00:39:50,340 --> 00:39:51,840
Gimme the product details, right?

1052
00:39:51,840 --> 00:39:54,480
So you see all of the
queries and aggregations

1053
00:39:54,480 --> 00:39:56,970
that it created to create this report.

1054
00:39:56,970 --> 00:39:58,680
It's now available in this code.

1055
00:39:58,680 --> 00:40:01,140
Of course you'll review
the code before you run it,

1056
00:40:01,140 --> 00:40:04,083
but you've got a really
good solid starting point.

1057
00:40:05,730 --> 00:40:07,470
Now, while you were doing this, alright?

1058
00:40:07,470 --> 00:40:09,780
Your boss came along and said, Hey, okay,

1059
00:40:09,780 --> 00:40:11,130
I know you're working with us,

1060
00:40:11,130 --> 00:40:14,790
can you tell us what's gonna
be hot this holiday season?

1061
00:40:14,790 --> 00:40:15,623
Alright?

1062
00:40:15,623 --> 00:40:16,860
So again, through natural language

1063
00:40:16,860 --> 00:40:20,730
you can just ask it, okay,
based on past products,

1064
00:40:20,730 --> 00:40:23,100
past performance, past sales,

1065
00:40:23,100 --> 00:40:27,930
what is going to be popular
this holiday season, right?

1066
00:40:27,930 --> 00:40:30,120
So you see, you know, it's
trying a lot of different things.

1067
00:40:30,120 --> 00:40:32,730
Sometimes you'll see things
maybe that don't work,

1068
00:40:32,730 --> 00:40:35,370
so it gets an error so it'll
go try something else, right?

1069
00:40:35,370 --> 00:40:38,310
But the point is, it'll get to the point

1070
00:40:38,310 --> 00:40:40,350
where it'll do the analysis

1071
00:40:40,350 --> 00:40:44,010
and now it's creating a report
of, based on the past couple

1072
00:40:44,010 --> 00:40:46,590
of years and sales,
this is what's expected

1073
00:40:46,590 --> 00:40:49,500
to be popular this holiday season.

1074
00:40:49,500 --> 00:40:54,110
So you can see relatively
easily through MCP servers

1075
00:40:55,470 --> 00:40:57,450
agentic AI type of solutions.

1076
00:40:57,450 --> 00:41:01,230
You can quickly go in, explore
the data, generate code.

1077
00:41:01,230 --> 00:41:03,783
Give you good starting
point for your applications.

1078
00:41:07,050 --> 00:41:09,990
Okay, so with that, let's talk about

1079
00:41:09,990 --> 00:41:13,950
some best practices in the
time that we've got left here.

1080
00:41:13,950 --> 00:41:17,460
So this is probably the first,
well, this is the first time

1081
00:41:17,460 --> 00:41:19,380
you're seeing these in
these presentations.

1082
00:41:19,380 --> 00:41:22,500
But if you're familiar
with vector embeddings

1083
00:41:22,500 --> 00:41:25,590
on Amazon DocumentDB, we
support two different types

1084
00:41:25,590 --> 00:41:26,730
of vector indexes.

1085
00:41:26,730 --> 00:41:28,560
IVFFlat and HNSW.

1086
00:41:30,026 --> 00:41:32,250
Alright, so you've got two to choose from.

1087
00:41:32,250 --> 00:41:33,990
Which one do I choose, alright?

1088
00:41:33,990 --> 00:41:36,333
So, there's some trade offs between them,

1089
00:41:37,230 --> 00:41:40,077
but at a high level, you know, IVFFlat,

1090
00:41:40,077 --> 00:41:45,077
the indexes are smaller,
they use less memory,

1091
00:41:45,480 --> 00:41:47,700
but they require pre-populated data,

1092
00:41:47,700 --> 00:41:49,470
so you have to already
have your data set loaded

1093
00:41:49,470 --> 00:41:51,393
before you can create your indexes.

1094
00:41:52,920 --> 00:41:54,960
And if you do have workload where

1095
00:41:54,960 --> 00:41:56,670
that information is being updated

1096
00:41:56,670 --> 00:41:57,960
or you're adding more information,

1097
00:41:57,960 --> 00:42:00,303
you will need to rebuild those indexes.

1098
00:42:01,320 --> 00:42:04,590
HNSW, on the other hand,
slower index build times,

1099
00:42:04,590 --> 00:42:08,520
they use more memory, but
there's better accuracy,

1100
00:42:08,520 --> 00:42:10,350
lower latency and you don't need

1101
00:42:10,350 --> 00:42:13,350
to rebuild those as your data changes.

1102
00:42:13,350 --> 00:42:15,660
So again, which one do you choose?

1103
00:42:15,660 --> 00:42:17,490
Well, it's gonna depend
on your requirements,

1104
00:42:17,490 --> 00:42:21,993
but typically HNSW is probably
a good place to start.

1105
00:42:24,810 --> 00:42:28,230
And to sum it up, IVFFlat, if
you need the fastest indexing,

1106
00:42:28,230 --> 00:42:30,210
IVFFlat's a good option for that.

1107
00:42:30,210 --> 00:42:32,760
If you want something easy
to manage better performance,

1108
00:42:32,760 --> 00:42:35,073
better recall, HNSW.

1109
00:42:36,930 --> 00:42:39,780
Just a little bit to give some information

1110
00:42:39,780 --> 00:42:43,680
about index build times
or index creation times.

1111
00:42:43,680 --> 00:42:46,200
There is some pretty
significant differences, right?

1112
00:42:46,200 --> 00:42:48,840
So if you're gonna be building indexes,

1113
00:42:48,840 --> 00:42:50,880
creating indexes a lot, right?

1114
00:42:50,880 --> 00:42:52,080
This could factor into that.

1115
00:42:52,080 --> 00:42:57,080
But this particular test
was run on an 8XL instance.

1116
00:42:57,420 --> 00:43:02,250
And what you see here is the
number of embeddings, right?

1117
00:43:02,250 --> 00:43:05,400
Remember Cody showed you
the human readable text

1118
00:43:05,400 --> 00:43:07,980
and then the arrays and
numbers, those embeddings.

1119
00:43:07,980 --> 00:43:09,570
And so we've got one, two, three,

1120
00:43:09,570 --> 00:43:11,640
four, five, six embeddings.

1121
00:43:11,640 --> 00:43:15,840
The green bar is IVFFlat,
the other bar is HNSW.

1122
00:43:15,840 --> 00:43:19,470
So you see, like we said on
the other slide, IVFFlat,

1123
00:43:19,470 --> 00:43:23,220
those build times are much lower
in terms of seconds, right,

1124
00:43:23,220 --> 00:43:24,660
compared to the HNSW.

1125
00:43:25,721 --> 00:43:28,590
So, the scale here is in seconds.

1126
00:43:28,590 --> 00:43:32,100
So that's good representation visual

1127
00:43:32,100 --> 00:43:34,080
for the difference in build times

1128
00:43:34,080 --> 00:43:37,023
between the two index types.

1129
00:43:38,730 --> 00:43:42,750
Now HNSW, remember IVFFlat, you
can only build those indexes

1130
00:43:42,750 --> 00:43:44,490
on pre-existing data.

1131
00:43:44,490 --> 00:43:45,540
So that's your only option.

1132
00:43:45,540 --> 00:43:49,320
But those index build
times are pretty quick.

1133
00:43:49,320 --> 00:43:52,110
HNSW, you do have options.

1134
00:43:52,110 --> 00:43:54,360
You can create the index first

1135
00:43:54,360 --> 00:43:56,730
and it will be built as you load the data

1136
00:43:56,730 --> 00:43:58,590
or you can also create it after.

1137
00:43:58,590 --> 00:44:01,950
But what you see here,
that low purple line

1138
00:44:01,950 --> 00:44:04,230
is if you create the index first,

1139
00:44:04,230 --> 00:44:06,300
those indexes are gonna
build much faster, right?

1140
00:44:06,300 --> 00:44:09,300
Because you're adding the data,
you're updating the indexes.

1141
00:44:09,300 --> 00:44:10,650
If you're building it after the fact,

1142
00:44:10,650 --> 00:44:12,090
it's gonna take longer.

1143
00:44:12,090 --> 00:44:14,820
And honestly it's the
same as recommendations

1144
00:44:14,820 --> 00:44:17,190
with any index you create on DocumentDB.

1145
00:44:17,190 --> 00:44:19,800
If you can, create it
before you load your data

1146
00:44:19,800 --> 00:44:22,830
because you're gonna be able
to update that much faster

1147
00:44:22,830 --> 00:44:25,773
than you can if you're trying
to build it after the fact.

1148
00:44:28,200 --> 00:44:33,200
Okay, so a couple decision
points IVFFlat versus HNSW.

1149
00:44:34,380 --> 00:44:37,050
I need exact nearest neighbor search

1150
00:44:37,050 --> 00:44:38,580
or a hundred percent recall,

1151
00:44:38,580 --> 00:44:40,893
meaning I need to find the exact match.

1152
00:44:41,760 --> 00:44:43,890
Don't use vector indexes, right?

1153
00:44:43,890 --> 00:44:48,240
Just use a normal index for
that 'cause you're basically

1154
00:44:48,240 --> 00:44:51,270
just doing a point look
up in a quality match.

1155
00:44:51,270 --> 00:44:54,153
If you want the fastest indexing, IVFFlat.

1156
00:44:55,050 --> 00:44:58,470
Easiest management,
frequent updates, HNSW.

1157
00:44:58,470 --> 00:45:01,800
Higher performance, recall rates, HNSW.

1158
00:45:01,800 --> 00:45:04,920
So yeah, this is a good
slide to take a picture of

1159
00:45:04,920 --> 00:45:07,410
if you want, or like Cody said,

1160
00:45:07,410 --> 00:45:09,723
pause the video when it's out on YouTube.

1161
00:45:12,690 --> 00:45:15,690
Vector embeddings take up
space in your documents, right?

1162
00:45:15,690 --> 00:45:17,160
I mean this is great.

1163
00:45:17,160 --> 00:45:18,450
We can add these vector embeddings,

1164
00:45:18,450 --> 00:45:22,740
but there is a finite
amount of, finite, sorry,

1165
00:45:22,740 --> 00:45:25,020
there is a limit to the size of documents

1166
00:45:25,020 --> 00:45:26,010
in DocumentDB, right?

1167
00:45:26,010 --> 00:45:28,500
It is 16 megabytes.

1168
00:45:28,500 --> 00:45:31,307
So you know, if you've
got a lot of embeddings

1169
00:45:31,307 --> 00:45:33,090
and a lot of metadata, you know,

1170
00:45:33,090 --> 00:45:35,070
hopefully you're still
not near the 16 megabytes.

1171
00:45:35,070 --> 00:45:38,040
But the point is there is a limit,

1172
00:45:38,040 --> 00:45:42,030
so you do wanna keep in
mind the impact on the size

1173
00:45:42,030 --> 00:45:44,700
of your documents for
these vector embeddings.

1174
00:45:44,700 --> 00:45:46,803
So pretty, pretty simple formula.

1175
00:45:48,660 --> 00:45:50,163
You see on the top right here,

1176
00:45:51,210 --> 00:45:55,350
the key length plus one
plus dimensions times 13.

1177
00:45:55,350 --> 00:45:58,800
So the key length is
in this case embedding.

1178
00:45:58,800 --> 00:46:02,700
So key length plus one
plus dimensions times 13

1179
00:46:02,700 --> 00:46:07,700
in what you've got with
the 13 is four bytes

1180
00:46:10,378 --> 00:46:15,270
for an in 32 value, eight
bytes for the element length.

1181
00:46:15,270 --> 00:46:20,010
So for each item in that array,
we store it in eight bytes.

1182
00:46:20,010 --> 00:46:21,660
And then there's a one byte terminator.

1183
00:46:21,660 --> 00:46:25,080
Sorry, there's this one four byte value

1184
00:46:25,080 --> 00:46:26,310
sort of at the beginning.

1185
00:46:26,310 --> 00:46:29,550
And then each element, eight
bytes, one byte terminator.

1186
00:46:29,550 --> 00:46:33,390
All that together gives
you the size of that.

1187
00:46:33,390 --> 00:46:35,970
Or if you just look at
the chart, you can see

1188
00:46:35,970 --> 00:46:39,710
how a hundred dimensions, it's about 1.3k.

1189
00:46:39,710 --> 00:46:43,890
A thousand, it's about 10 times
as much as you can imagine.

1190
00:46:43,890 --> 00:46:46,020
So again, just something to keep in mind.

1191
00:46:46,020 --> 00:46:48,920
Yeah, it's great to
have a lot of embeddings

1192
00:46:48,920 --> 00:46:51,300
in your vectors, get better matches,

1193
00:46:51,300 --> 00:46:53,150
but they're gonna take up more space.

1194
00:46:55,770 --> 00:46:58,440
So there's a lot of things
to think about, right?

1195
00:46:58,440 --> 00:47:01,020
Which vector index type to use,

1196
00:47:01,020 --> 00:47:04,530
all of the different settings
on those, how many embeddings,

1197
00:47:04,530 --> 00:47:06,960
number of connections and so on.

1198
00:47:06,960 --> 00:47:11,400
But a better way to think
about this is take a step back,

1199
00:47:11,400 --> 00:47:13,260
you know, what are your
requirements, alright?

1200
00:47:13,260 --> 00:47:16,650
How many queries per second
do you need to support?

1201
00:47:16,650 --> 00:47:18,840
Alright, what's your query latency?

1202
00:47:18,840 --> 00:47:22,410
Does this thing need to run in a second,

1203
00:47:22,410 --> 00:47:25,530
less than a second, 30 seconds?

1204
00:47:25,530 --> 00:47:27,930
Alright, what's your recall rate?

1205
00:47:27,930 --> 00:47:30,060
Does it always have to be an exact match?

1206
00:47:30,060 --> 00:47:32,943
Again, vector index is
probably not way to go.

1207
00:47:34,136 --> 00:47:36,360
You know, do you need
maybe 90% recall rate

1208
00:47:36,360 --> 00:47:38,670
or is 50% good enough?

1209
00:47:38,670 --> 00:47:41,010
Again, depending on the answers to those,

1210
00:47:41,010 --> 00:47:45,278
it's going to influence
which vector index you use,

1211
00:47:45,278 --> 00:47:47,700
IVFFlat or HNSW.

1212
00:47:47,700 --> 00:47:49,860
Ingestion time, right?

1213
00:47:49,860 --> 00:47:51,870
Again, IVFFlat, the index builds

1214
00:47:51,870 --> 00:47:53,940
are really fast on existing data.

1215
00:47:53,940 --> 00:47:58,650
So if ingestion time, low
ingestion time is a priority,

1216
00:47:58,650 --> 00:48:01,009
maybe you wanna go with IVFFlat

1217
00:48:01,009 --> 00:48:02,880
and index build time as well.

1218
00:48:02,880 --> 00:48:06,690
So these are the things better to think,

1219
00:48:06,690 --> 00:48:08,550
kind of flip it around, think about

1220
00:48:08,550 --> 00:48:10,290
what your requirements are

1221
00:48:10,290 --> 00:48:13,770
and work into what your index
type and your settings are.

1222
00:48:13,770 --> 00:48:15,003
Work into it that way.

1223
00:48:18,060 --> 00:48:21,150
Alright, so just a
couple more slides here.

1224
00:48:21,150 --> 00:48:26,130
Some tests on query performance, right,

1225
00:48:26,130 --> 00:48:28,020
on the different types of indexes.

1226
00:48:28,020 --> 00:48:33,020
So this is IVFFlat indexes,
IVFFlat index, excuse me.

1227
00:48:33,300 --> 00:48:36,120
What we're showing here
is along the bottom,

1228
00:48:36,120 --> 00:48:41,120
the 20, 40, 80, 400, 600,
are the number of probes,

1229
00:48:43,695 --> 00:48:45,900
are the number of lists to search.

1230
00:48:45,900 --> 00:48:50,133
So an analogy to think
of maybe with IVFFlat,

1231
00:48:51,090 --> 00:48:54,330
you've got people live in
apartment buildings, right?

1232
00:48:54,330 --> 00:48:56,850
And there's a finite number
of apartment buildings,

1233
00:48:56,850 --> 00:49:00,180
let's say 20 apartment
buildings, more people,

1234
00:49:00,180 --> 00:49:01,320
there's just gonna be more people

1235
00:49:01,320 --> 00:49:02,700
in each apartment building.

1236
00:49:02,700 --> 00:49:05,910
So that apartment building
is like that list, right?

1237
00:49:05,910 --> 00:49:10,170
So you've got 20 groupings of embeddings,

1238
00:49:10,170 --> 00:49:13,140
40 groupings of embeddings, 80 and so on.

1239
00:49:13,140 --> 00:49:14,850
Alright, so that's
across the bottom there.

1240
00:49:14,850 --> 00:49:18,093
So what you see now on
the queries per second,

1241
00:49:18,960 --> 00:49:23,013
certainly the fewer
groupings, the fewer probes,

1242
00:49:24,870 --> 00:49:27,990
the faster those queries are
because there's less to search,

1243
00:49:27,990 --> 00:49:29,580
but our recall is lower.

1244
00:49:29,580 --> 00:49:31,110
It's about 85%.

1245
00:49:31,110 --> 00:49:33,030
As you increase the number of probes

1246
00:49:33,030 --> 00:49:36,450
or the number of of groups,
the queries per second go down,

1247
00:49:36,450 --> 00:49:37,950
but the recall goes up.

1248
00:49:37,950 --> 00:49:39,750
But as you see once, in this case,

1249
00:49:39,750 --> 00:49:42,120
once you get to about 400,

1250
00:49:42,120 --> 00:49:44,310
it's kind of the point
of diminishing returns.

1251
00:49:44,310 --> 00:49:47,070
Yes, you can go to 600, get
a little bit better recall,

1252
00:49:47,070 --> 00:49:50,220
but you're getting fewer
queries per second.

1253
00:49:50,220 --> 00:49:53,070
So again, just keep in mind,
you don't need to always go

1254
00:49:53,070 --> 00:49:56,790
to the maximum and that's gonna
vary based on your data set,

1255
00:49:56,790 --> 00:49:58,110
based on your embeddings.

1256
00:49:58,110 --> 00:49:59,820
But just realize, you
know, there's a point

1257
00:49:59,820 --> 00:50:02,570
where you probably don't
really need to go any further.

1258
00:50:04,350 --> 00:50:07,980
Same thing with HNSW,
different terms in this.

1259
00:50:07,980 --> 00:50:11,673
In HNSW, they call it EF search.

1260
00:50:12,810 --> 00:50:17,190
So this is the list size
when you're querying, right,

1261
00:50:17,190 --> 00:50:20,670
how many, how many items
are you trying to look at?

1262
00:50:20,670 --> 00:50:23,220
And then you see at the
top some information

1263
00:50:23,220 --> 00:50:24,720
about the index there.

1264
00:50:24,720 --> 00:50:28,710
But similar idea, not to go
into all the details too much,

1265
00:50:28,710 --> 00:50:33,270
but again, the smaller the
lists that you're considering,

1266
00:50:33,270 --> 00:50:34,770
the higher the queries per second

1267
00:50:34,770 --> 00:50:36,870
and you can see much
higher queries per second.

1268
00:50:36,870 --> 00:50:39,840
Now we're in the thousands of
queries per second with HNSW.

1269
00:50:39,840 --> 00:50:41,360
They're more performant.

1270
00:50:42,319 --> 00:50:46,050
But you know, the recall, you
know, maybe that's good enough

1271
00:50:46,050 --> 00:50:47,670
for your use case, maybe not.

1272
00:50:47,670 --> 00:50:49,530
Well, crank up the EF search.

1273
00:50:49,530 --> 00:50:54,240
But again, you get to a point
where you get close to one,

1274
00:50:54,240 --> 00:50:57,660
no matter how much further
you go up with the EF search,

1275
00:50:57,660 --> 00:50:58,950
it doesn't really go up much,

1276
00:50:58,950 --> 00:51:01,020
but your queries per second go down.

1277
00:51:01,020 --> 00:51:04,770
So way to sum it up, you know, just test,

1278
00:51:04,770 --> 00:51:06,810
get the right value
where it's close enough

1279
00:51:06,810 --> 00:51:09,150
to what you need and go with that.

1280
00:51:09,150 --> 00:51:12,843
Don't always just max it out
because it's not necessary.

1281
00:51:14,790 --> 00:51:17,670
Alright, so best way to
sum all of this up, right?

1282
00:51:17,670 --> 00:51:18,600
A lot of information.

1283
00:51:18,600 --> 00:51:19,433
You've seen a lot.

1284
00:51:19,433 --> 00:51:21,000
You've seen three demos.

1285
00:51:21,000 --> 00:51:23,160
Yeah, I've talked about
different types of indexes

1286
00:51:23,160 --> 00:51:24,363
and all of these things.

1287
00:51:26,220 --> 00:51:28,470
The best way to sum this
up, the first point there,

1288
00:51:28,470 --> 00:51:31,203
commit to experimentation early, right?

1289
00:51:31,203 --> 00:51:34,020
Just start using these
things if you haven't, right?

1290
00:51:34,020 --> 00:51:36,810
If you haven't already started
using this, start using it.

1291
00:51:36,810 --> 00:51:39,060
See what it can do, get familiar with it.

1292
00:51:39,060 --> 00:51:41,670
I know myself, I didn't know
anything about MCP servers

1293
00:51:41,670 --> 00:51:42,540
and when I started using it,

1294
00:51:42,540 --> 00:51:45,600
I'm like, holy cow, this
is amazing. I love it.

1295
00:51:45,600 --> 00:51:46,890
So, you know, work with it.

1296
00:51:46,890 --> 00:51:50,130
The more you use it, the
more you're going to find,

1297
00:51:50,130 --> 00:51:53,613
you know, use cases for
it ways to solve problems.

1298
00:51:55,020 --> 00:51:57,690
So, you know, start
playing with it, right?

1299
00:51:57,690 --> 00:51:58,593
Start using it.

1300
00:51:59,760 --> 00:52:01,230
To the second point there, right?

1301
00:52:01,230 --> 00:52:02,850
You may find new ways of working,

1302
00:52:02,850 --> 00:52:05,640
maybe new ways of developing,
new ways of solving problems

1303
00:52:05,640 --> 00:52:07,650
with these technologies, right?

1304
00:52:07,650 --> 00:52:11,160
But at the end of the day, what the main,

1305
00:52:11,160 --> 00:52:12,660
one of the main takeaways here

1306
00:52:12,660 --> 00:52:17,660
is this is why vector support
on DocumentDB is so important.

1307
00:52:18,150 --> 00:52:22,050
Like Cody said, alright, your
data is the differentiator.

1308
00:52:22,050 --> 00:52:24,600
We're allowing you now to
store these vector embeddings

1309
00:52:24,600 --> 00:52:27,030
with your data in DocumentDB.

1310
00:52:27,030 --> 00:52:30,150
You've got everything you
need right there to allow you

1311
00:52:30,150 --> 00:52:33,363
to do all of these things that
we've showed you here today.

1312
00:52:35,850 --> 00:52:39,000
So if you wanna take a
picture of that real quick.

1313
00:52:39,000 --> 00:52:41,460
So there's QR codes that'll take you

1314
00:52:41,460 --> 00:52:45,930
to the Amazon DocumentDB MCP server

1315
00:52:45,930 --> 00:52:48,843
and the Mongo shell TSQL plugin.

1316
00:52:50,550 --> 00:52:52,530
And I realized my mistake here,

1317
00:52:52,530 --> 00:52:56,100
I forgot to emphasize something
very important early on.

1318
00:52:56,100 --> 00:52:57,900
And what I was supposed
to emphasize early on

1319
00:52:57,900 --> 00:53:02,070
is for HNSW indexes is that
you should always create

1320
00:53:02,070 --> 00:53:04,650
your indexes before inserting your data

1321
00:53:04,650 --> 00:53:06,030
on a new namespace, right?

1322
00:53:06,030 --> 00:53:07,170
Very important.

1323
00:53:07,170 --> 00:53:09,990
So I don't know if you've
been to one of these sessions

1324
00:53:09,990 --> 00:53:12,480
like this, but if you go to the booth

1325
00:53:12,480 --> 00:53:15,450
and maybe you tell somebody that,

1326
00:53:15,450 --> 00:53:18,480
hey, always create your indexes on

1327
00:53:18,480 --> 00:53:22,200
before inserting your data
in your name spaces, alright?

1328
00:53:22,200 --> 00:53:24,420
You might be able to get a hoodie.

1329
00:53:24,420 --> 00:53:26,070
Alright.

1330
00:53:26,070 --> 00:53:28,140
So with that, thank you all very much

1331
00:53:28,140 --> 00:53:31,110
for your time, for your attention.

1332
00:53:31,110 --> 00:53:32,958
Please give us feedback, alright?

1333
00:53:32,958 --> 00:53:33,875
(audience applauds and cheers)

1334
00:53:33,875 --> 00:53:34,708
Just, you know, be candid.

1335
00:53:34,708 --> 00:53:37,920
We want candid feedback, we
want to make these better.

1336
00:53:37,920 --> 00:53:40,560
You know, we think we're telling people

1337
00:53:40,560 --> 00:53:41,393
what they want to hear.

1338
00:53:41,393 --> 00:53:42,630
Maybe it's not, right?

1339
00:53:42,630 --> 00:53:45,870
Maybe we told you stuff that
you don't find that helpful.

1340
00:53:45,870 --> 00:53:47,310
Let us know so we can adjust

1341
00:53:47,310 --> 00:53:49,260
and continue to make these things better.

1342
00:53:49,260 --> 00:53:51,267
So we do take a look at the feedback

1343
00:53:51,267 --> 00:53:53,100
and we do take it seriously.

1344
00:53:53,100 --> 00:53:55,320
So please, please provide that.

1345
00:53:55,320 --> 00:53:57,153
But again, thank you very much.

1346
00:53:59,100 --> 00:54:01,680
On behalf of Cody, enjoy
the rest of your stay here

1347
00:54:01,680 --> 00:54:04,008
at re:Invent and have a good evening.

1348
00:54:04,008 --> 00:54:07,008
(audience applauds)

