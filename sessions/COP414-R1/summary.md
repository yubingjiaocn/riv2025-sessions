# AWS re:Invent 2025 分会场总结：使用 AWS FIS 对 Lambda 函数进行混沌工程测试

## 会议概述

本次分会场重点介绍了如何使用 AWS Fault Injection Service (FIS) 对 AWS Lambda 无服务器应用进行韧性测试和混沌工程实践。演讲者 Sor Kumar 和 Haresh Nandwani（均为 AWS 高级解决方案架构师）详细讲解了 FIS 原生故障注入功能的工作原理，并通过实时编码演示了如何快速开始对 Lambda 函数进行韧性测试。

随着越来越多的企业采用 Lambda 等无服务器技术，虽然这些服务简化了基础设施管理，但也给混沌工程和韧性测试带来了新的挑战。AWS FIS 的 Lambda 原生故障操作正是为解决这一问题而推出的。会议强调，即使 Lambda 本身是一个具有韧性的区域性服务，应用程序仍然需要验证在 Lambda 函数遇到故障时，整个系统的韧性表现如何，特别是上下游组件的影响。

演讲者通过一个包含 API Gateway、Lambda 函数和 DynamoDB 的示例应用，展示了如何使用 CDK（Cloud Development Kit）代码部署 FIS 实验，配置 Lambda 扩展，并运行故障注入实验。整个过程强调了可观测性的重要性，并演示了如何使用 CloudWatch 仪表板监控实验影响。

## 详细时间线与关键要点

### 开场与背景介绍（0:00-5:30）
- **0:00** - 会议开始，演讲者询问现场观众使用 Lambda 函数的情况，大多数人举手表示正在使用
- **0:30** - 询问有多少人对 Lambda 进行韧性测试，举手人数明显减少
- **1:15** - 介绍演讲者：Sor Kumar 和 Haresh Nandwani，均为 AWS 高级解决方案架构师，专注于韧性和混沌工程领域
- **2:00** - 会议议程概览：混沌工程收益、FIS 服务介绍、Lambda 基础、FIS Lambda 操作、扩展工作原理、实时编码演示

### 混沌工程与 FIS 介绍（5:30-12:00）
- **5:30** - 询问观众对混沌工程的了解程度，部分观众表示熟悉
- **6:00** - 混沌工程定义：通过在系统中进行实验来建立信心，确保系统在出现问题时能够存活并快速恢复
- **6:45** - 混沌工程的核心价值：通过运行故障场景测试，更好地了解系统的韧性状况、关键挑战和未知问题
- **7:30** - 推荐使用 AWS FIS 的三大理由：
  - 完全无服务器和全托管服务
  - 提供丰富的故障场景库
  - 与 AWS 服务原生集成（如 EC2 自动扩展暂停）
- **9:00** - FIS 的控制和防护机制：安全杠杆（Safety Levers）功能，可在实验影响超出预期时立即停止所有实验
- **10:00** - FIS 关键术语解释：
  - 实验模板（Experiment Template）：故障场景的定义
  - 操作（Actions）：注入的故障类型
  - 目标（Targets）：故障作用的资源

### Lambda 服务与韧性需求（12:00-17:30）
- **12:00** - Lambda 简介：无服务器计算服务，无需管理服务器配置
- **12:30** - Lambda 是区域性服务，利用多个可用区提供冗余和故障隔离
- **13:00** - Lambda 设计上具有韧性，但这是否意味着不需要担心韧性问题？答案是否定的
- **13:45** - Lambda 函数通常不是孤立运行的，它们与上下游系统集成，仍需验证故障对整体系统韧性的影响
- **14:30** - FIS 最近推出的三个 Lambda 操作：
  1. **添加启动延迟（Add Start Delay）**：延迟 Lambda 函数启动，测试消费组件对延迟的影响
  2. **修改集成响应（Modify Integration Response）**：返回错误响应，测试下游系统的处理能力
  3. **调用错误（Invocation Errors）**：将 Lambda 函数标记为失败，测试调用组件的影响

### Lambda 组件与 FIS 扩展工作原理（17:30-25:00）
- **17:30** - Lambda 函数组件介绍：
  - 函数代码（业务逻辑）
  - 库代码（运行时特定代码）
  - 执行环境（安全隔离的运行时环境）
  - 运行时 API（通过 HTTP 与执行环境通信）
- **19:00** - Lambda 扩展（Extensions）：自定义代码，作为独立进程在运行时环境中运行
- **19:45** - FIS 如何提供原生故障操作？答案：通过 FIS 扩展
- **20:15** - FIS 扩展实现 API 代理模式，挂钩到 Lambda 函数执行的请求-响应生命周期
- **21:00** - FIS 扩展工作流程：
  - 配置 FIS 扩展时需要配置 S3 存储桶
  - FIS 扩展轮询 S3 存储桶检查是否有活动实验
  - 启动实验时，FIS 将故障配置写入 S3 存储桶
  - 扩展检测到活动故障后开始应用故障
- **22:30** - 轮询机制详解：
  - 慢轮询模式：无实验运行时，默认 60 秒轮询一次
  - 快轮询模式：检测到活动实验时，切换为 20 秒轮询一次
  - 这是性能与快速恢复之间的权衡

### 实时编码演示 - 应用架构（25:00-32:00）
- **25:00** - 开始实时编码部分，切换到演示环境
- **25:30** - 应用架构介绍：
  - DynamoDB 数据库和表
  - Lambda 函数执行 CRUD 操作
  - API Gateway 托管 API
  - 外部消费者访问 API
- **26:30** - FIS 实验所需组件（架构上半部分）：
  - S3 存储桶（用于 FIS 配置）
  - CloudWatch 仪表板（用于可观测性）
- **27:00** - CDK 代码结构：两个堆栈
  - API 堆栈：部署无服务器应用（API Gateway、Lambda、DynamoDB、S3）
  - FIS 实验堆栈：部署 FIS 实验模板

### 实时编码演示 - API 堆栈代码（32:00-40:00）
- **32:00** - 展示 API 堆栈的 CDK 代码
- **33:00** - Lambda 函数的关键环境变量配置：
  - AWS_FIS_CONFIGURATION_LOCATION：S3 存储桶位置
  - AWS_LAMBDA_EXEC_WRAPPER：扩展引导脚本位置
  - AWS_FIS_EXTENSION_METRICS：设置为 "all" 以生成扩展指标
  - AWS_FIS_EXTENSION_SLOW_POLL_INTERVAL：慢轮询间隔配置
- **35:00** - Lambda 函数部署代码关键点：
  - 资源标签（Resource Tags）：用于 FIS 实验目标选择
  - Lambda 层 ARN：指向 FIS 扩展代码的位置
- **36:30** - 扩展 ARN 说明：每个区域都有对应的扩展版本，不需要都指向 us-east-1
- **37:30** - 标签配置：定义 FIS 实验要针对的标签名称和值

### 实时编码演示 - 已部署资源查看（40:00-47:00）
- **40:00** - 切换到 AWS 控制台查看已部署的堆栈（为节省时间提前部署）
- **40:30** - API 堆栈输出：
  - CloudWatch 仪表板 ARN：用于实验报告
  - FIS 存储桶 ARN：传递给 FIS 实验堆栈
- **41:30** - 查看 Lambda 函数配置（以 GetItem 函数为例）
- **42:00** - Lambda 层展示：FIS 扩展已作为层添加到函数中
- **42:30** - 环境变量验证：确认所有 FIS 相关配置已正确设置
- **44:00** - CloudWatch 仪表板演示：
  - 强调可观测性是混沌工程最关键的要素
  - 仪表板显示关键指标：FIS 延迟影响、Lambda 调用失败等
  - 实验运行时可以观察到指标变化

### 实时编码演示 - FIS 实验堆栈代码（47:00-60:00）
- **47:00** - 开始编写 FIS 实验堆栈的 CDK 代码（Java）
- **48:00** - 遇到网络连接问题，短暂中断
- **49:00** - 恢复演示，继续编写代码
- **49:30** - 导入 S3 存储桶和 CloudWatch 仪表板（从 API 堆栈）
- **50:00** - 创建 FIS 报告存储桶（第二个 S3 存储桶）
- **50:30** - 说明两个存储桶的区别：
  - 第一个：FIS 发送实验配置
  - 第二个：FIS 存储实验报告
- **51:00** - 创建 IAM 策略：
  - 报告存储桶写入权限
  - FIS 配置存储桶读写权限
  - Lambda 函数访问权限
  - 标签策略（用于资源选择）
  - CloudWatch 日志权限
  - CloudWatch 仪表板访问权限
- **54:00** - 创建 FIS 角色，附加所有策略
- **54:30** - 开始创建实验模板 1：注入启动延迟
- **55:00** - 实验模板配置：
  - 描述：详细说明实验目的
  - 名称：inject-delay
  - 操作：invoke-add-delay
  - 参数：
    - startupDelay：2000 毫秒（2 秒）
    - duration：PT5M（5 分钟）
    - invocationPercentage：100（影响所有调用）
- **56:30** - 调用百分比说明：可设置为 50% 以实现更零星的故障注入
- **57:00** - 目标配置：
  - 资源类型：Lambda 函数
  - 选择模式：通过标签选择
  - 选择范围：所有匹配的函数
- **58:00** - 报告配置：
  - 指定报告存储桶
  - 关联 CloudWatch 仪表板
  - 设置实验前状态持续时间（稳定状态）
  - 设置实验状态持续时间
  - 设置实验后状态持续时间（恢复状态）
- **59:00** - 创建实验模板 2：注入调用错误
- **59:30** - 第二个模板与第一个类似，主要区别是操作类型：inject-invocation-error

### 实时编码演示 - 问题排查与部署（60:00-结束）
- **60:00** - 观众提问：preventExecution 参数设置为 false 会发生什么？
- **60:30** - 回答：
  - 设置为 true：Lambda 代码不执行，直接返回错误
  - 设置为 false：Lambda 代码执行后再注入故障
  - 适用于调用错误和集成响应修改两个操作
- **61:00** - 代码编译错误：发现重复定义了 FIS 角色
- **61:30** - 观众协助发现错误位置
- **62:00** - 修复错误：删除重复的报告存储桶定义
- **62:30** - 演讲者幽默评论："这就是实时编码的乐趣"
- **63:00** - 开始部署堆栈

注：由于字幕在部署过程中截断，完整的部署结果和实验运行演示未包含在提供的字幕中。