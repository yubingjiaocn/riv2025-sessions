# AWS re:Invent 2025 会议总结：使用 Agentic AI 简化 EKS 运维

## 会议概述

本次会议是一场代码实战演示（Code Talk），由 AWS 首席解决方案架构师 Sai Venom 和 Lucas Dwart 主讲。会议重点展示了如何利用 Agentic AI 技术构建智能化的 Kubernetes 运维助手，实现 EKS 集群的自动化故障排查和问题修复。

演讲者通过现场编码的方式，展示了从简单的 RAG（检索增强生成）架构演进到基于 Strands SDK 和 MCP（模型上下文协议）的智能代理系统。这个系统不仅仅是一个聊天机器人，而是一个能够主动监控、分析和解决问题的"团队成员"。它可以接收来自 Alert Manager 的告警信息，自动执行故障排查，并在 Slack 频道中提供详细的分析和解决方案。

会议特别强调了使用合适的 LLM 模型来完成特定任务的重要性。例如，使用轻量级的 Nova Micro 模型进行消息分类，而使用更强大的 Claude 3 Sonnet 进行复杂的故障排查。这种多代理架构不仅提高了效率，还显著降低了运营成本。演讲者还介绍了 AWS 最新发布的托管式 EKS MCP 服务器，大大简化了 MCP 的配置和使用。

## 详细时间线

### 开场介绍 (00:00 - 02:30)
- **00:00** - 会议开始，介绍演讲者：Sai Venom 和 Lucas Dwart，均为 AWS 首席解决方案架构师
- **00:30** - 说明这是一场非录制的现场编码会议（Code Talk）
- **01:00** - 介绍会议主题：使用 Agentic AI 简化 EKS 运维操作
- **01:30** - 强调这不是简单的聊天机器人，而是一个智能团队成员
- **02:00** - 提到去年的会议使用了 AI，但今年利用了更先进的代理和 MCP 技术

### 演示目标系统 (02:30 - 05:00)
- **02:30** - 介绍新团队成员：Cube Agent（Kubernetes 代理）
- **03:00** - 展示系统架构：Slack 频道 + 内存代理 + Kubernetes 专家代理
- **03:30** - 演示录制视频：Alert Manager 发送告警到 Slack
- **04:00** - 代理自动识别告警并开始故障排查循环
- **04:30** - 代理自动修复问题并在 Slack 中报告解决方案
- **04:45** - 讨论生产环境中应集成 GitOps 进行人工审核

### RAG 架构回顾 (05:00 - 07:30)
- **05:00** - 回顾去年使用的 RAG（检索增强生成）方法
- **05:30** - 解释 RAG 工作流程：数据分块 → 向量存储 → 嵌入检索 → LLM 生成
- **06:00** - 指出 RAG 的局限性：受限于上下文窗口大小
- **06:30** - 强调 RAG 的另一个问题：数据不是实时的，可能每 30-60 分钟更新一次
- **07:00** - 说明这导致工程师需要手动运行 kubectl 命令获取数据

### Strands SDK 介绍 (07:30 - 09:00)
- **07:30** - 介绍 Strands：用于构建代理的开源 SDK
- **08:00** - 询问现场观众是否使用过 Strands（有几位举手）
- **08:30** - 展示多代理架构：使用多个专门的代理而非单一大型代理
- **08:45** - 说明代理可以相互通信、使用多个 LLM 模型、连接 AWS 资源和 MCP 服务器

### 基础架构搭建 (09:00 - 13:00)
- **09:00** - 展示基础架构：Slack 接口 → 编排代理 → Kubernetes 专家代理
- **09:30** - 打开 IDE 查看代码结构
- **10:00** - 展示编排代理代码：从 Strands SDK 导入功能
- **10:30** - 介绍 Kubernetes 专家代理：配置了 describe_pod 和 get_pods 工具
- **11:00** - 展示配置文件：使用 Claude 3 Sonnet 模型
- **11:30** - 说明 Slack 处理器代码是使用 Kira（AI 编码助手）自动生成的
- **12:00** - 查看 requirements.txt 文件中的依赖项
- **12:30** - 准备进行第一次演示

### 第一次演示：基础功能 (13:00 - 16:00)
- **13:00** - 说明当前代理只有 describe_pod 和 get_pods 两个工具
- **13:30** - 在 Slack 中提问："我的 EKS 集群中有哪些命名空间？"
- **14:00** - 代理尝试通过 get_pods 推断命名空间
- **14:30** - 代理返回 3 个命名空间（不准确）
- **15:00** - 使用 K9s 工具验证，实际有更多命名空间
- **15:30** - 说明需要改进代理能力

### 集成 MCP 服务器 (16:00 - 20:00)
- **16:00** - 介绍 AWS 托管的 EKS MCP 服务器（两周前发布）
- **16:30** - 说明托管 MCP 的优势：无需本地运行、使用 IAM 权限管理
- **17:00** - 展示新架构图：添加 MCP 服务器组件
- **17:30** - 打开代码编辑器准备添加 MCP 支持
- **18:00** - 在 settings 文件中启用 MCP 配置
- **18:30** - 在 Kubernetes 专家代理中导入 MCP 库
- **19:00** - 添加 MCP 客户端初始化代码（使用 stdio 协议）
- **19:30** - 添加清理方法以正确关闭 MCP 连接

### 第二次演示：MCP 增强 (20:00 - 23:00)
- **20:00** - 重启 Python 应用程序
- **20:30** - 再次提问："我的 EKS 集群中有哪些命名空间？"
- **21:00** - 代理使用 MCP 提供的 list_kubernetes_resources 工具
- **21:30** - 强调这个工具从未手动编码，完全来自 MCP 服务器
- **22:00** - 代理返回正确的命名空间列表
- **22:30** - 讨论 MCP 的优势：集中化工具管理，避免重复编码
- **22:45** - 将 MCP 比作 USB-C：解决 N×M 集成问题的标准协议

### 智能消息分类 (23:00 - 28:00)
- **23:00** - 展示当前的关键词匹配方法的局限性
- **23:30** - 查看 keywords 文件中的有限关键词列表
- **24:00** - 说明需要使用 AI 进行智能意图分类
- **24:30** - 介绍新架构：使用 Nova Micro 进行消息分类
- **25:00** - 类比：不需要用博士数学家来做酒店前台工作
- **25:30** - 强调 Slack 机器人监听所有消息，需要高效的分类机制
- **26:00** - 说明 Nova Micro 是轻量级、快速且成本低的模型
- **26:30** - 开始编写分类代码

### 实现智能分类 (28:00 - 33:00)
- **28:00** - 创建分类提示词：判断消息是否与 Kubernetes 故障排查相关
- **28:30** - 提示词要求模型只回答"是"或"否"
- **29:00** - 设置最大 token 数为 10（因为"是"/"否"不超过 10 个 token）
- **29:30** - 导入必要的库：JSON、boto3、BeforeInvocationEvent
- **30:00** - 实现 before_invocation 钩子方法
- **30:30** - 创建 callback_message_validator 方法
- **31:00** - 实现 classify_with_nova 方法：调用 Nova Micro 进行分类
- **31:30** - 更新构造函数：初始化 Bedrock 客户端
- **32:00** - 添加代理钩子：在调用前执行消息验证
- **32:30** - 删除旧的关键词匹配方法

### 第三次演示：智能分类 (33:00 - 36:00)
- **33:00** - 重启应用程序（无错误）
- **33:30** - 提问："我运行的是什么版本的 EKS？"（EKS 不在关键词列表中）
- **34:00** - 查看日志：显示"message classification: yes"
- **34:30** - 代理成功响应，因为 Nova Micro 判断这是技术问题
- **35:00** - 测试负面案例："大家今天几点吃午饭？"
- **35:30** - 查看日志：显示"No"，代理不响应
- **35:45** - 强调响应速度快且成本低（仅 1 个输出 token）

### 总结与扩展讨论 (36:00 - 结束)
- **36:00** - 讨论可以使用本地小语言模型替代 Nova Micro
- **36:30** - 提到在笔记本电脑 CPU 上运行小模型的可行性
- **37:00** - 强调 Strands SDK 提供的各种钩子功能（before/after invocation）
- **37:30** - 讨论未来可能的微代理架构（类似微服务）
- **38:00** - 会议结束，准备回答观众问题