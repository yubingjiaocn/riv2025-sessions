# AWS re:Invent 2025 - 构建自主自我改进的AI代理

## 会议概述

本次会议由AWS首席工程师Aaron和研究工程师Shagatai主讲,主题为"Strands代理与构建自主自我改进的AI代理"。会议展示了如何构建能够读取自身源代码、在运行时创建新能力并部署到生产环境的自我进化代理系统。这不是理论探讨,而是基于完全可运行的开源代码实现,所有代码都已发布在GitHub仓库中供参与者学习和使用。

会议采用渐进式教学方法,从最基础的代理开始,逐步引入更多自主性功能。核心理念是将工程和科学团队的负担转移给具备编排能力的先进模型(如Claude 4.5、GPT-5等),让代理自己决定如何分解任务、需要什么技能和工具,而不是由工程师预定义复杂的工作流图和边缘情况处理。

演讲者强调了自我进化代理的三步循环机制:动态检索信息、自我修改行为、持久化修改结果。这个循环使代理能够在每次交互中不断修改和进化自己。会议还探讨了元代理(meta agents)概念,即能够自我编排的代理,它们可以动态创建子代理、管理共享上下文,甚至在运行时更新自己的Python代码。

## 详细时间线与关键要点

### 开场介绍 (00:00 - 02:30)
- **00:00** - Aaron和Shagatai介绍自己,均来自AWS代理组织
- **00:45** - 会议目标:观看AI代理读取源代码、创建新能力并部署到生产环境
- **01:15** - 展示GitHub仓库二维码,包含6个提交记录,每个提交对应一个功能演进
- **02:00** - 现场投票结果显示:参与者背景多样,从新手到已构建生产级代理系统的开发者

### 会议议程 (02:30 - 04:00)
- **02:30** - 议程概览:从基础代理开始,逐步增加自主性
- **03:00** - 核心功能包括:代理构建自己的工具、更新系统提示词、从交互中学习
- **03:30** - 引入元代理概念:代理自我编排,无需预定义工作流图
- **03:50** - 最后将部署到Agent Core,预留5-10分钟问答时间

### 基础代理演示 (04:00 - 06:30)
- **04:00** - Shagatai演示基础代理,使用Strands SDK设计
- **04:30** - 基础代理只有shell工具,可以访问运行环境
- **05:00** - 提出核心问题:代理能否构建自己的工具?
- **05:45** - 引入"自扩展代理"(self-extending agents)概念

### 代理构建自己的工具 (06:30 - 10:00)
- **06:30** - Strands支持从目录热加载工具,类似前端框架的文件路由
- **07:00** - 代码示例:系统提示词指示代理"为自己创建工具并立即使用"
- **07:30** - 工具定义使用@add_tool装饰器,启用load_tools_from_directory=true
- **08:00** - 实时演示:代理创建tools目录并生成多个工具文件
- **08:30** - 代理创建的工具包括:计算器、路径生成器、文本分析器、单位转换器等
- **09:00** - 关键点:代理创建工具后立即开始使用,无需停止进程
- **09:30** - 演示完成,证明代理可以在运行时构建并使用新能力

### 代理更新系统提示词 (10:00 - 15:00)
- **10:00** - Aaron介绍代理如何更新自己的系统提示词
- **10:30** - 系统提示词从环境变量SYSTEM_PROMPT读取,实现持久化存储
- **11:00** - 代理配备environment工具,可以读写环境变量
- **11:30** - 三个关键步骤:定义动态系统提示词、每次调用时重构提示词、代理可修改提示词
- **12:00** - 代码示例:每次循环都重新加载系统提示词
- **12:30** - 演示:Shagatai告诉代理"我的名字是Shagatai Kelly,我们在做AIM 426会议"
- **13:00** - 代理检查环境变量,发现系统提示词未设置,自动设置
- **13:30** - 清空对话历史后,代理仍能记住名字,证明信息存储在系统提示词中
- **14:30** - 这是一种基础的记忆形式,为后续更复杂的记忆机制奠定基础

### 自我进化的三步循环 (15:00 - 17:30)
- **15:00** - Shagatai总结动态提示词构建的三个步骤
- **15:30** - 步骤1:动态提示词构建,允许系统提示词的部分内容动态更新
- **16:00** - 步骤2:自我修改,代理需要有权限更新该部分内容
- **16:30** - 步骤3:持久化,将更新后的系统提示词版本存储到某处
- **17:00** - 持久化对子代理至关重要,否则子代理无法感知上下文变化

### 使用向量存储的记忆机制 (17:30 - 23:00)
- **17:30** - Aaron介绍更常见的记忆方法:使用向量存储
- **18:00** - 三步流程:搜索相关对话和历史上下文、代理响应、存储交互结果
- **18:30** - 代码示例:使用Bedrock Knowledge Base作为向量存储
- **19:00** - 使用retrieve工具进行语义搜索,预填充代理上下文
- **19:30** - 直接工具调用agent.tool()可以程序化调用工具并预填充上下文
- **20:00** - 代理调用后,使用store_in_kb工具将对话历史存储到知识库
- **20:30** - 存储的文档包含用户问题和代理回答,实现持续学习
- **21:00** - 代理也可以动态调用这些工具,无需手动编程
- **21:30** - 演示:询问"你认识Shagatai Kelly吗?",代理从知识库检索信息并回答
- **22:30** - 这是典型的记忆集成方式,代理能够使用知识库中的文档

### 问答环节1 - 权限和多知识库 (23:00 - 25:30)
- **23:00** - 观众提问:工具使用什么权限访问知识库?
- **23:30** - Shagatai回答:需要IAM角色,建议使用Bedrock Agent Core Memory
- **24:00** - Aaron补充:Strands提供多种工具,包括S3 Vectors、Mem Zero等
- **24:30** - 观众提问:代理能否检索多个知识库?
- **25:00** - Aaron回答:可以提供多个工具(每个知识库一个)或合并到一个工具中

### 元代理与增强自主性 (25:30 - 30:00)
- **25:30** - Shagatai介绍如何进一步增强代理的自主性和能力
- **26:00** - 三个层次的自主性:构建工具、动态创建代理、更新自己的Python代码
- **26:30** - Aaron强调动态创建代理的重要性:模型自己决定需要什么子代理
- **27:00** - 类比项目管理:主代理像项目经理,知道需要什么技能的团队成员
- **27:30** - 模型决定如何分解任务、需要什么工具,无需工程师预定义
- **28:00** - 子代理也可以是自我进化的,形成递归结构
- **28:30** - Shagatai介绍use_agent工具:接受系统提示词、工具、模型提供商等参数

### 元工具详解 (30:00 - 35:00)
- **30:00** - 代码示例:主代理配备shell、use_agent、think、swarm、graph、journal工具
- **30:30** - use_agent工具:创建全新的代理实例,可使用不同模型提供商
- **31:00** - think工具:递归思考,将一个代理的结果传递给下一个代理
- **31:30** - Aaron解释:think工具像递归思考,类似研究过程中的多次迭代和精炼
- **32:00** - swarm工具:代理之间的共享上下文,像自组织团队
- **32:30** - Aaron类比:他和Shagatai合作准备演讲,没有领导者,只是协作
- **33:00** - graph工具:条件边缘,定义代理之间的有向关系
- **33:30** - journal工具:使用文件系统持久化数据,作为代理的草稿本
- **34:00** - Aaron补充:journal可以是待办事项列表,让代理不丢失上下文

### 元代理演示 (35:00 - 38:00)
- **35:00** - 演示:用户输入"测试use_agent工具"
- **35:30** - 主代理决定并行调用use_agent工具多次,计算2+2
- **36:00** - 关键成就:扩展了上下文长度,每个子代理有独立的100万token上下文
- **36:30** - 子代理可以相互调用,进一步扩展上下文容量
- **37:00** - 展示架构图:4个子代理工具并行调用,采用"发射后忘记"模式
- **37:30** - 第一行:一个代理使用另一个代理,后者创建两个子代理并等待结果

### 复杂代理架构图解析 (38:00 - 42:00)
- **38:00** - 架构图第一行:最多消耗400万tokens(4个代理各100万)
- **38:30** - 第二行:递归调用代理,共享上下文,think工具调用10次
- **39:00** - Aaron解释:think工具像研究过程,多次重访和精炼理解
- **39:30** - Shagatai展示swarm模式:代理之间有交集的共享上下文
- **40:00** - Aaron补充:共享上下文可以在内存中实现,也可以用DynamoDB等存储
- **40:30** - 类比:共享上下文像他们准备演讲时的共享笔记
- **41:00** - 最后一行:graph模式,有向系统,可以形成循环
- **41:30** - 关键点:graph节点中的一个使用use_agent工具,实现组合

### 问答环节2 - Journal vs Memory (42:00 - 44:00)
- **42:00** - 观众提问:journal工具和memory有什么区别?
- **42:30** - Shagatai回答:journal只使用文件系统,没有额外依赖
- **43:00** - 即使断网,代理仍能工作,因为journal是本地的
- **43:30** - Aaron补充:memory(如Bedrock Knowledge Base)是向量存储,支持语义检索
- **44:00** - journal是基于markdown文件,不支持语义搜索,但适合跟踪进度

### 编排原语的组合性 (44:00 - 46:00)
- **44:00** - Aaron强调:这些编排原语(graph、swarm、use_agent)可以混合匹配
- **44:30** - 可以构建"graph的graph"、"swarm的graph"等复杂结构
- **45:00** - 代理运行时可以改变自己的运行方式,这是模型驱动的方法
- **45:30** - Shagatai引用Stephen Hawking:"智能是适应变化的能力"
- **46:00** - 软件应该帮助人们,不应该是静态的,代理和机器人是实现方式

### 部署到生产环境 (46:00 - 结束)
- **46:00** - 开始部署演示,展示如何将自我进化代理部署到云端
- **46:30** - 强调之前的代码让代理更新系统提示词、构建工具
- **47:00** - 现在需要部署到云端,不依赖本地MacBook运行
- **47:15** - 视频演示开始(字幕在此处中断)

### 核心技术要点总结
- **自我进化循环**:检索→修改→持久化,形成持续改进的闭环
- **工具热加载**:代理可以在运行时创建和加载新工具
- **动态系统提示词**:通过环境变量或外部存储实现提示词的动态更新
- **多层记忆机制**:从简单的环境变量到向量存储,再到文件系统journal
- **元代理架构**:主代理可以动态创建、编排和管理子代理
- **上下文扩展**:通过子代理实现上下文长度的指数级扩展
- **模型驱动编排**:将复杂的工作流决策交给先进的LLM模型