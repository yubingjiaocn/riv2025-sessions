1
00:00:04,740 --> 00:00:06,333
- All right, welcome everyone.

2
00:00:07,560 --> 00:00:10,323
Give me a thumbs up if the audio is good.

3
00:00:11,520 --> 00:00:12,840
Let's see.

4
00:00:12,840 --> 00:00:15,210
Wanna make sure everyone can hear me.

5
00:00:15,210 --> 00:00:16,043
Awesome.

6
00:00:17,700 --> 00:00:19,740
My name is Roland Barcia.

7
00:00:19,740 --> 00:00:21,030
I'm the worldwide director

8
00:00:21,030 --> 00:00:23,790
for our specialist technology team,

9
00:00:23,790 --> 00:00:26,370
and I have the honor and
privilege to be here with Mridula.

10
00:00:26,370 --> 00:00:28,860
You wanna introduce yourself?
- For sure.

11
00:00:28,860 --> 00:00:29,693
Hello, everyone.

12
00:00:29,693 --> 00:00:30,990
My name is Mridula Grandhi,

13
00:00:30,990 --> 00:00:33,720
and I lead the go-to-market
for North America

14
00:00:33,720 --> 00:00:35,190
for specialist SAs.

15
00:00:35,190 --> 00:00:36,900
I'm happy to be here and be talking

16
00:00:36,900 --> 00:00:40,170
about unlocking agentic
AI for microservices.

17
00:00:40,170 --> 00:00:41,703
- Thank you.

18
00:00:41,703 --> 00:00:42,990
Thank you for joining us, by the way,

19
00:00:42,990 --> 00:00:46,080
in the evening 05:30, not a great slot.

20
00:00:46,080 --> 00:00:48,630
I know people want to go have nice dinners

21
00:00:48,630 --> 00:00:49,530
and things at this time,

22
00:00:49,530 --> 00:00:51,450
so really appreciate you all being here.

23
00:00:51,450 --> 00:00:53,190
Thank you so much.

24
00:00:53,190 --> 00:00:54,750
So, let's get started.

25
00:00:54,750 --> 00:00:57,000
I'm gonna go through the animations quick,

26
00:00:57,000 --> 00:00:59,250
'cause I really wanna have a
conversation with the audience.

27
00:00:59,250 --> 00:01:00,990
I wish it was a little
bit more two-way here,

28
00:01:00,990 --> 00:01:05,990
but obviously, AI applications
have really exploded.

29
00:01:07,440 --> 00:01:09,510
I mean, how many sessions
were there this week

30
00:01:09,510 --> 00:01:10,950
with the word agents in it?

31
00:01:10,950 --> 00:01:12,630
Agents is everywhere.

32
00:01:12,630 --> 00:01:14,910
We're entering the agentic age,

33
00:01:14,910 --> 00:01:17,520
and it's really important to understand

34
00:01:17,520 --> 00:01:19,890
what that means for your existing systems,

35
00:01:19,890 --> 00:01:24,163
your existing microservices,
your existing applications.

36
00:01:24,163 --> 00:01:26,880
I wanna get started a little
bit with agent-driven design

37
00:01:26,880 --> 00:01:28,800
and agent applications.

38
00:01:28,800 --> 00:01:31,830
We've spent many years
building microservices.

39
00:01:31,830 --> 00:01:33,960
Mridula is gonna talk
about that in a minute,

40
00:01:33,960 --> 00:01:37,200
but agentic applications
have really emerged

41
00:01:37,200 --> 00:01:38,850
as a new pattern,

42
00:01:38,850 --> 00:01:41,760
and there's a lot of
differences between them.

43
00:01:41,760 --> 00:01:45,000
So for example, very
stateful applications,

44
00:01:45,000 --> 00:01:48,960
very data-intensive, very conversational,

45
00:01:48,960 --> 00:01:50,730
there's a lot of different principles.

46
00:01:50,730 --> 00:01:53,190
The DevOps is different in many ways.

47
00:01:53,190 --> 00:01:54,780
You're doing things like evaluations.

48
00:01:54,780 --> 00:01:57,750
We announced agent core
evaluation today, for example.

49
00:01:57,750 --> 00:01:59,880
We're doing things with MLOps,

50
00:01:59,880 --> 00:02:02,280
we're doing a lot of
different things with data.

51
00:02:02,280 --> 00:02:04,440
We wanna make sure we can get at the data,

52
00:02:04,440 --> 00:02:05,907
get insights from the data,

53
00:02:05,907 --> 00:02:07,980
and we wanna make sure we have guardrails.

54
00:02:07,980 --> 00:02:11,040
We wanna make sure it's
enhancing human ability

55
00:02:11,040 --> 00:02:14,850
to do things faster and more
effectively with more quality.

56
00:02:14,850 --> 00:02:17,703
And these are all aspects
of agent-driven design.

57
00:02:18,600 --> 00:02:22,800
Now, a lot of the early
agentic applications,

58
00:02:22,800 --> 00:02:25,260
were static workflows.

59
00:02:25,260 --> 00:02:27,480
Oftentimes, stitching together agents

60
00:02:27,480 --> 00:02:31,260
through workflow tools,
BPM tools, et cetera.

61
00:02:31,260 --> 00:02:32,730
We worked with a telco provider.

62
00:02:32,730 --> 00:02:35,790
One of the teams I run
is the prototyping team.

63
00:02:35,790 --> 00:02:38,700
And we spend a lot of
times helping customers,

64
00:02:38,700 --> 00:02:41,850
build their first agent,
their first agent use cases.

65
00:02:41,850 --> 00:02:44,280
This one is a very interesting one for me,

66
00:02:44,280 --> 00:02:45,960
and it kind of highlights
some of the themes

67
00:02:45,960 --> 00:02:47,370
we're gonna talk about.

68
00:02:47,370 --> 00:02:50,700
We worked on this SRE agent,

69
00:02:50,700 --> 00:02:53,580
and what we wanted to do
is have a metric, a goal.

70
00:02:53,580 --> 00:02:56,970
They wanted to get from 30,
40 minutes problem resolution,

71
00:02:56,970 --> 00:02:58,710
down to five minutes.

72
00:02:58,710 --> 00:03:02,040
And so, you know, we can solve
this with agentic behavior,

73
00:03:02,040 --> 00:03:03,450
but a lot of the things

74
00:03:03,450 --> 00:03:07,080
and systems they needed were
locked inside of applications.

75
00:03:07,080 --> 00:03:08,790
And so, they wanted information

76
00:03:08,790 --> 00:03:11,850
about their Kubernetes EKS cluster,

77
00:03:11,850 --> 00:03:14,580
they wanted information
about their metrics server,

78
00:03:14,580 --> 00:03:16,770
they wanted observability information,

79
00:03:16,770 --> 00:03:20,520
and they had built a wealth
of knowledge around runbooks.

80
00:03:20,520 --> 00:03:24,150
So, we built these existing
systems and exposed them

81
00:03:24,150 --> 00:03:26,649
through the model context protocol.

82
00:03:26,649 --> 00:03:28,470
Mridula's gonna talk a
little bit about that later.

83
00:03:28,470 --> 00:03:31,260
That's MCP, if you're living under a rock,

84
00:03:31,260 --> 00:03:33,162
is like everywhere, right?

85
00:03:33,162 --> 00:03:34,885
There's like probably more MCP servers,

86
00:03:34,885 --> 00:03:37,440
and there are people using
MCP servers in many ways.

87
00:03:37,440 --> 00:03:42,440
But we built an SRE agent
that really modeled workflows,

88
00:03:42,540 --> 00:03:45,090
after their existing
patterns and runbooks,

89
00:03:45,090 --> 00:03:49,140
and they were able to really
resolve a bunch of the issues

90
00:03:49,140 --> 00:03:51,840
that they had in production
a lot more quickly.

91
00:03:51,840 --> 00:03:53,610
And these are examples of the power

92
00:03:53,610 --> 00:03:56,610
of taking your existing
deterministic code,

93
00:03:56,610 --> 00:03:59,220
deterministic operations and exposing them

94
00:03:59,220 --> 00:04:00,900
through a common API,

95
00:04:00,900 --> 00:04:04,140
and then being able to build
orchestration and workflows,

96
00:04:04,140 --> 00:04:05,760
and they were able to not only get

97
00:04:05,760 --> 00:04:07,620
to what is the issue quicker,

98
00:04:07,620 --> 00:04:10,350
but actually, take
resolution steps with agents

99
00:04:10,350 --> 00:04:12,540
and take actions on them as well.

100
00:04:12,540 --> 00:04:14,820
This is the power of
agentic behavior being able

101
00:04:14,820 --> 00:04:17,730
to stitch these things
and automate the things

102
00:04:17,730 --> 00:04:21,033
that we wanna automate
so we can focus on value.

103
00:04:22,650 --> 00:04:24,951
But microservices is a challenge,

104
00:04:24,951 --> 00:04:26,220
and with that, Mridula is
gonna talk a little bit

105
00:04:26,220 --> 00:04:27,183
about some of this.

106
00:04:29,160 --> 00:04:32,160
- All right, let me start with
the question for the room.

107
00:04:32,160 --> 00:04:36,000
How many of you are actually
running microservices

108
00:04:36,000 --> 00:04:36,990
on production today?

109
00:04:36,990 --> 00:04:39,810
And a quick show of hands.
- [Roland] Should be everyone.

110
00:04:39,810 --> 00:04:40,980
- That's awesome.

111
00:04:40,980 --> 00:04:42,900
And keep your hands up,

112
00:04:42,900 --> 00:04:47,373
if you have agents already
accessing them on production.

113
00:04:49,050 --> 00:04:50,763
Okay, that's what I thought.

114
00:04:52,110 --> 00:04:55,860
We've been running microservices
on production successfully,

115
00:04:55,860 --> 00:04:59,403
but now AI agents want in club.

116
00:05:00,630 --> 00:05:02,070
Think of it like this.

117
00:05:02,070 --> 00:05:05,370
We've either started
directly with microservices

118
00:05:05,370 --> 00:05:09,600
or decomposed monolith
applications into microservices.

119
00:05:09,600 --> 00:05:12,900
We now have a fleet of microservices each

120
00:05:12,900 --> 00:05:17,520
with its own API
databases, business logic.

121
00:05:17,520 --> 00:05:20,940
All the services are
talking fluently in rest,

122
00:05:20,940 --> 00:05:24,720
but agents only understand
why coding, just kidding.

123
00:05:24,720 --> 00:05:27,600
When we are bringing agents
into the enterprise world,

124
00:05:27,600 --> 00:05:31,560
agents that can plan
reason, break down tasks,

125
00:05:31,560 --> 00:05:35,370
execute the tools, and
actually achieve the outcome

126
00:05:35,370 --> 00:05:37,800
that you want them to achieve.

127
00:05:37,800 --> 00:05:41,130
And when you expose them
into the microservices world,

128
00:05:41,130 --> 00:05:43,830
they'll be like, "Okay, cool endpoints.

129
00:05:43,830 --> 00:05:46,170
What do you want us to do with it?"

130
00:05:46,170 --> 00:05:49,950
This is where the context
engineering comes into picture.

131
00:05:49,950 --> 00:05:52,350
In the microservices environment,

132
00:05:52,350 --> 00:05:56,970
context engineering is
where you tell the agents

133
00:05:56,970 --> 00:05:59,100
what services exist,

134
00:05:59,100 --> 00:06:03,630
which ones it's actually
allowed to call, in what order,

135
00:06:03,630 --> 00:06:05,850
under which preconditions,

136
00:06:05,850 --> 00:06:08,223
and how do you recover from failure?

137
00:06:09,090 --> 00:06:11,730
And if it's actually done right,

138
00:06:11,730 --> 00:06:14,790
you're turning a flat list of APIs

139
00:06:14,790 --> 00:06:19,790
into a map of capabilities,
constraints, and workflows,

140
00:06:19,860 --> 00:06:24,120
exactly the environment
that agents can thrive.

141
00:06:24,120 --> 00:06:26,850
So the real problem is
actually not the logic.

142
00:06:26,850 --> 00:06:28,260
The logic is already existing

143
00:06:28,260 --> 00:06:30,840
in your microservices applications.

144
00:06:30,840 --> 00:06:33,930
The real problem is the exposure.

145
00:06:33,930 --> 00:06:38,640
How do you surface the
already existing logic

146
00:06:38,640 --> 00:06:41,370
that's there in your microservices

147
00:06:41,370 --> 00:06:46,370
into a structured contextual
and a truly agent-friendly way

148
00:06:46,740 --> 00:06:50,170
so that your agents can start
talking to your microservices

149
00:06:51,900 --> 00:06:54,360
and build the new agentic systems?

150
00:06:54,360 --> 00:06:57,630
Now, think about it from
your environment perspective.

151
00:06:57,630 --> 00:07:00,510
What does it take for you

152
00:07:00,510 --> 00:07:04,530
to actually expose your
microservices to the agents

153
00:07:04,530 --> 00:07:07,470
so that you're truly unlocking that value,

154
00:07:07,470 --> 00:07:08,820
and actually unlocking

155
00:07:08,820 --> 00:07:13,503
to the next level of enterprise
scale agentic automation?

156
00:07:17,640 --> 00:07:20,730
Now, before we dive deep into AI agents,

157
00:07:20,730 --> 00:07:22,560
let's make sure that we are actually,

158
00:07:22,560 --> 00:07:25,770
all speaking the same
language of microservices.

159
00:07:25,770 --> 00:07:30,570
Foundationally, a microservice
is a simple deployable unit

160
00:07:30,570 --> 00:07:32,940
that has a specific business function,

161
00:07:32,940 --> 00:07:36,750
and can talk to each other
and also external data sources

162
00:07:36,750 --> 00:07:39,870
through rest endpoints or
well-defined endpoints, right?

163
00:07:39,870 --> 00:07:41,520
Think of it like Lego blocks.

164
00:07:41,520 --> 00:07:46,380
Each block has a specific
function that does it well,

165
00:07:46,380 --> 00:07:48,390
but when you snap them together,

166
00:07:48,390 --> 00:07:50,583
you're actually creating
something amazing.

167
00:07:51,420 --> 00:07:53,640
Now, there are six
principles of microservices

168
00:07:53,640 --> 00:07:56,190
that I want you all to underscore.

169
00:07:56,190 --> 00:07:58,530
First is service independence.

170
00:07:58,530 --> 00:08:01,170
Each service is a standalone application

171
00:08:01,170 --> 00:08:05,370
or with its own database
and deployment lifecycle.

172
00:08:05,370 --> 00:08:08,120
Think of it like roommates
with separate bank accounts.

173
00:08:09,210 --> 00:08:11,490
Second is single responsibility.

174
00:08:11,490 --> 00:08:15,180
One service, one job, done well.

175
00:08:15,180 --> 00:08:17,700
Third is decentralized communication.

176
00:08:17,700 --> 00:08:21,510
Services talk in well-defined endpoints

177
00:08:21,510 --> 00:08:26,190
or APIs not directly access the database.

178
00:08:26,190 --> 00:08:28,950
Fourth is agnostic tech stack.

179
00:08:28,950 --> 00:08:32,400
Service A can be written in
Python, service B in Java,

180
00:08:32,400 --> 00:08:35,583
service C in Rust, do whatever fits well.

181
00:08:36,840 --> 00:08:39,060
Fifth is system resiliency.

182
00:08:39,060 --> 00:08:43,590
One failure doesn't crash
your entire application,

183
00:08:43,590 --> 00:08:47,883
just like a flat tire doesn't
bring the entire highway down.

184
00:08:48,810 --> 00:08:51,870
And the last is the
independent deployability.

185
00:08:51,870 --> 00:08:53,910
You can deploy, update,

186
00:08:53,910 --> 00:08:55,500
and roll back your services

187
00:08:55,500 --> 00:08:58,440
without impacting other services.

188
00:08:58,440 --> 00:09:03,440
These six principles are what
make microservices powerful.

189
00:09:03,750 --> 00:09:05,340
And once you master these,

190
00:09:05,340 --> 00:09:07,920
you're actually ready to
understand the AI agents

191
00:09:07,920 --> 00:09:10,323
and how it unlocks to the next level.

192
00:09:13,350 --> 00:09:16,590
Now, let's look at how some of the aspects

193
00:09:16,590 --> 00:09:19,560
that we discuss on this
slide could be helpful

194
00:09:19,560 --> 00:09:23,460
for you to think about
rethinking microservices

195
00:09:23,460 --> 00:09:24,720
in the agentic era.

196
00:09:24,720 --> 00:09:28,500
Now on the left, you have the
core microservice constructs.

197
00:09:28,500 --> 00:09:31,980
You've got your data layer,
where you store your databases,

198
00:09:31,980 --> 00:09:35,670
you've got your events flowing
through the message queues,

199
00:09:35,670 --> 00:09:37,800
you've got your business logic,

200
00:09:37,800 --> 00:09:40,376
the code that makes the decision,

201
00:09:40,376 --> 00:09:41,310
the brain of your business.

202
00:09:41,310 --> 00:09:44,370
And if you've got your communication,

203
00:09:44,370 --> 00:09:48,153
the rest APIs talking to each
other, pretty straightforward.

204
00:09:49,110 --> 00:09:50,403
Now on the right,

205
00:09:51,570 --> 00:09:55,110
what you have are the
AI AgentCore constructs.

206
00:09:55,110 --> 00:09:58,890
And when you infuse these
into your microservices,

207
00:09:58,890 --> 00:10:01,503
you're adding four new capabilities.

208
00:10:02,460 --> 00:10:04,230
The first is the reasoning.

209
00:10:04,230 --> 00:10:08,610
Reasoning is the agent's
ability to solve problems.

210
00:10:08,610 --> 00:10:09,690
Chain of thought,

211
00:10:09,690 --> 00:10:13,503
is the agent explaining
its reasoning out loud.

212
00:10:14,460 --> 00:10:17,610
Chain of thought transforms
what you see as a black box

213
00:10:17,610 --> 00:10:19,440
to actually a glass box,

214
00:10:19,440 --> 00:10:23,040
because you get to see every
decision that is being made.

215
00:10:23,040 --> 00:10:24,510
And especially, that's important,

216
00:10:24,510 --> 00:10:26,190
when you are orchestrating your services

217
00:10:26,190 --> 00:10:28,380
in a production environment.

218
00:10:28,380 --> 00:10:29,673
Next is the memory.

219
00:10:31,740 --> 00:10:34,380
You have two different types
of memory fundamentally.

220
00:10:34,380 --> 00:10:37,170
And today, we've launched
episodic memory as well,

221
00:10:37,170 --> 00:10:39,030
and we'll talk about it later.

222
00:10:39,030 --> 00:10:40,920
But the short-term and long-term memory,

223
00:10:40,920 --> 00:10:44,130
especially the conversational
and the operational context,

224
00:10:44,130 --> 00:10:46,023
is stored for agents.

225
00:10:47,550 --> 00:10:49,950
And your microservices architecture,

226
00:10:49,950 --> 00:10:52,380
becomes an extensible toolkit

227
00:10:52,380 --> 00:10:54,693
that agents can include via tools.

228
00:10:55,650 --> 00:10:57,990
And the last aspect is the learning.

229
00:10:57,990 --> 00:11:02,070
The agents improvise through
feedback loops every iteration

230
00:11:02,070 --> 00:11:03,750
of their execution.

231
00:11:03,750 --> 00:11:05,580
Now, here's the key difference.

232
00:11:05,580 --> 00:11:08,520
The old way you have to
hard code everything,

233
00:11:08,520 --> 00:11:12,660
call service A, then
service B, then service C.

234
00:11:12,660 --> 00:11:15,300
It's rigid, it's deterministic,

235
00:11:15,300 --> 00:11:17,220
it works until it doesn't.

236
00:11:17,220 --> 00:11:22,220
The new way is how you
actually give an agent a goal,

237
00:11:23,580 --> 00:11:26,520
something like reduce
incident response time,

238
00:11:26,520 --> 00:11:31,170
and it figures out which
services to call, in what order,

239
00:11:31,170 --> 00:11:33,150
and actually, what's happening,

240
00:11:33,150 --> 00:11:37,020
and train accordingly in
terms of what's happening

241
00:11:37,020 --> 00:11:38,020
in your environment.

242
00:11:43,890 --> 00:11:47,670
Let's talk about when you
should actually use AI agents.

243
00:11:47,670 --> 00:11:50,670
It's not about jumping
onto the hype train,

244
00:11:50,670 --> 00:11:53,910
it's about focusing on
three key principles.

245
00:11:53,910 --> 00:11:56,310
The first is start with real problem.

246
00:11:56,310 --> 00:11:58,740
Use cases like clinical
workflow automation

247
00:11:58,740 --> 00:12:00,570
for healthcare where agents,

248
00:12:00,570 --> 00:12:05,007
can proactively analyze your
patient medical history,

249
00:12:07,590 --> 00:12:11,400
identify trends and flag potential issues

250
00:12:11,400 --> 00:12:15,690
or market analyst agents
and financial services

251
00:12:15,690 --> 00:12:18,360
where it identifies the
market opportunities

252
00:12:18,360 --> 00:12:19,950
to reduce research time,

253
00:12:19,950 --> 00:12:21,810
so that the investment analysts,

254
00:12:21,810 --> 00:12:24,180
can focus on higher value strategic work,

255
00:12:24,180 --> 00:12:27,360
are some of the examples
of real use cases.

256
00:12:27,360 --> 00:12:29,910
Determine your key metrics,

257
00:12:29,910 --> 00:12:33,240
things like turnaround time reduction,

258
00:12:33,240 --> 00:12:35,760
staff productivity improvements,

259
00:12:35,760 --> 00:12:39,240
and time to insight are some
good examples of key metrics

260
00:12:39,240 --> 00:12:43,083
that you may want to define
as KPIs for your agents.

261
00:12:44,250 --> 00:12:47,460
And lastly, assess the potential impact.

262
00:12:47,460 --> 00:12:50,940
Consider both business value and risk.

263
00:12:50,940 --> 00:12:53,370
For business impact, things like ROI,

264
00:12:53,370 --> 00:12:55,260
which is return of investment,

265
00:12:55,260 --> 00:12:58,170
operational efficiency,
customer satisfaction,

266
00:12:58,170 --> 00:12:59,970
are some of the examples.

267
00:12:59,970 --> 00:13:01,560
And for risk assessment,

268
00:13:01,560 --> 00:13:04,950
think about what happens
when your agent fails.

269
00:13:04,950 --> 00:13:06,630
Do you have human in the loop?

270
00:13:06,630 --> 00:13:08,460
If not, what would it take to make sure

271
00:13:08,460 --> 00:13:11,310
that your services are seamless?

272
00:13:11,310 --> 00:13:14,430
So start with high impact problems,

273
00:13:14,430 --> 00:13:17,010
define metrics upfront,

274
00:13:17,010 --> 00:13:20,580
assess both upside and failure modes,

275
00:13:20,580 --> 00:13:22,380
and get these three things right

276
00:13:22,380 --> 00:13:24,453
and the technology becomes the easy part.

277
00:13:25,541 --> 00:13:28,170
Now I let Roland continue
with what it takes

278
00:13:28,170 --> 00:13:31,200
in terms of tools and
positioning the tools and agents.

279
00:13:31,200 --> 00:13:33,070
- Thank you, Mridula.

280
00:13:33,070 --> 00:13:34,650
So as we continue here,

281
00:13:34,650 --> 00:13:37,050
one of the things I just wanna follow up.

282
00:13:37,050 --> 00:13:38,190
To be honest, when we're talking

283
00:13:38,190 --> 00:13:40,620
about AI use cases and agents,

284
00:13:40,620 --> 00:13:44,970
oftentimes people or some of
the agents that we're building,

285
00:13:44,970 --> 00:13:46,890
it's a technology looking for a problem

286
00:13:46,890 --> 00:13:48,750
in some cases, right?

287
00:13:48,750 --> 00:13:53,750
The reality is business use
cases drive what you need to do.

288
00:13:53,910 --> 00:13:55,980
And it could be some
of it is deterministic,

289
00:13:55,980 --> 00:13:57,720
some of it is non-deterministic,

290
00:13:57,720 --> 00:13:59,970
the business problems live on their own.

291
00:13:59,970 --> 00:14:02,640
And then AI can kind of help automate,

292
00:14:02,640 --> 00:14:06,720
do certain things better, do
certain automations better.

293
00:14:06,720 --> 00:14:09,512
There's probably lots of
things you can look at

294
00:14:09,512 --> 00:14:10,920
at existing systems and take a look at

295
00:14:10,920 --> 00:14:13,200
that would be easy to automate with AI.

296
00:14:13,200 --> 00:14:16,830
If you ever build business
process workflow applications,

297
00:14:16,830 --> 00:14:20,520
you've probably seen big
branches of conditional code

298
00:14:20,520 --> 00:14:23,116
that goes into different leafs.

299
00:14:23,116 --> 00:14:26,283
Those are good opportunities
for agentic modernization.

300
00:14:27,180 --> 00:14:30,120
Let's talk a little bit
about building agents.

301
00:14:30,120 --> 00:14:33,030
More or less in a nutshell,
agents of piece of code,

302
00:14:33,030 --> 00:14:35,460
you might write it in Python, Strands.

303
00:14:35,460 --> 00:14:38,403
We just announced
Strands' TypeScript today,

304
00:14:38,403 --> 00:14:39,451
some really exciting.

305
00:14:39,451 --> 00:14:40,530
We write some agents in TypeScript.

306
00:14:40,530 --> 00:14:41,970
There's other frameworks,

307
00:14:41,970 --> 00:14:43,530
and you're really doing a combination

308
00:14:43,530 --> 00:14:44,760
of goals and instructions.

309
00:14:44,760 --> 00:14:47,400
So you have your system prompts,

310
00:14:47,400 --> 00:14:49,710
you have your tools,
your deterministic logic,

311
00:14:49,710 --> 00:14:51,900
we gave examples of that earlier.

312
00:14:51,900 --> 00:14:54,450
And then you have things in your context.

313
00:14:54,450 --> 00:14:57,690
Context engineering is really
becoming very strategic

314
00:14:57,690 --> 00:15:01,530
in guiding the agent in where
and what decisions to make,

315
00:15:01,530 --> 00:15:04,200
what tools to use, what data to go act

316
00:15:04,200 --> 00:15:06,030
or what actions to go after.

317
00:15:06,030 --> 00:15:08,010
As you build more and more agents,

318
00:15:08,010 --> 00:15:09,840
you get a lot, a lot of tools,

319
00:15:09,840 --> 00:15:11,310
and you need that context

320
00:15:11,310 --> 00:15:14,910
to really help your agent
make the right decisions.

321
00:15:14,910 --> 00:15:17,168
You wanna be able to guide the agents,

322
00:15:17,168 --> 00:15:18,330
you're right to make those decisions.

323
00:15:18,330 --> 00:15:20,100
And then you have observability.

324
00:15:20,100 --> 00:15:22,560
You wanna be able to measure
the results of the agents,

325
00:15:22,560 --> 00:15:24,750
make sure you're getting
the answers you want.

326
00:15:24,750 --> 00:15:27,390
Go beyond what you get in chatbot today,

327
00:15:27,390 --> 00:15:29,582
is like thumbs up, thumbs down.

328
00:15:29,582 --> 00:15:30,415
Did you like the answer?

329
00:15:30,415 --> 00:15:33,510
How do you do observability
and successful metrics

330
00:15:33,510 --> 00:15:35,430
in an observable way?

331
00:15:35,430 --> 00:15:38,133
These are some of the
challenges around that, right?

332
00:15:39,150 --> 00:15:41,940
Agents need tools and they need content.

333
00:15:41,940 --> 00:15:45,093
And there's different
ways to do this, right?

334
00:15:45,993 --> 00:15:48,180
There's web scraping,
navigation interactions,

335
00:15:48,180 --> 00:15:49,050
LLMs are good.

336
00:15:49,050 --> 00:15:51,180
There's techniques like LLMS text files

337
00:15:51,180 --> 00:15:55,230
that you can put into websites,
for example, to help models.

338
00:15:55,230 --> 00:15:57,300
You have workflows and automations

339
00:15:57,300 --> 00:15:59,070
that you need to do tasks.

340
00:15:59,070 --> 00:16:02,550
Usually, these are located
inside of MCP servers,

341
00:16:02,550 --> 00:16:05,490
that's what we wanna get out
of our existing applications.

342
00:16:05,490 --> 00:16:08,220
Then you have knowledge bases as well,

343
00:16:08,220 --> 00:16:09,990
and you have your existing data,

344
00:16:09,990 --> 00:16:12,570
and that data is structured
and unstructured.

345
00:16:12,570 --> 00:16:16,440
So this is definitely the things
that the agents work with.

346
00:16:16,440 --> 00:16:19,770
Some of those things,
again, are available there.

347
00:16:19,770 --> 00:16:21,840
I'm gonna give it back to Mridula

348
00:16:21,840 --> 00:16:23,690
to talk a little bit about MCP, yeah.

349
00:16:26,130 --> 00:16:27,693
- Thank you.

350
00:16:27,693 --> 00:16:29,760
All right, remember the early 2000s,

351
00:16:29,760 --> 00:16:33,450
every device had a
different power adapter?

352
00:16:33,450 --> 00:16:35,880
It used to be a nightmare
to manage all of those.

353
00:16:35,880 --> 00:16:37,710
Then USBC happened.

354
00:16:37,710 --> 00:16:40,290
And that's exactly what's
happening right now

355
00:16:40,290 --> 00:16:42,330
in the AI agentic space,

356
00:16:42,330 --> 00:16:44,880
especially when we have
so many agents talking

357
00:16:44,880 --> 00:16:46,740
to different tools and content.

358
00:16:46,740 --> 00:16:48,810
We need an adapter to make sure

359
00:16:48,810 --> 00:16:52,470
that all of this is
flowing through seamlessly.

360
00:16:52,470 --> 00:16:56,190
Model context protocol is an
open source protocol developed

361
00:16:56,190 --> 00:16:58,200
by anthropic and emerging

362
00:16:58,200 --> 00:17:00,630
to be a standard operating protocol along

363
00:17:00,630 --> 00:17:02,130
with the agent to agent.

364
00:17:02,130 --> 00:17:05,550
But specifically, when it comes
to agents talking to tools,

365
00:17:05,550 --> 00:17:08,460
MCP plays a critical role given the fact

366
00:17:08,460 --> 00:17:10,800
that MCP is better with respect

367
00:17:10,800 --> 00:17:13,175
to agentic tools communication.

368
00:17:13,175 --> 00:17:14,640
So we will dive deep on
this protocol followed

369
00:17:14,640 --> 00:17:17,520
by Roland taking over on A2A.

370
00:17:17,520 --> 00:17:21,630
So MCP follows a client
host server architecture

371
00:17:21,630 --> 00:17:23,400
for your agents.

372
00:17:23,400 --> 00:17:28,400
Firstly, the host has your
AI agents, LLMs, and IDs,

373
00:17:28,710 --> 00:17:31,950
that will be requesting
access to the data sources.

374
00:17:31,950 --> 00:17:34,620
Then you have the MCP client,

375
00:17:34,620 --> 00:17:37,140
which maintains the one-to-one connection

376
00:17:37,140 --> 00:17:39,120
with your MCP server.

377
00:17:39,120 --> 00:17:41,280
And an important thing to note here is,

378
00:17:41,280 --> 00:17:44,970
MCP client can establish
multiple transport layers,

379
00:17:44,970 --> 00:17:47,010
which means that you
can actually get a mix

380
00:17:47,010 --> 00:17:51,003
of deployment modes without
to rewrite agentic code.

381
00:17:51,870 --> 00:17:54,930
The MCP server is a lightweight program

382
00:17:54,930 --> 00:17:59,310
that exposes this capabilities
of your microservices

383
00:17:59,310 --> 00:18:02,070
through the standardized MCP protocol.

384
00:18:02,070 --> 00:18:04,500
And lastly, we have the data sources,

385
00:18:04,500 --> 00:18:08,340
both local resources
like databases and files,

386
00:18:08,340 --> 00:18:11,940
and remote services via
APIs can be accessed

387
00:18:11,940 --> 00:18:13,143
through the MCP server.

388
00:18:14,070 --> 00:18:16,680
So the key point to note here is MCP,

389
00:18:16,680 --> 00:18:20,190
is action-oriented and deterministic.

390
00:18:20,190 --> 00:18:23,940
All it takes care of is
the protocol translation,

391
00:18:23,940 --> 00:18:25,800
but not the decision-making.

392
00:18:25,800 --> 00:18:28,150
That's where your agents
come into the picture.

393
00:18:29,940 --> 00:18:31,770
Now, before MCP,

394
00:18:31,770 --> 00:18:35,460
building GenAI applications
was like a plumber in a house

395
00:18:35,460 --> 00:18:38,580
where every room has a
different pipe standard.

396
00:18:38,580 --> 00:18:42,210
Your application needs to call
GitHub, custom integration,

397
00:18:42,210 --> 00:18:44,820
Slack, another custom integration,

398
00:18:44,820 --> 00:18:47,373
your own databases, yet another one.

399
00:18:48,630 --> 00:18:51,330
Each with different
authentication methods,

400
00:18:51,330 --> 00:18:54,900
data formats, and communication protocols.

401
00:18:54,900 --> 00:18:57,330
So if you have about
five applications talking

402
00:18:57,330 --> 00:19:01,320
to 10 different tools, you
have 50 different integrations.

403
00:19:01,320 --> 00:19:02,670
And here's the kicker.

404
00:19:02,670 --> 00:19:05,970
When Slack updates its
API tomorrow morning,

405
00:19:05,970 --> 00:19:07,260
you'll end up rewriting

406
00:19:07,260 --> 00:19:11,280
that code across every single application

407
00:19:11,280 --> 00:19:12,990
that invokes the Slack.

408
00:19:12,990 --> 00:19:15,570
It's a nightmare to handle
the integration complexity

409
00:19:15,570 --> 00:19:18,170
and not exactly the future
that we've signed up for.

410
00:19:19,410 --> 00:19:23,970
With MCP, you get one unified API layer,

411
00:19:23,970 --> 00:19:28,500
your application needs or speaks
to one protocol that is MCP

412
00:19:28,500 --> 00:19:31,140
and the protocol handles the translation

413
00:19:31,140 --> 00:19:34,680
to each service's unique API.

414
00:19:34,680 --> 00:19:36,993
One integration point
for your application,

415
00:19:38,190 --> 00:19:40,470
but actually, standardized access

416
00:19:40,470 --> 00:19:42,720
to an expanding list of tools.

417
00:19:42,720 --> 00:19:46,020
And that's the fundamental
shift we are talking about,

418
00:19:46,020 --> 00:19:49,920
from custom integrations
to standardized simplicity,

419
00:19:49,920 --> 00:19:54,600
from spending weeks debugging
the authentication methods

420
00:19:54,600 --> 00:19:58,080
and API versioning to shipping AI features

421
00:19:58,080 --> 00:19:59,823
in hours if not days.

422
00:20:01,200 --> 00:20:03,300
Now, Roland is gonna cover the A2A.

423
00:20:03,300 --> 00:20:07,080
- Yeah, and so we wanted
to cover this a little bit.

424
00:20:07,080 --> 00:20:08,280
We're not gonna go too deep,

425
00:20:08,280 --> 00:20:11,130
but as we're thinking about microservices,

426
00:20:11,130 --> 00:20:14,070
one of the big things about microservices,

427
00:20:14,070 --> 00:20:15,990
was always reuse, right?

428
00:20:15,990 --> 00:20:18,813
How do I reuse my existing applications?

429
00:20:19,980 --> 00:20:21,750
Agents need to do the same thing.

430
00:20:21,750 --> 00:20:25,320
I need to build agents, and
they're used by other agents.

431
00:20:25,320 --> 00:20:27,090
That's how you build orchestration,

432
00:20:27,090 --> 00:20:28,890
non-deterministic workflows,

433
00:20:28,890 --> 00:20:30,930
calling other non-deterministic workflows,

434
00:20:30,930 --> 00:20:33,960
and A2A really addresses that problem.

435
00:20:33,960 --> 00:20:35,550
One, there's tons of agents out there,

436
00:20:35,550 --> 00:20:37,260
so how do I discover them?

437
00:20:37,260 --> 00:20:40,530
The A2A protocol has
a discovery mechanism.

438
00:20:40,530 --> 00:20:43,050
Task management, you have different agents

439
00:20:43,050 --> 00:20:44,490
that do different tasks.

440
00:20:44,490 --> 00:20:47,340
Collaboration, how do you
share things like context?

441
00:20:47,340 --> 00:20:50,550
How do you share things
like security, et cetera?

442
00:20:50,550 --> 00:20:52,350
And these are important things

443
00:20:52,350 --> 00:20:54,990
to talk about when you're building agents.

444
00:20:54,990 --> 00:20:57,390
You wanna think about your
agents the same way you think

445
00:20:57,390 --> 00:21:01,380
about microservices and
expose them to other agents

446
00:21:01,380 --> 00:21:03,570
and other orchestration, and other tools,

447
00:21:03,570 --> 00:21:04,830
and even frontends.

448
00:21:04,830 --> 00:21:07,470
Actually had a code talk earlier today,

449
00:21:07,470 --> 00:21:10,298
it's should be up on YouTube already.

450
00:21:10,298 --> 00:21:12,660
That kind of shows an
example of us taking an agent

451
00:21:12,660 --> 00:21:14,310
and exposing it through MCP

452
00:21:14,310 --> 00:21:16,263
and deploying it to AgentCore Runtime.

453
00:21:19,710 --> 00:21:22,230
So let's talk a little bit

454
00:21:22,230 --> 00:21:26,910
about now the process of going through

455
00:21:26,910 --> 00:21:30,000
and taking your existing applications,

456
00:21:30,000 --> 00:21:32,010
your existing microservices,

457
00:21:32,010 --> 00:21:34,470
exposing them through tools, right?

458
00:21:34,470 --> 00:21:37,170
You wanna define, describe your APIs.

459
00:21:37,170 --> 00:21:39,090
How many people used things like Swagger

460
00:21:39,090 --> 00:21:42,390
in the past to define RESTful APIs?

461
00:21:42,390 --> 00:21:46,050
Well, Mridula talked about
microservices principles earlier.

462
00:21:46,050 --> 00:21:47,820
The reality is,

463
00:21:47,820 --> 00:21:51,210
we probably haven't written
perfect microservices

464
00:21:51,210 --> 00:21:54,570
that have one data
source per microservice,

465
00:21:54,570 --> 00:21:55,950
and do all those things, right?

466
00:21:55,950 --> 00:21:58,980
We probably have a
combination of monoliths

467
00:21:58,980 --> 00:22:03,252
through microservices, and
maybe you don't have those APIs.

468
00:22:03,252 --> 00:22:05,400
You can use something
like Kiro to generate some

469
00:22:05,400 --> 00:22:10,230
of those OpenAPI's
Swagger documents, right?

470
00:22:10,230 --> 00:22:11,940
You want structured interfaces.

471
00:22:11,940 --> 00:22:16,940
So JSON, OpenAPI, gRPC or other metrics,

472
00:22:17,059 --> 00:22:18,822
you need security and guardrails.

473
00:22:18,822 --> 00:22:19,710
How do you access them?

474
00:22:19,710 --> 00:22:22,091
And then you need feedback loops,

475
00:22:22,091 --> 00:22:24,660
observability, retries, et cetera.

476
00:22:24,660 --> 00:22:28,620
Now, when we're getting into
exposing your microservices,

477
00:22:28,620 --> 00:22:33,620
there's choices, you can code
and write your own MCP servers

478
00:22:34,830 --> 00:22:37,740
in code, make it part of your application,

479
00:22:37,740 --> 00:22:39,390
maintain it with your code.

480
00:22:39,390 --> 00:22:40,950
There's nothing wrong with that.

481
00:22:40,950 --> 00:22:42,840
Oftentimes, why would you do that?

482
00:22:42,840 --> 00:22:47,840
You wanna take full
advantage of the MCP protocol

483
00:22:48,270 --> 00:22:49,320
in addition to tools.

484
00:22:49,320 --> 00:22:52,500
It has things like resources
and prompt templates.

485
00:22:52,500 --> 00:22:54,930
So you wanna be able to
standardize on those.

486
00:22:54,930 --> 00:22:58,140
You might code some special
purpose MCP servers,

487
00:22:58,140 --> 00:23:01,083
but when you have hundreds or
thousands of microservices,

488
00:23:01,950 --> 00:23:03,720
you may want an easy button.

489
00:23:03,720 --> 00:23:06,180
And that's why having something
like AgentCore Gateway,

490
00:23:06,180 --> 00:23:07,380
which we'll talk about,

491
00:23:07,380 --> 00:23:11,070
to kind of expose your
existing tools as MCP servers,

492
00:23:11,070 --> 00:23:14,790
might be a huge accelerator
for your existing systems.

493
00:23:14,790 --> 00:23:16,380
So you can kind of think about

494
00:23:16,380 --> 00:23:18,690
which MCP servers you wanna code,

495
00:23:18,690 --> 00:23:20,400
which ones you wanna expose,

496
00:23:20,400 --> 00:23:22,500
which ones you wanna combine, et cetera,

497
00:23:22,500 --> 00:23:24,003
and have those capabilities.

498
00:23:26,173 --> 00:23:28,470
A lot of the early MCP servers

499
00:23:28,470 --> 00:23:31,470
that were built out were read only, right?

500
00:23:31,470 --> 00:23:34,230
So we'd have an ordering
agent, pricing agent,

501
00:23:34,230 --> 00:23:37,950
you go to MCP Gateway,
you go get your promotions

502
00:23:37,950 --> 00:23:40,800
or list your promotions, et cetera,

503
00:23:40,800 --> 00:23:44,700
and then kind of goes into
your existing systems,

504
00:23:44,700 --> 00:23:48,660
access your presentation
layer or your REST APIs,

505
00:23:48,660 --> 00:23:51,630
your BFF services, best friends forever

506
00:23:51,630 --> 00:23:54,833
or backend for frontends,
that's what that means.

507
00:23:54,833 --> 00:23:55,710
And then kind of expose it.

508
00:23:55,710 --> 00:23:56,910
And that was easy.

509
00:23:56,910 --> 00:23:59,520
Some of the security
behind that's a bit easier.

510
00:23:59,520 --> 00:24:01,800
But now, things are evolving, right?

511
00:24:01,800 --> 00:24:05,748
So you know, you're gonna
have lots of existing APIs,

512
00:24:05,748 --> 00:24:08,670
you're gonna have lots of
existing MCP tools, right?

513
00:24:08,670 --> 00:24:12,510
Then you're gonna have MCP servers,

514
00:24:12,510 --> 00:24:14,310
and then you could expose them

515
00:24:14,310 --> 00:24:16,200
through a gateway to
make things a lot easier

516
00:24:16,200 --> 00:24:17,340
for you, right?

517
00:24:17,340 --> 00:24:20,850
There's different patterns
with MCP gateways, for example,

518
00:24:20,850 --> 00:24:22,410
you might wanna get REST APIs,

519
00:24:22,410 --> 00:24:25,770
you might have existing Lambda functions,

520
00:24:25,770 --> 00:24:29,040
you might have existing
MCP servers, et cetera.

521
00:24:29,040 --> 00:24:31,680
And we didn't catch the typo.

522
00:24:31,680 --> 00:24:34,590
My name was in the header there, oops.

523
00:24:34,590 --> 00:24:36,933
And so some design principles, right?

524
00:24:37,980 --> 00:24:40,590
When you're building
model-driven approach to agent,

525
00:24:40,590 --> 00:24:42,150
you wanna think about your consumers.

526
00:24:42,150 --> 00:24:43,380
We have developers.

527
00:24:43,380 --> 00:24:46,830
Some agents are gonna be
naturally consumed by developers.

528
00:24:46,830 --> 00:24:49,830
Some agents are gonna be
consumed by business users.

529
00:24:49,830 --> 00:24:51,960
I know we have a lot of
low code, no code tools,

530
00:24:51,960 --> 00:24:55,110
like Quick Suite, which is an
awesome way for your BI people

531
00:24:55,110 --> 00:24:57,090
to build agents and automation,

532
00:24:57,090 --> 00:24:59,760
against your different data sources.

533
00:24:59,760 --> 00:25:02,340
But you wanna be able to get and build

534
00:25:02,340 --> 00:25:04,680
for developers, simple code solutions.

535
00:25:04,680 --> 00:25:06,690
You want reasoning capabilities,

536
00:25:06,690 --> 00:25:09,123
and you want model and deployment choices.

537
00:25:10,920 --> 00:25:14,130
So the reality is building agents is hard.

538
00:25:14,130 --> 00:25:17,520
I say building them, building examples,

539
00:25:17,520 --> 00:25:20,190
building POCs are fairly easy.

540
00:25:20,190 --> 00:25:22,410
Getting them to production is hard,

541
00:25:22,410 --> 00:25:24,750
learning all the best practices is hard.

542
00:25:24,750 --> 00:25:26,977
You have to start thinking
about things like,

543
00:25:26,977 --> 00:25:29,760
"I have hundreds and
hundreds of MCP tools,

544
00:25:29,760 --> 00:25:32,010
and then I send a request,

545
00:25:32,010 --> 00:25:35,400
I said, 'Give me a list
of tools, da da da da.'

546
00:25:35,400 --> 00:25:36,510
I get the answer back,

547
00:25:36,510 --> 00:25:40,110
and then I tell the chat
agent, 'Thank you.'"

548
00:25:40,110 --> 00:25:40,943
What's it gonna do?

549
00:25:40,943 --> 00:25:42,780
It's gonna send thank you
back with the list of tools

550
00:25:42,780 --> 00:25:43,860
and the context.

551
00:25:43,860 --> 00:25:45,450
You don't wanna pay for the tokens

552
00:25:45,450 --> 00:25:47,340
for the list of tools and build that up.

553
00:25:47,340 --> 00:25:49,290
Lots of different new best practices

554
00:25:49,290 --> 00:25:51,750
that are emerging around those things.

555
00:25:51,750 --> 00:25:55,500
And so we control
guardrails, all these things,

556
00:25:55,500 --> 00:25:58,290
limited visibility,
observability is a challenge.

557
00:25:58,290 --> 00:25:59,580
Things are generated,

558
00:25:59,580 --> 00:26:01,530
you get responses, they're dynamic.

559
00:26:01,530 --> 00:26:04,650
It's really hard to observe
dynamic code, right?

560
00:26:04,650 --> 00:26:08,040
So it's challenging, it's
hard to maintain, why?

561
00:26:08,040 --> 00:26:09,660
Because models keep coming out,

562
00:26:09,660 --> 00:26:11,403
new versions of models come out,

563
00:26:12,238 --> 00:26:14,250
and you start building up
a prompt library of things

564
00:26:14,250 --> 00:26:16,050
to test answers.

565
00:26:16,050 --> 00:26:18,600
And then you know, brand
new model comes out,

566
00:26:18,600 --> 00:26:21,000
you run your tests and all
the answers are off, right?

567
00:26:21,000 --> 00:26:25,590
So DevOps and MLOps crashing
together, different things.

568
00:26:25,590 --> 00:26:28,890
And so Strands really
helps with a lot of this.

569
00:26:28,890 --> 00:26:31,440
Mridula, you wanna talk a
little bit about Strands?

570
00:26:33,060 --> 00:26:35,550
- All right, let's talk
about Strands Agents.

571
00:26:35,550 --> 00:26:38,550
Strands Agents is an open source SDK,

572
00:26:38,550 --> 00:26:43,080
that lets you build AI agents
in just a few lines of code.

573
00:26:43,080 --> 00:26:46,770
Amazon has actually built this

574
00:26:46,770 --> 00:26:48,660
and published this as an open source.

575
00:26:48,660 --> 00:26:52,110
No complex workflows, no
orchestration nightmares,

576
00:26:52,110 --> 00:26:55,260
just you, a prompt, and a list of tools.

577
00:26:55,260 --> 00:26:57,480
Why should you use Strands?

578
00:26:57,480 --> 00:26:59,850
Let's start with ease of use.

579
00:26:59,850 --> 00:27:02,610
Remember the last time you
tried to build an agent,

580
00:27:02,610 --> 00:27:03,660
and spend three days,

581
00:27:03,660 --> 00:27:06,150
figuring out the orchestration framework?

582
00:27:06,150 --> 00:27:09,300
With Strands, it's just
four lines of code.

583
00:27:09,300 --> 00:27:12,390
You've got a working agent, no YAML files,

584
00:27:12,390 --> 00:27:14,790
no complex configuration,

585
00:27:14,790 --> 00:27:17,820
no sacrificing your
weekend to stack overflow.

586
00:27:17,820 --> 00:27:22,020
Internally, our Amazon Q developer team,

587
00:27:22,020 --> 00:27:25,650
used Strands to publish our agentic chat

588
00:27:25,650 --> 00:27:27,030
in just three weeks,

589
00:27:27,030 --> 00:27:31,470
and GitLab Duo integration
in just six weeks.

590
00:27:31,470 --> 00:27:35,460
What previously took months,
now just takes weeks.

591
00:27:35,460 --> 00:27:36,720
And that's the difference between

592
00:27:36,720 --> 00:27:39,270
we'll have them ship next quarter,

593
00:27:39,270 --> 00:27:42,540
versus we've already
shipped them last Tuesday.

594
00:27:42,540 --> 00:27:45,060
When it comes to robust capabilities,

595
00:27:45,060 --> 00:27:49,200
Strands comes with about
more than 20 prebuilt tools,

596
00:27:49,200 --> 00:27:52,770
whether it's file requests, web services,

597
00:27:52,770 --> 00:27:56,100
operations, and custom integration

598
00:27:56,100 --> 00:27:58,830
with AWS service tools directly.

599
00:27:58,830 --> 00:28:02,370
So if you want to integrate directly

600
00:28:02,370 --> 00:28:05,550
with Glue or Amazon VPC
Reachability Analyzer,

601
00:28:05,550 --> 00:28:10,110
or even a Snowflake database,
MCP got you covered there,

602
00:28:10,110 --> 00:28:12,450
and Strands got you
covered there through MCP.

603
00:28:12,450 --> 00:28:15,270
Because Strands comes
with a native MCP support,

604
00:28:15,270 --> 00:28:16,930
and we've also recently launched

605
00:28:17,869 --> 00:28:20,100
eight-way support for Strands.

606
00:28:20,100 --> 00:28:22,980
Extensibility is where
Strands really shine,

607
00:28:22,980 --> 00:28:27,390
because you are not locked in
on one single-model provider.

608
00:28:27,390 --> 00:28:31,350
You can use Amazon's
Bedrock, Anthropic's Claude,

609
00:28:31,350 --> 00:28:36,090
or any other Mistral AI or
Stability AI model provider,

610
00:28:36,090 --> 00:28:37,200
the choice is yours.

611
00:28:37,200 --> 00:28:40,770
And we have support over
100 LLM providers there.

612
00:28:40,770 --> 00:28:45,060
So rapid development means
you get to go from idea

613
00:28:45,060 --> 00:28:48,060
to working prototype in minutes, not days.

614
00:28:48,060 --> 00:28:51,720
You can test easily on local machines.

615
00:28:51,720 --> 00:28:55,683
It read fast and deploy to
production whenever you're ready.

616
00:28:57,450 --> 00:29:01,320
So given the agents
are autonomous systems,

617
00:29:01,320 --> 00:29:03,540
even building a basic agent,

618
00:29:03,540 --> 00:29:08,130
requires piecing together
numerous complex components,

619
00:29:08,130 --> 00:29:11,430
such as orchestration, tool execution,

620
00:29:11,430 --> 00:29:13,380
and state management.

621
00:29:13,380 --> 00:29:17,237
Open source frameworks
like LangGraph, CrewAI,

622
00:29:17,237 --> 00:29:18,870
and Strand Agents are making it easy

623
00:29:18,870 --> 00:29:22,650
for developers to get
started and build prototypes.

624
00:29:22,650 --> 00:29:23,760
While these frameworks,

625
00:29:23,760 --> 00:29:27,390
have simplified building
a working agent prototype,

626
00:29:27,390 --> 00:29:31,350
developers still hit a
brick wall when you attempt

627
00:29:31,350 --> 00:29:33,600
to actually build an application

628
00:29:33,600 --> 00:29:37,413
that can scale to millions
of end users in production.

629
00:29:38,460 --> 00:29:42,150
So I let Roland unpack the key components

630
00:29:42,150 --> 00:29:44,328
and the challenges that we are facing

631
00:29:44,328 --> 00:29:46,143
and how AWS can actually help.

632
00:29:51,810 --> 00:29:52,643
- Thank you, Mridula.

633
00:29:52,643 --> 00:29:54,720
So let's get a little bit,

634
00:29:54,720 --> 00:29:56,550
we've already talked about AgentCore,

635
00:29:56,550 --> 00:29:58,710
which we announced earlier in the year,

636
00:29:58,710 --> 00:30:01,440
obviously, missing from
here is the new policy

637
00:30:01,440 --> 00:30:03,870
and the gateway and the
valuation frameworks.

638
00:30:03,870 --> 00:30:08,850
But AgentCore, we built
it in a very specific way.

639
00:30:08,850 --> 00:30:10,050
When we think about platforms,

640
00:30:10,050 --> 00:30:13,470
we know a lot of our
customers build platforms,

641
00:30:13,470 --> 00:30:15,060
and they have different choices.

642
00:30:15,060 --> 00:30:16,410
So we build AgentCore in a way

643
00:30:16,410 --> 00:30:20,130
that you can use the different
pieces interchangeably

644
00:30:20,130 --> 00:30:21,000
in different ways.

645
00:30:21,000 --> 00:30:23,280
So you don't have to use all of it,

646
00:30:23,280 --> 00:30:26,347
but if you use all of it,
you get a lot of advantages.

647
00:30:26,347 --> 00:30:28,290
AgentCore Runtime, which you get into,

648
00:30:28,290 --> 00:30:30,900
provides a serverless runtime environment

649
00:30:30,900 --> 00:30:32,520
for you to build agents.

650
00:30:32,520 --> 00:30:35,520
We have Memory, so we talked
about things like short-term,

651
00:30:35,520 --> 00:30:36,840
long-term summary,

652
00:30:36,840 --> 00:30:39,120
episodic, which was just announced today.

653
00:30:39,120 --> 00:30:41,340
All these different
patterns that were emerging.

654
00:30:41,340 --> 00:30:44,700
Identity, which allows us to securely,

655
00:30:44,700 --> 00:30:48,240
have our agents access
securely and also access tools

656
00:30:48,240 --> 00:30:50,910
and third-party agents securely as well.

657
00:30:50,910 --> 00:30:53,730
AgentCore Gateway, which
we're gonna get into deeper,

658
00:30:53,730 --> 00:30:57,300
really, is the ability to expose
your existing MCP servers,

659
00:30:57,300 --> 00:31:01,470
your existing APIs, lambda
functions and integrations

660
00:31:01,470 --> 00:31:02,910
to your agents.

661
00:31:02,910 --> 00:31:04,230
Code Interpreter, it'll let you,

662
00:31:04,230 --> 00:31:06,810
as a lot of agents generate code,

663
00:31:06,810 --> 00:31:08,010
run it on the fly.

664
00:31:08,010 --> 00:31:10,650
You wanna do that in a
safe sandbox environment,

665
00:31:10,650 --> 00:31:13,629
and a set of browser
tools and Observability

666
00:31:13,629 --> 00:31:17,190
to help you see how your agents
are performing and doing.

667
00:31:17,190 --> 00:31:21,390
And so with Amazon
Bedrock AgentCore, right,

668
00:31:21,390 --> 00:31:22,950
you can build with the Runtime,

669
00:31:22,950 --> 00:31:25,830
you can have tools discovered
easily semantically

670
00:31:25,830 --> 00:31:27,930
through the gateway with semantic search.

671
00:31:27,930 --> 00:31:30,180
Saves a lot of money in token costs,

672
00:31:30,180 --> 00:31:33,600
short-term and long-term
memory, episodic as well.

673
00:31:33,600 --> 00:31:36,750
And summaries end-to-end
tracing and visibility,

674
00:31:36,750 --> 00:31:38,340
and full-managed browser tools

675
00:31:38,340 --> 00:31:40,203
and code interpreter capabilities.

676
00:31:41,820 --> 00:31:43,980
Get a little bit deeper when we're talking

677
00:31:43,980 --> 00:31:46,501
about applications, right?

678
00:31:46,501 --> 00:31:48,360
You wanna have an application,
wanna have an agent,

679
00:31:48,360 --> 00:31:50,010
you wanna use your favorite framework

680
00:31:50,010 --> 00:31:52,920
as Mridula talked about, such as Strands,

681
00:31:52,920 --> 00:31:55,710
TypeScript announced
today release, woo-hoo.

682
00:31:55,710 --> 00:31:58,770
For those people that don't
always wanna do Python,

683
00:31:58,770 --> 00:32:01,680
deploy that into your
serverless environment.

684
00:32:01,680 --> 00:32:03,420
Talk to any model that you want,

685
00:32:03,420 --> 00:32:07,290
can be hosted on Bedrock
with all the model choices.

686
00:32:07,290 --> 00:32:10,710
Could be hosted in silicon
like Trainium, et cetera,

687
00:32:10,710 --> 00:32:13,380
Trainium3, NVIDIA instances, et cetera.

688
00:32:13,380 --> 00:32:16,410
Then you have AgentCore
Memory for the patterns,

689
00:32:16,410 --> 00:32:19,830
ready for production, AgentCore
Observability, Identity,

690
00:32:19,830 --> 00:32:22,530
all your tools and your
existing applications,

691
00:32:22,530 --> 00:32:24,938
and your interpreter and browser.

692
00:32:24,938 --> 00:32:25,771
This is really exciting

693
00:32:25,771 --> 00:32:28,530
because we find getting to
production is a challenge.

694
00:32:28,530 --> 00:32:31,800
We think we build a really
good end-to-end environment

695
00:32:31,800 --> 00:32:34,800
in a modular way to help
you get to production.

696
00:32:34,800 --> 00:32:38,010
We have lots of customers
already in production with agents

697
00:32:38,010 --> 00:32:39,390
with tons of different customers.

698
00:32:39,390 --> 00:32:42,360
So Gateway, we have a nice
little animation there.

699
00:32:42,360 --> 00:32:43,680
We're going to, I think,

700
00:32:43,680 --> 00:32:45,780
Mridula surprised me with the animation.

701
00:32:45,780 --> 00:32:48,420
So you know, we have the gateway,

702
00:32:48,420 --> 00:32:51,960
which we're gonna kind of
concentrate into, right?

703
00:32:51,960 --> 00:32:55,470
AgentCore Runtime, really
exciting, serverless.

704
00:32:55,470 --> 00:32:58,680
So, but you can take your
existing application,

705
00:32:58,680 --> 00:33:00,750
all you have to do is
put it in a container.

706
00:33:00,750 --> 00:33:03,360
You could also do it just the code itself.

707
00:33:03,360 --> 00:33:05,940
There's a zip, a faster
way to do it as well.

708
00:33:05,940 --> 00:33:09,030
But a lot of customers
like to deploy containers.

709
00:33:09,030 --> 00:33:10,560
They have a DevOps pipeline

710
00:33:10,560 --> 00:33:12,480
that knows how to publish to ECR.

711
00:33:12,480 --> 00:33:14,940
So you can keep your existing DevOps,

712
00:33:14,940 --> 00:33:17,310
deploy your agent as a container,

713
00:33:17,310 --> 00:33:19,920
and then it's automatically
deployed and running.

714
00:33:19,920 --> 00:33:21,630
There's a lot of coding talks this week.

715
00:33:21,630 --> 00:33:24,720
Please go see them online if you haven't,

716
00:33:24,720 --> 00:33:27,180
especially the one I
just did earlier today.

717
00:33:27,180 --> 00:33:30,060
Use case independent, very
much like microservices,

718
00:33:30,060 --> 00:33:33,150
secure, isolated and isolated environment

719
00:33:33,150 --> 00:33:35,130
so that your agent can run

720
00:33:35,130 --> 00:33:37,893
without having security
boundaries crossed.

721
00:33:39,000 --> 00:33:40,560
And so it's very simple, right?

722
00:33:40,560 --> 00:33:43,770
You take your agent,
your tools and your code,

723
00:33:43,770 --> 00:33:45,510
you write your code, your decorators,

724
00:33:45,510 --> 00:33:48,990
your different applications,
you configure a docker file,

725
00:33:48,990 --> 00:33:53,100
push it into ECR, automatically
your runtime agent is there.

726
00:33:53,100 --> 00:33:55,200
Your endpoints, which could be A2A,

727
00:33:55,200 --> 00:33:57,210
could be other types of endpoints as well,

728
00:33:57,210 --> 00:33:59,810
and your application can
invoke it, nice and simple.

729
00:34:01,080 --> 00:34:02,250
AgentCore Gateway.

730
00:34:02,250 --> 00:34:04,950
Now, AgentCore Gateway is fairly exciting.

731
00:34:04,950 --> 00:34:07,620
We had a session earlier
today, like I said,

732
00:34:07,620 --> 00:34:09,930
where you can take your applications,

733
00:34:09,930 --> 00:34:12,690
your tools, and expose your APIs,

734
00:34:12,690 --> 00:34:15,360
OpenAPI and Smithy are examples of that,

735
00:34:15,360 --> 00:34:17,460
but just I just opened the account,

736
00:34:17,460 --> 00:34:19,590
and I saw API Gateway is in there as well.

737
00:34:19,590 --> 00:34:22,320
So your AgentCore Gateway can access APIs,

738
00:34:22,320 --> 00:34:24,810
and API Gateway integrations,

739
00:34:24,810 --> 00:34:28,350
or third-party MCP servers
that already exist.

740
00:34:28,350 --> 00:34:31,650
This gives you a unified point
in your organization to say,

741
00:34:31,650 --> 00:34:34,470
hey, these are supported, secured,

742
00:34:34,470 --> 00:34:36,420
verified MCP tools.

743
00:34:36,420 --> 00:34:38,458
With the new policy engine,

744
00:34:38,458 --> 00:34:39,600
you can have security policies there.

745
00:34:39,600 --> 00:34:41,640
You could say these tools
can only be executed

746
00:34:41,640 --> 00:34:44,340
by these agents, and these
different types of patterns

747
00:34:44,340 --> 00:34:46,560
that you want with a certain contact.

748
00:34:46,560 --> 00:34:48,450
And then you have semantic search.

749
00:34:48,450 --> 00:34:50,640
Semantic search is really important

750
00:34:50,640 --> 00:34:52,620
because you can write an application

751
00:34:52,620 --> 00:34:55,770
to do a semantic search
across thousands of tools

752
00:34:55,770 --> 00:34:57,930
that won't send all of that to the LLM.

753
00:34:57,930 --> 00:35:00,420
Instead, it'll give you
back the tools you want,

754
00:35:00,420 --> 00:35:01,590
and save money,

755
00:35:01,590 --> 00:35:06,180
especially you could send
the list of tools to the LLM,

756
00:35:06,180 --> 00:35:08,010
let the LLM kind of determined.

757
00:35:08,010 --> 00:35:09,870
But again, you're using a lot of tokens,

758
00:35:09,870 --> 00:35:13,800
and if your application knows
what tools it needs to use,

759
00:35:13,800 --> 00:35:16,800
that's a great pattern for you
to optimize and save money.

760
00:35:16,800 --> 00:35:18,990
That's why we have intelligent discovery,

761
00:35:18,990 --> 00:35:20,940
right, very simple.

762
00:35:20,940 --> 00:35:24,270
You create a gateway instance,

763
00:35:24,270 --> 00:35:26,130
you attach it to an identity provider

764
00:35:26,130 --> 00:35:28,050
with AgentCore Identity, right?

765
00:35:28,050 --> 00:35:29,460
You give it a target.

766
00:35:29,460 --> 00:35:30,360
In this case,

767
00:35:30,360 --> 00:35:34,140
we're talking about existing
RESTful service endpoints.

768
00:35:34,140 --> 00:35:36,300
So here's an example of that.

769
00:35:36,300 --> 00:35:39,150
And then you go and use semantic search

770
00:35:39,150 --> 00:35:40,560
or use the application, say, list,

771
00:35:40,560 --> 00:35:43,020
and invoke the tools, and you just use it,

772
00:35:43,020 --> 00:35:44,613
fairly simple configuration.

773
00:35:45,870 --> 00:35:47,790
That's kind of the key with that.

774
00:35:47,790 --> 00:35:51,000
You also can do the same
pattern with Lambda.

775
00:35:51,000 --> 00:35:52,560
We have lots, how many people have lots

776
00:35:52,560 --> 00:35:54,710
of Lambda functions
deployed in production.

777
00:35:56,430 --> 00:35:58,680
Lots, right, so you have your Lambda code,

778
00:35:58,680 --> 00:35:59,880
your Lambda targets.

779
00:35:59,880 --> 00:36:02,760
Lambda could be a good
quick way to stitch things

780
00:36:02,760 --> 00:36:04,980
and support patterns that
we might not support yet.

781
00:36:04,980 --> 00:36:08,046
For example, you might have private APIs

782
00:36:08,046 --> 00:36:10,380
that are not accessible
through a VPC, et cetera.

783
00:36:10,380 --> 00:36:12,660
You can use Lambda to
kind of bridge those gaps

784
00:36:12,660 --> 00:36:14,220
and things like that as well.

785
00:36:14,220 --> 00:36:16,710
Lambda's a great stitching tool for that.

786
00:36:16,710 --> 00:36:20,850
It supports things like OAuth
with AgentCore Identity.

787
00:36:20,850 --> 00:36:23,280
We actually showed the code for this

788
00:36:23,280 --> 00:36:26,790
in the API gateway with
containers application

789
00:36:26,790 --> 00:36:29,880
where we actually use the Python decorator

790
00:36:29,880 --> 00:36:32,640
as we create the gateway
to refresh the token.

791
00:36:32,640 --> 00:36:35,250
AgentCore Identity kind of
gives you these patterns

792
00:36:35,250 --> 00:36:37,530
to do that very simply and very easily.

793
00:36:37,530 --> 00:36:40,950
And of course, using AWS IAM to do that,

794
00:36:40,950 --> 00:36:44,070
Identity gives you that
security capability for it.

795
00:36:44,070 --> 00:36:46,680
Very similar, RESTful APIs

796
00:36:46,680 --> 00:36:50,310
as well as other patterns like
Smithy and semantic search.

797
00:36:50,310 --> 00:36:54,010
This is really, really huge to save money

798
00:36:55,080 --> 00:36:57,660
if your agents know which
tools they wanna do,

799
00:36:57,660 --> 00:36:59,640
get your list of MCP tools,

800
00:36:59,640 --> 00:37:01,770
ask you questions, do semantic search,

801
00:37:01,770 --> 00:37:03,960
and be able to get the different tools

802
00:37:03,960 --> 00:37:06,390
that you might wanna
use in your application.

803
00:37:06,390 --> 00:37:09,210
Search, you get back the
four most relevant tools

804
00:37:09,210 --> 00:37:11,673
that you wanna use for your application.

805
00:37:12,510 --> 00:37:15,600
You know, you might ask an
LLM to do this initially,

806
00:37:15,600 --> 00:37:17,490
but you really wanna save money

807
00:37:17,490 --> 00:37:19,590
and be important there as well.

808
00:37:19,590 --> 00:37:20,790
Gonna hand it over.

809
00:37:20,790 --> 00:37:22,320
We're doing a switch on purpose.

810
00:37:22,320 --> 00:37:24,480
We thought it would be
funner to do it this way

811
00:37:24,480 --> 00:37:25,880
because we're being agentic.

812
00:37:28,474 --> 00:37:29,640
- All right, here's the challenge

813
00:37:29,640 --> 00:37:32,070
with agents and microservices.

814
00:37:32,070 --> 00:37:35,610
Traditional microservices
are stateless by design.

815
00:37:35,610 --> 00:37:39,480
They don't remember anything
between the interactions,

816
00:37:39,480 --> 00:37:44,480
but AI agents need
context to be effective.

817
00:37:45,330 --> 00:37:49,833
Without memory, your agent
starts from scratch every time,

818
00:37:50,820 --> 00:37:53,130
leading to repetitive questions,

819
00:37:53,130 --> 00:37:56,460
slower responses, and higher costs,

820
00:37:56,460 --> 00:37:58,440
as you pass the context

821
00:37:58,440 --> 00:38:01,113
and the same context over
and over to your LLM.

822
00:38:02,790 --> 00:38:05,730
AgentCore Memory solves this
by automatically storing

823
00:38:05,730 --> 00:38:09,270
and indexing your agent's interactions

824
00:38:09,270 --> 00:38:11,370
in a serverless architecture.

825
00:38:11,370 --> 00:38:14,910
As a result, it reduces
the amount of context

826
00:38:14,910 --> 00:38:16,980
that you need to pass to the LLM,

827
00:38:16,980 --> 00:38:19,440
which means faster responses,

828
00:38:19,440 --> 00:38:22,020
better accuracy, lower costs,

829
00:38:22,020 --> 00:38:25,440
all while maintaining
enterprise-grade security

830
00:38:25,440 --> 00:38:27,243
with encrypted data isolation.

831
00:38:30,450 --> 00:38:32,670
So AgentCore Memory works very similar

832
00:38:32,670 --> 00:38:35,730
to how human brain remembers information

833
00:38:35,730 --> 00:38:38,583
through context and associations.

834
00:38:39,720 --> 00:38:44,010
Short-term memory handles
your immediate context,

835
00:38:44,010 --> 00:38:47,340
like chat messages and session state,

836
00:38:47,340 --> 00:38:50,520
keeping track of what's
happening right now

837
00:38:50,520 --> 00:38:51,903
in the conversation.

838
00:38:52,830 --> 00:38:56,700
Long-term memory is where the
real intelligence emerges.

839
00:38:56,700 --> 00:38:59,310
It stores the semantic information,

840
00:38:59,310 --> 00:39:02,190
user preferences and summaries

841
00:39:02,190 --> 00:39:04,260
that persisted across sessions,

842
00:39:04,260 --> 00:39:08,610
and episodic memory captures
specific preferences

843
00:39:08,610 --> 00:39:12,750
and experiences and
events with their temporal

844
00:39:12,750 --> 00:39:15,120
and contextual interactions,

845
00:39:15,120 --> 00:39:18,660
like remembering particular conversations,

846
00:39:18,660 --> 00:39:21,600
what decisions were made or problem solved

847
00:39:21,600 --> 00:39:23,043
in that past interaction.

848
00:39:24,000 --> 00:39:28,290
The magic is in the
automatic memory extraction.

849
00:39:28,290 --> 00:39:30,970
The system asynchronously processes

850
00:39:32,130 --> 00:39:33,930
and organizes this memory

851
00:39:33,930 --> 00:39:38,880
so you and your agent can
actually retrieve relevant context

852
00:39:38,880 --> 00:39:43,620
from past interactions without you having

853
00:39:43,620 --> 00:39:45,750
to manage any infrastructure.

854
00:39:45,750 --> 00:39:47,550
That's the key aspect.

855
00:39:47,550 --> 00:39:51,960
This means your agent learns
and improves over time.

856
00:39:51,960 --> 00:39:56,820
Remembering user preferences
improvise past solutions

857
00:39:56,820 --> 00:39:59,310
and the specific journey of interactions

858
00:39:59,310 --> 00:40:01,533
that lead to the successful outcomes.

859
00:40:05,100 --> 00:40:07,200
Here's a fundamental
challenge when it comes

860
00:40:07,200 --> 00:40:10,170
to AI agents and microservices

861
00:40:10,170 --> 00:40:12,170
that are set up in a distributed system.

862
00:40:13,230 --> 00:40:16,230
And when it's calling enterprise services,

863
00:40:16,230 --> 00:40:21,230
whether it's GitHub, Salesforce,
or even AWS Resources,

864
00:40:22,299 --> 00:40:25,830
you're dealing with a complex
web of authentication methods.

865
00:40:25,830 --> 00:40:27,930
Traditional approaches force you

866
00:40:27,930 --> 00:40:31,170
to build custom authentication flows

867
00:40:31,170 --> 00:40:34,650
for each service and migrate users,

868
00:40:34,650 --> 00:40:36,930
or even create token management systems

869
00:40:36,930 --> 00:40:38,133
that are often brittle.

870
00:40:39,540 --> 00:40:41,430
AgentCore Identity solves this

871
00:40:41,430 --> 00:40:44,820
by providing secure delegated access,

872
00:40:44,820 --> 00:40:46,893
across your entire enterprise.

873
00:40:48,780 --> 00:40:52,320
And this is done by providing
secure delegated access,

874
00:40:52,320 --> 00:40:56,197
across different services,
whether it's Okta

875
00:40:58,350 --> 00:41:01,620
or Microsoft Entra ID,
or even Amazon Cognito.

876
00:41:01,620 --> 00:41:04,110
You don't have to migrate users.

877
00:41:04,110 --> 00:41:06,720
All you have to do is make sure

878
00:41:06,720 --> 00:41:08,010
that you have your credentials,

879
00:41:08,010 --> 00:41:11,133
whether it's through the
keys or the IAM roles,

880
00:41:12,450 --> 00:41:15,840
and you can accelerate your
agent development without having

881
00:41:15,840 --> 00:41:18,790
to rebuild your authentication
infrastructure through this.

882
00:41:20,370 --> 00:41:24,150
Now, the authentication
works in two directions,

883
00:41:24,150 --> 00:41:26,190
both inbound and outbound.

884
00:41:26,190 --> 00:41:30,540
Inbound authentication handles
how users and applications

885
00:41:30,540 --> 00:41:35,540
in your microservices
actually invoke your agents,

886
00:41:35,550 --> 00:41:39,600
whether it's through IAM or AWS resources.

887
00:41:39,600 --> 00:41:42,300
And this is where
AgentCore Gateway validates

888
00:41:42,300 --> 00:41:45,990
who's calling your agent
even if they're allowed

889
00:41:45,990 --> 00:41:47,013
to do so or not.

890
00:41:48,060 --> 00:41:51,720
Outbound authentication is
where your agent authentication

891
00:41:51,720 --> 00:41:54,960
to external resources
and services are done

892
00:41:54,960 --> 00:41:56,700
on behalf of the user.

893
00:41:56,700 --> 00:42:00,090
And when your agent needs
to call the GitHub API

894
00:42:00,090 --> 00:42:02,010
or query Salesforce,

895
00:42:02,010 --> 00:42:05,220
or even access your AWS Lambda functions,

896
00:42:05,220 --> 00:42:07,440
it uses the appropriate credentials,

897
00:42:07,440 --> 00:42:11,370
whether it's OAuth tokens
or API keys or IAM roles

898
00:42:11,370 --> 00:42:15,630
that we discussed, all managed
through a secure token vault.

899
00:42:15,630 --> 00:42:16,463
And the beauty is

900
00:42:16,463 --> 00:42:20,520
that AgentCore Gateway handles
both inbound and outbound

901
00:42:20,520 --> 00:42:24,180
with a prebuilt-in
authentication and observability,

902
00:42:24,180 --> 00:42:26,400
so you get the enterprise grade security

903
00:42:26,400 --> 00:42:27,903
without any custom code.

904
00:42:30,750 --> 00:42:33,930
Now, agents are
non-deterministic by nature.

905
00:42:33,930 --> 00:42:36,180
They make autonomous decisions,

906
00:42:36,180 --> 00:42:41,040
call multiple tools, and
execute complex workflows.

907
00:42:41,040 --> 00:42:44,910
Without visibility, you are
actually flying blind here.

908
00:42:44,910 --> 00:42:48,450
And when something goes
wrong, you can't debug it.

909
00:42:48,450 --> 00:42:51,900
When performance degrades,
you cannot diagnose it.

910
00:42:51,900 --> 00:42:54,720
And when you need to
maintain quality and trust

911
00:42:54,720 --> 00:42:58,773
with your end user, you have
no evidence to show them.

912
00:42:59,940 --> 00:43:03,300
This is where AgentCore
Observability solves this

913
00:43:03,300 --> 00:43:07,050
by providing comprehensive
observability and visibility

914
00:43:07,050 --> 00:43:10,650
into agent execution
and operational metrics,

915
00:43:10,650 --> 00:43:13,470
across all AgentCore services.

916
00:43:13,470 --> 00:43:18,030
You get real-time dashboards
that centralize agent health

917
00:43:18,030 --> 00:43:21,603
and performance for
faster issue resolution.

918
00:43:22,680 --> 00:43:26,400
And you can accelerate
your debugging capabilities

919
00:43:26,400 --> 00:43:31,400
to quickly detect issues and
assess performance trends.

920
00:43:33,480 --> 00:43:36,930
Custom attributes and
metadata are something

921
00:43:36,930 --> 00:43:38,670
that you can actually customize.

922
00:43:38,670 --> 00:43:42,360
And we've recently launched
AgentCore Evaluations,

923
00:43:42,360 --> 00:43:47,360
where it enables to systematically
assess agent quality

924
00:43:47,400 --> 00:43:48,720
through success criteria

925
00:43:48,720 --> 00:43:51,813
that you can actually
configure through evaluations.

926
00:43:56,100 --> 00:43:58,020
Now, how the system works is

927
00:43:58,020 --> 00:44:00,870
through a centralized
observability architecture

928
00:44:00,870 --> 00:44:02,880
that collects the telemetry

929
00:44:02,880 --> 00:44:04,740
from all the AgentCore components,

930
00:44:04,740 --> 00:44:09,150
whether it's Runtime or
Gateway or Identity or Memory,

931
00:44:09,150 --> 00:44:12,000
and your tools through the microservices.

932
00:44:12,000 --> 00:44:13,683
As your agents execute,

933
00:44:14,640 --> 00:44:17,100
AgentCore automatically sends traces

934
00:44:17,100 --> 00:44:18,840
to the observability component,

935
00:44:18,840 --> 00:44:21,810
capturing every decision, every tool call,

936
00:44:21,810 --> 00:44:23,673
and every interaction that was made.

937
00:44:24,540 --> 00:44:26,760
The logs are open telemetry compatible,

938
00:44:26,760 --> 00:44:31,290
which means that the logs
can be directly pipped

939
00:44:31,290 --> 00:44:34,440
into your choice of
observability platform,

940
00:44:34,440 --> 00:44:39,440
whether it's Dynatrace or
Datadog or Langsmith or Langfuse.

941
00:44:40,170 --> 00:44:44,640
You can easily add random
and custom attributes

942
00:44:44,640 --> 00:44:48,150
and business metadata
functions to your agent traces,

943
00:44:48,150 --> 00:44:50,970
making observability directly relevant

944
00:44:50,970 --> 00:44:53,673
to your business outcomes
and decision-making.

945
00:44:55,020 --> 00:44:57,330
Now, that covers our AgentCore modules,

946
00:44:57,330 --> 00:45:00,420
and remember that these are
all modular Lego blocks,

947
00:45:00,420 --> 00:45:01,860
so you can pick and choose

948
00:45:01,860 --> 00:45:04,680
whatever fits your production environment.

949
00:45:04,680 --> 00:45:07,830
And with that, I'll hand it over to Roland

950
00:45:07,830 --> 00:45:09,690
to do some closing comments.

951
00:45:09,690 --> 00:45:10,920
- Thank you.

952
00:45:10,920 --> 00:45:12,060
Yeah, I'm really excited

953
00:45:12,060 --> 00:45:15,235
with observability, OTEL support,

954
00:45:15,235 --> 00:45:16,500
is lets you kind of integrate

955
00:45:16,500 --> 00:45:18,840
with your existing observability tools,

956
00:45:18,840 --> 00:45:22,410
'cause we love our observability tools,

957
00:45:22,410 --> 00:45:24,990
but our partners also
have some great tools.

958
00:45:24,990 --> 00:45:27,180
So really excited about that as well.

959
00:45:27,180 --> 00:45:30,570
Still a lot of challenges
in this space, right?

960
00:45:30,570 --> 00:45:32,790
Cardinality and token costs.

961
00:45:32,790 --> 00:45:35,580
You have lots and
thousands of microservices,

962
00:45:35,580 --> 00:45:38,700
and you have to interrogate
all of those things, right?

963
00:45:38,700 --> 00:45:42,000
And you're sending those over to LLMs

964
00:45:42,000 --> 00:45:44,370
to make choices on your applications

965
00:45:44,370 --> 00:45:46,140
that can bring up the cost.

966
00:45:46,140 --> 00:45:47,850
That's why things like semantic search

967
00:45:47,850 --> 00:45:50,640
and using that are so important, right?

968
00:45:50,640 --> 00:45:51,960
Auditability requirements.

969
00:45:51,960 --> 00:45:53,880
The more regulated your industry,

970
00:45:53,880 --> 00:45:55,830
the more you have to think about things.

971
00:45:55,830 --> 00:45:57,840
When policies are changing fast,

972
00:45:57,840 --> 00:45:59,100
how do you deal with that?

973
00:45:59,100 --> 00:46:01,650
Lots of issues there as well, right?

974
00:46:01,650 --> 00:46:03,180
A lot of regulated industries,

975
00:46:03,180 --> 00:46:06,120
require precise deterministic logic,

976
00:46:06,120 --> 00:46:08,070
that's where your code is super important.

977
00:46:08,070 --> 00:46:10,050
You're still gonna write
your microservices,

978
00:46:10,050 --> 00:46:12,780
still gonna write your
container-based applications,

979
00:46:12,780 --> 00:46:16,290
EKS, ECS, and a lot of cool
announcements there this week

980
00:46:16,290 --> 00:46:18,210
as well, and your Lambda functions,

981
00:46:18,210 --> 00:46:20,670
and you're still gotta deal
with things like data trust,

982
00:46:20,670 --> 00:46:22,560
permissions, and all of these things.

983
00:46:22,560 --> 00:46:25,140
And I'm really excited
with the frontier agents

984
00:46:25,140 --> 00:46:27,930
that Matt announced
earlier yesterday, right?

985
00:46:27,930 --> 00:46:30,930
These agents really implementing,
Swami talked about it,

986
00:46:30,930 --> 00:46:33,540
kind of some of these DevOps
challenges that we have,

987
00:46:33,540 --> 00:46:37,440
MLOps evaluations, and
really streamlining that.

988
00:46:37,440 --> 00:46:40,740
But there's still a lot
of things to kind of worry

989
00:46:40,740 --> 00:46:44,640
about with your existing DevOps,
your existing applications.

990
00:46:44,640 --> 00:46:47,846
You might be using GitHubs,
DevOps, different things,

991
00:46:47,846 --> 00:46:48,960
and now you have brand new patterns.

992
00:46:48,960 --> 00:46:50,700
So these are still lots of challenges.

993
00:46:50,700 --> 00:46:52,140
Hopefully, we work together,

994
00:46:52,140 --> 00:46:56,293
discover them together,
out there in the ethos

995
00:46:56,293 --> 00:46:59,220
as we work together and
build our systems, right?

996
00:46:59,220 --> 00:47:04,100
In summary, our use cases must
be business-driven, right?

997
00:47:04,100 --> 00:47:05,580
At the end of the day,

998
00:47:05,580 --> 00:47:08,490
you must have valid business
reasons to build applications,

999
00:47:08,490 --> 00:47:11,130
build systems, whether it's to save costs,

1000
00:47:11,130 --> 00:47:13,410
whether it's to provide new opportunities,

1001
00:47:13,410 --> 00:47:16,410
certainly not lots of new
patterns, generation of tools,

1002
00:47:16,410 --> 00:47:18,750
making it easier for your applications

1003
00:47:18,750 --> 00:47:22,350
to kind of create content,
lots of different use cases,

1004
00:47:22,350 --> 00:47:24,960
use accelerator, lots of best practices

1005
00:47:24,960 --> 00:47:28,680
in places like our solution
library and marketplace.

1006
00:47:28,680 --> 00:47:31,440
And all different places
have different accelerators

1007
00:47:31,440 --> 00:47:32,970
and best practices.

1008
00:47:32,970 --> 00:47:35,460
Integration continues to be important.

1009
00:47:35,460 --> 00:47:36,930
Things like gateways,

1010
00:47:36,930 --> 00:47:39,900
will really accelerate
your existing applications.

1011
00:47:39,900 --> 00:47:43,470
Define your development
methodology early, your MLOps,

1012
00:47:43,470 --> 00:47:45,210
your evaluations, your DevOps,

1013
00:47:45,210 --> 00:47:48,810
harden those practices when
you build your first agents.

1014
00:47:48,810 --> 00:47:51,480
And then over time, harden those practices

1015
00:47:51,480 --> 00:47:52,710
as you learn more and more.

1016
00:47:52,710 --> 00:47:55,380
It might be building up
a library of prompts,

1017
00:47:55,380 --> 00:47:58,380
introducing new practices
like LLM as a judge

1018
00:47:58,380 --> 00:48:01,290
to kind of evaluate as
new models come out.

1019
00:48:01,290 --> 00:48:04,950
So with that, I want to thank
you for spending your evening.

1020
00:48:04,950 --> 00:48:07,530
I hope you all have
great plans this evening

1021
00:48:07,530 --> 00:48:11,370
as you go out, and think about
these things agentically,

1022
00:48:11,370 --> 00:48:13,830
think about making
decisions over your dinners,

1023
00:48:13,830 --> 00:48:15,660
where you're going to eat agentically.

1024
00:48:15,660 --> 00:48:16,560
Thank you.

1025
00:48:16,560 --> 00:48:19,710
We'll share the QR code,
start building with AWS,

1026
00:48:19,710 --> 00:48:23,220
and use our Bedrock
AgentCore capabilities.

1027
00:48:23,220 --> 00:48:24,837
Thank you.

1028
00:48:24,837 --> 00:48:27,442
(audience applauding)

