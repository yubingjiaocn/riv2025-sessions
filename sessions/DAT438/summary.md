# AWS re:Invent 2025 ElastiCache 与 Valkey 会议总结

## 会议概述

本次会议由 AWS ElastiCache 团队的高级工程经理 Yon 和首席工程师 Kevin McGee 主讲，深入探讨了 Amazon ElastiCache 和 Valkey 引擎的高级应用场景和数据建模技术。

会议以构建大型多人在线游戏（MMO RPG）为实际案例，展示了如何利用 ElastiCache 和 Valkey 实现高可扩展性、低延迟和高吞吐量的应用架构。ElastiCache 是 AWS 提供的完全托管的内存数据存储服务，能够提供微秒级响应时间，显著提升应用性能。该服务支持三种开源引擎：Redis OSS、Memcached 和 Valkey。Valky 是从 Redis 开源版本分叉而来的高性能键值数据存储引擎，在 Redis 更改许可证后，AWS 于去年宣布 ElastiCache 和 MemoryDB 支持 Valkey 引擎。

演讲涵盖了多个核心主题，包括缓存策略（懒加载和缓存失效）、客户端缓存、多种数据结构（Hash、JSON、发布订阅、概率数据结构）、语义缓存和向量搜索等。通过丰富的代码示例和架构图，讲师展示了如何在实际应用中实现这些技术，帮助开发者构建高性能、可扩展的云原生应用。

## 详细时间线与关键要点

### 开场介绍 (0:00 - 2:30)
- **0:00** - 会议开始，Yon 和 Kevin McGee 介绍自己来自 AWS ElastiCache 团队
- **0:30** - 会议主题：ElastiCache 和 Valkey 的高级用例和数据建模
- **1:00** - 宣布将通过构建大型多人在线游戏（MMO RPG）来演示技术应用

### ElastiCache 基础介绍 (2:30 - 5:00)
- **2:30** - Amazon ElastiCache 是完全托管的内存数据存储服务
- **3:00** - 提供微秒级响应时间，显著提升应用性能
- **3:30** - 支持三种开源引擎：Redis OSS、Memcached 和 Valkey
- **4:00** - Valkey 是高性能键值数据存储，从 Redis 开源版本分叉而来
- **4:30** - AWS 去年宣布 ElastiCache 和 MemoryDB 支持 Valkey 引擎

### 缓存基础架构 (5:00 - 8:30)
- **5:00** - 演示基础架构：EC2 + RDS 的传统架构
- **6:00** - 当工作负载增加时，可以扩展 RDS 或添加副本
- **6:30** - RDS 缓存层基于页面和块，不包含结果本身
- **7:00** - 引入 ElastiCache 将数据显式存储在内存中
- **7:30** - 从缓存读取数据可获得微秒级响应时间
- **8:00** - 减轻后端数据库压力，优化成本

### 懒加载策略 (8:30 - 11:00)
- **8:30** - 介绍懒加载（Lazy Loading）缓存策略
- **9:00** - 首先从 ElastiCache 读取数据，如果命中则直接返回
- **9:30** - 缓存未命中时，从 DynamoDB 读取数据
- **10:00** - 读取后将数据更新到缓存中
- **10:30** - 使用 DynamoDB 触发器和 Lambda 函数实现缓存失效
- **11:00** - 当数据更新时，Lambda 负责使缓存中的特定项失效

### 热数据管理与 TTL (11:00 - 13:30)
- **11:00** - 讨论热数据和 TTL（Time To Live）管理
- **11:30** - 使用 Valkey 多命令（Multi-command）原子性执行操作
- **12:00** - 通过 GET 和检查过期时间来管理热数据
- **12:30** - 当过期时间低于 5 秒阈值时，后台任务更新数据
- **13:00** - 确保热数据在过期前被刷新，保持缓存命中率

### 避免惊群问题 (13:30 - 17:00)
- **13:30** - 介绍惊群问题（Thundering Herd Problem）
- **14:00** - 当热数据过期时，多个进程同时请求会导致数据库压力
- **14:30** - 使用同步屏障机制，只允许一个客户端请求数据库
- **15:00** - 演示两个微服务的交互流程
- **15:30** - 第一个微服务获取锁，使用 NX 和 EX 参数
- **16:00** - 第二个微服务尝试获取锁失败，等待锁释放
- **16:30** - 第一个微服务完成后释放锁，第二个微服务从缓存读取

### 客户端缓存 (17:00 - 20:30)
- **17:00** - 介绍客户端缓存（Client-side Caching）
- **17:30** - 从远程缓存获取数据后存储在本地缓存
- **18:00** - 本地缓存可提供极低延迟
- **18:30** - 两种管理数据新鲜度的方法：TTL 和订阅通知
- **19:00** - Valkey 默认方式：存储客户端和键的映射关系
- **19:30** - 第二种方式：订阅前缀，接收相关键的更新通知
- **20:00** - 推荐使用连接池和长连接以减少 TCP 连接开销

### 连接池管理 (20:30 - 22:00)
- **20:30** - 将连接池分为两类：失效连接和数据连接
- **21:00** - 连接 0 作为失效连接，订阅失效通道
- **21:30** - 其他连接（1-9）作为数据连接，执行跟踪重定向
- **22:00** - 当键更新时，连接 0 接收通知并更新本地缓存

### Hash 数据结构 (22:00 - 24:30)
- **22:00** - 介绍 Hash 数据结构用于存储会话信息
- **22:30** - Hash 是键值对映射，适合简单对象如会话存储
- **23:00** - 使用 HSET 命令创建 Hash，提供键值对列表
- **23:30** - 常数时间复杂度的随机访问
- **24:00** - 代码示例：使用 Valkey Glide 连接服务器
- **24:30** - 生成 UUID 作为会话 ID，使用 HGETALL 检索数据

### JSON 数据结构 (24:30 - 27:00)
- **24:30** - 介绍 JSON 数据结构，由数组和键值对组成
- **25:00** - 使用 JSON.SET 创建 JSON 文档
- **25:30** - 使用 JSON Path 检索特定项
- **26:00** - 使用 JSON.ARRAPPEND 向数组添加项
- **26:30** - 代码示例：检索用户邮箱、年龄，使用 NUMINCRBY 增加数值
- **27:00** - Hash vs JSON：JSON 适合嵌套文档，Hash 适合简单键值对

### 语义缓存与向量搜索 (27:00 - 33:00)
- **27:00** - 宣布 ElastiCache 支持语义缓存，95% 召回率
- **27:30** - 介绍向量嵌入（Vector Embedding）概念
- **28:00** - 将非结构化数据（文档、视频、音频、图像）转换为向量表示
- **28:30** - 向量嵌入捕获语义关系，如"book"的不同含义
- **29:00** - 处理流程：数据摄取、分块、转换为向量
- **29:30** - 示例：聊天机器人查询"下一个任务何时开始"
- **30:00** - 语义搜索理解相似查询的含义
- **30:30** - 架构流程：查询生成式 AI 应用，使用基础模型
- **31:00** - 首次查询未命中缓存，从基础模型获取响应
- **31:30** - 使用 Amazon Titan 生成嵌入向量
- **32:00** - 相似查询可以命中缓存，节省成本和时间
- **32:30** - 避免重复调用昂贵的基础模型

### 向量搜索 API (33:00 - 36:00)
- **33:00** - 使用 FT.CREATE 创建索引，支持 Hash 或 JSON
- **33:30** - 使用 HNSW 算法，适合高维空间，性能优化
- **34:00** - 示例使用 128 维向量
- **34:30** - 使用余弦距离度量
- **35:00** - FT.SEARCH 搜索最近邻，检索 10 个结果
- **35:30** - 支持服务器端过滤，如按国家过滤
- **36:00** - 代码示例：加载文本数据并分块

### 向量存储实现 (36:00 - 38:00)
- **36:00** - 使用 LangChain 库处理文本分块
- **36:30** - 使用嵌入模型将分块转换为向量
- **37:00** - 使用 Titan 生成嵌入向量
- **37:30** - 使用 FT.CREATE 存储向量
- **38:00** - 使用 FT.SEARCH 和最近邻查询检索数据

### 发布订阅模式 (38:00 - 43:00)
- **38:00** - Kevin 接手演讲，介绍发布订阅功能
- **38:30** - 为 MMO RPG 构建游戏内聊天功能
- **39:00** - 示例：Shadow Dragons 公会聊天
- **39:30** - 发布订阅模式：生产者和订阅者解耦
- **40:00** - 订阅者订阅命名主题，发布者发布消息
- **40:30** - Valkey 中数据是临时的，作为消息总线
- **41:00** - 支持最多一次传递，未监听则错过消息
- **41:30** - Streams 数据结构支持长期存储（未详细讨论）
- **42:00** - 两种发布订阅类型：经典和分片
- **42:30** - 推荐使用分片发布订阅，具有更好的可扩展性
- **43:00** - 经典发布订阅将消息转发到所有节点，扇出大

### 分片发布订阅 (43:00 - 46:00)
- **43:00** - 分片发布订阅消息发送到特定分片
- **43:30** - 生产者和消费者知道去哪个分片
- **44:00** - 缺点：不支持通配符订阅
- **44:30** - 必须使用特定主题名称以哈希到正确分片
- **45:00** - 示例：Alice 和 Bob 加入聊天室
- **45:30** - 使用 SSUBSCRIBE 命令订阅，前缀为"chat:"
- **46:00** - 返回主题标识符和成功订阅确认

### 发布订阅实践 (46:00 - 48:00)
- **46:00** - Alice 使用 SPUBLISH 发布消息
- **46:30** - 使用 JSON 格式包含元数据以渲染聊天
- **47:00** - 返回 1 表示成功，Alice 立即收到 SMESSAGE
- **47:30** - Bob 订阅后发布消息
- **48:00** - 两个用户都收到消息，因为都已订阅

### HyperLogLog 概率数据结构 (48:00 - 53:00)
- **48:00** - 介绍概率数据结构，内存效率高
- **48:30** - 用例：唯一用户计数（每日活跃用户）
- **49:00** - 传统 Set 需要 O(n) 空间存储所有用户
- **49:30** - HyperLogLog 可以近似集合基数
- **50:00** - 固定 12KB 内存，标准误差小于 1%
- **50:30** - 常数时间操作
- **51:00** - 工作原理：类似抛硬币，观察连续正面次数
- **51:30** - 使用 MurmurHash 生成 64 位均匀分布二进制串
- **52:00** - 前 14 位计算哈希桶（16,000 个桶）
- **52:30** - 计算前导零数量，存储每个桶的最大前导零数
- **53:00** - 使用调和平均数计算总观察数

### HyperLogLog API (53:00 - 56:00)
- **53:00** - API 简单：PF 前缀命令
- **53:30** - PFADD 添加项到 HyperLogLog
- **54:00** - 示例：daily_active_users:日期，添加三个用户
- **54:30** - PFCOUNT 返回计数，此例返回 3
- **55:00** - 添加重复用户返回 0，计数不变
- **55:30** - HyperLogLog 可组合，使用 PFMERGE 合并
- **56:00** - 示例：game1 和 game2 的用户合并

### HyperLogLog 性能对比 (56:00 - 58:00)
- **56:00** - 合并后获得跨多个 HyperLogLog 的唯一用户总数
- **56:30** - 示例：5 次观察但只有 4 个唯一用户
- **57:00** - 内存使用模拟：10,000 个数字
- **57:30** - Set 使用 420KB，返回精确的 10,000
- **58:00** - HyperLogLog 使用 12KB，返回 9,987（0.13% 误差）

### Bloom Filter 概率数据结构 (58:00 - 63:00)
- **58:00** - 新问题：两个玩家是否认识彼此
- **58:30** - 跟踪玩家交互形成图结构
- **59:00** - 使用 Set 存储需要 O(n) 空间
- **59:30** - Bloom Filter 回答成员测试问题
- **60:00** - 相比 Set 可节省超过 90% 内存
- **60:30** - 可调节假阳性率，默认 1%
- **61:00** - 假阳性率越低，内存使用越高
- **61:30** - 常数时间操作，使用多个哈希函数
- **62:00** - 工作原理：固定大小位数组
- **62:30** - 示例：10 位数组，两个哈希函数
- **63:00** - 添加 Bob：hash1(Bob) mod 10 = 5，hash2(Bob) mod 10 = 9

### Bloom Filter 工作机制 (63:00 - 66:00)
- **63:00** - 更新位数组中的位 5 和位 9
- **63:30** - 添加 Alice：可能与现有位冲突
- **64:00** - 成员测试：检查哈希位是否都为 1
- **64:30** - 如果至少一个位为 0，则肯定未添加
- **65:00** - 如果所有位都为 1，则可能已添加（可能假阳性）
- **65:30** - 不存储底层字符串，只存储哈希值表示
- **66:00** - 内存节省显著

### Bloom Filter 容量 (66:00 - 68:00)
- **66:00** - 1% 假阳性率：128MB 可存储 1.12 亿项
- **66:30** - 512MB 可存储 4.48 亿项，线性扩展
- **67:00** - 0.1% 假阳性率：128MB 可存储 7400 万项
- **67:30** - 512MB 可存储 2.98 亿项
- **68:00** - 可根据需求调整配置

### Bloom Filter API (68:00 - 结束)
- **68:00** - API 类似 Set，使用 BF.ADD 命令添加项
- **68:30** - 会议内容总结和结束

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━


注： 本总结基于提供的字幕转录，涵盖了会议的主要技术要点和时间线。