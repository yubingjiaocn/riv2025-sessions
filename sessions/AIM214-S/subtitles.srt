1
00:00:00,937 --> 00:00:03,030
(audience clapping)

2
00:00:03,030 --> 00:00:04,290
- Hey everybody, how we doing?

3
00:00:04,290 --> 00:00:06,067
Thanks so much for coming to my session,

4
00:00:06,067 --> 00:00:07,230
"RAG is dead:

5
00:00:07,230 --> 00:00:11,250
Long live intelligent
retrieval-augmented generation."

6
00:00:11,250 --> 00:00:14,400
We gather here today to
discuss the types of situations

7
00:00:14,400 --> 00:00:17,310
that unfortunately can slay RAG

8
00:00:17,310 --> 00:00:19,950
and what agentic retrieval can do

9
00:00:19,950 --> 00:00:21,333
to help solve this problem.

10
00:00:23,640 --> 00:00:26,250
Today we'll talk about
recommendation systems,

11
00:00:26,250 --> 00:00:28,260
what agentic RAG is,

12
00:00:28,260 --> 00:00:31,200
and different contributions
that agentic RAG can make

13
00:00:31,200 --> 00:00:33,570
in order to solve these
sorts of difficult queries.

14
00:00:33,570 --> 00:00:35,520
But before we get into any of that,

15
00:00:35,520 --> 00:00:37,650
I want you all to take a second

16
00:00:37,650 --> 00:00:40,470
and think about this problem with me.

17
00:00:40,470 --> 00:00:43,020
So imagine you're building a tech startup,

18
00:00:43,020 --> 00:00:44,640
which I imagine is not too difficult

19
00:00:44,640 --> 00:00:46,909
to imagine from very many of you,

20
00:00:46,909 --> 00:00:50,580
and you're trying to build
a recommendation service

21
00:00:50,580 --> 00:00:53,859
for restaurants and dishes,
a really popular one.

22
00:00:53,859 --> 00:00:55,110
And over time you notice

23
00:00:55,110 --> 00:00:57,720
that there's this really
sticky group of people

24
00:00:57,720 --> 00:00:59,730
that come back to use your system,

25
00:00:59,730 --> 00:01:02,400
but they don't seem to
actually enjoy it that much.

26
00:01:02,400 --> 00:01:05,313
And it's couples that are
going on a first date.

27
00:01:06,270 --> 00:01:07,950
And you realize that these couples

28
00:01:07,950 --> 00:01:10,980
tend to have user queries in your system.

29
00:01:10,980 --> 00:01:13,830
And what they really want is a
set of dishes and restaurants

30
00:01:13,830 --> 00:01:15,660
that they can go to that aligns with that.

31
00:01:15,660 --> 00:01:18,783
So you might have a situation
where you have person one,

32
00:01:19,770 --> 00:01:21,060
they might have some restrictions,

33
00:01:21,060 --> 00:01:24,240
like they need to avoid
dairy, they only eat chicken,

34
00:01:24,240 --> 00:01:26,850
and they prefer eating spicy food.

35
00:01:26,850 --> 00:01:29,730
And you'll have the second
person in the relationship

36
00:01:29,730 --> 00:01:32,130
which might love fish and beef,

37
00:01:32,130 --> 00:01:34,410
value a romantic atmosphere,

38
00:01:34,410 --> 00:01:36,570
and they have a lot of
specific food allergies.

39
00:01:36,570 --> 00:01:37,560
So it's really important

40
00:01:37,560 --> 00:01:39,483
to find the best restaurant for them.

41
00:01:40,980 --> 00:01:42,750
So you do some user studies,

42
00:01:42,750 --> 00:01:44,490
you sit down with these couples,

43
00:01:44,490 --> 00:01:47,220
and you realize that the
conversation goes back and forth.

44
00:01:47,220 --> 00:01:49,530
People kind of think about
what they're looking for,

45
00:01:49,530 --> 00:01:51,570
and they eventually land on

46
00:01:51,570 --> 00:01:53,670
maybe something like the following phrase.

47
00:01:54,937 --> 00:01:59,937
"We need date night restaurants
within our budget near us

48
00:02:00,240 --> 00:02:03,990
that have vegetarian non-dairy
options, spicy options,

49
00:02:03,990 --> 00:02:05,790
maybe a good charitable dessert

50
00:02:05,790 --> 00:02:07,980
with a romantic vibe, blah, blah blah."

51
00:02:07,980 --> 00:02:12,300
A really complicated set of preferences.

52
00:02:12,300 --> 00:02:15,060
Now at this point you might
be thinking, alright, Arjun,

53
00:02:15,060 --> 00:02:17,760
I was with you on the
recommendation system part,

54
00:02:17,760 --> 00:02:20,100
but I'm not with you on this
oddly specific scenario.

55
00:02:20,100 --> 00:02:22,590
This seems too arbitrary, right?

56
00:02:22,590 --> 00:02:24,390
I mean, how many of you
have tried to figure out

57
00:02:24,390 --> 00:02:25,770
where to eat with your significant other?

58
00:02:25,770 --> 00:02:28,020
It gets pretty complicated pretty quickly.

59
00:02:28,020 --> 00:02:29,490
And so you might be
thinking this is not real.

60
00:02:29,490 --> 00:02:31,590
And I'm here to tell you
that this is absolutely real,

61
00:02:31,590 --> 00:02:34,230
because almost six
years to this exact day,

62
00:02:34,230 --> 00:02:36,810
I was agonizing over exactly what to do

63
00:02:36,810 --> 00:02:38,460
in this exact situation,

64
00:02:38,460 --> 00:02:42,180
because I was trying to
impress a beautiful girl

65
00:02:42,180 --> 00:02:45,000
and I had to figure out
exactly where we need to go.

66
00:02:45,000 --> 00:02:47,670
And it turns out that those
were our real preferences

67
00:02:47,670 --> 00:02:50,400
that I had to figure out to
find the actual restaurant

68
00:02:50,400 --> 00:02:51,630
for our first date.

69
00:02:51,630 --> 00:02:56,040
And it worked, six years later
I proposed earlier this year.

70
00:02:56,040 --> 00:02:59,160
So yes, this is a real
problem that people face.

71
00:02:59,160 --> 00:03:00,210
These are types of queries

72
00:03:00,210 --> 00:03:02,490
that people will have to deal
with in specific situations

73
00:03:02,490 --> 00:03:05,370
with restaurant recommendations
being one of them.

74
00:03:05,370 --> 00:03:06,660
And what's sticky about this

75
00:03:06,660 --> 00:03:08,850
is that if we were to
use a system like this

76
00:03:08,850 --> 00:03:10,410
and it gave you a poor recommendation,

77
00:03:10,410 --> 00:03:12,030
the consequences are huge.

78
00:03:12,030 --> 00:03:14,673
So you really just get one
shot to get this right.

79
00:03:16,350 --> 00:03:18,210
Now, let's think a little harder

80
00:03:18,210 --> 00:03:20,463
about what makes this
problem so difficult.

81
00:03:21,570 --> 00:03:25,170
There are four distinct issues
with this type of situation.

82
00:03:25,170 --> 00:03:28,230
Number one, there are a lot
of distinct data sources

83
00:03:28,230 --> 00:03:29,370
that you have to reconcile

84
00:03:29,370 --> 00:03:31,380
that your system needs
to be able to deal with.

85
00:03:31,380 --> 00:03:34,260
And having a lot of distinct
data sources is difficult

86
00:03:34,260 --> 00:03:37,050
for a retrieval-augmented
generation system to resolve.

87
00:03:37,050 --> 00:03:39,600
You need to look at restaurant
reviews, descriptions,

88
00:03:39,600 --> 00:03:41,790
dishes, images, what people are saying,

89
00:03:41,790 --> 00:03:43,350
where these restaurants are,

90
00:03:43,350 --> 00:03:45,750
any dietary restrictions
associated with those dishes.

91
00:03:45,750 --> 00:03:48,240
Just thinking about how
to maintain the context

92
00:03:48,240 --> 00:03:51,120
around all of those
data sources is a pain.

93
00:03:51,120 --> 00:03:53,850
The second issue is that it's a high risk,

94
00:03:53,850 --> 00:03:55,410
high reward situation.

95
00:03:55,410 --> 00:03:57,180
If your primary demographic

96
00:03:57,180 --> 00:03:59,820
is people who haven't used
your application before

97
00:03:59,820 --> 00:04:02,100
and they're looking for a
really good recommendation

98
00:04:02,100 --> 00:04:04,710
the first time they
interact with your system,

99
00:04:04,710 --> 00:04:07,980
you better believe you serve
them a good recommendation.

100
00:04:07,980 --> 00:04:10,650
And in this situation, there
are three consequences.

101
00:04:10,650 --> 00:04:14,190
First, you're trying to
acquire this couple this user

102
00:04:14,190 --> 00:04:15,600
for the entirety of their journey.

103
00:04:15,600 --> 00:04:17,460
So they keep coming
back to your application

104
00:04:17,460 --> 00:04:19,980
to get those good
restaurant recommendations.

105
00:04:19,980 --> 00:04:21,180
Second, the restaurant

106
00:04:21,180 --> 00:04:23,190
that's going to be serving
those recommendations

107
00:04:23,190 --> 00:04:24,840
is gonna gain two seats instead of one.

108
00:04:24,840 --> 00:04:28,020
So it's really important for
them to be aligned to the users

109
00:04:28,020 --> 00:04:30,510
that are interested for
what they need to be doing.

110
00:04:30,510 --> 00:04:32,070
And finally, the couple cares, right?

111
00:04:32,070 --> 00:04:34,860
You wanna go to a place that's
gonna have really good food.

112
00:04:34,860 --> 00:04:36,720
The third issue is that we're dealing

113
00:04:36,720 --> 00:04:39,150
with really complicated
natural language queries.

114
00:04:39,150 --> 00:04:41,010
If you were to throw this query

115
00:04:41,010 --> 00:04:43,200
at a traditional vanilla RAG system,

116
00:04:43,200 --> 00:04:44,520
it would absolutely fail,

117
00:04:44,520 --> 00:04:47,280
because usually there is not
a query understanding portion

118
00:04:47,280 --> 00:04:48,390
built into that retrieval.

119
00:04:48,390 --> 00:04:51,180
Specifically, the query is long,

120
00:04:51,180 --> 00:04:53,070
requires a lot of reasoning capabilities

121
00:04:53,070 --> 00:04:56,070
to understand the
motivation behind the query,

122
00:04:56,070 --> 00:04:58,200
and it requires planning and coordination

123
00:04:58,200 --> 00:05:00,363
to solve the relevant recommendations.

124
00:05:01,530 --> 00:05:03,780
Finally, because this
query is so complicated,

125
00:05:03,780 --> 00:05:05,130
RAG approaches will just fail

126
00:05:05,130 --> 00:05:06,900
and we need a lot more engineering work

127
00:05:06,900 --> 00:05:08,250
to solve this problem.

128
00:05:08,250 --> 00:05:11,220
If only we had like a set of magical boxes

129
00:05:11,220 --> 00:05:12,510
that could help us parts

130
00:05:12,510 --> 00:05:14,910
and understand what
these queries are doing,

131
00:05:14,910 --> 00:05:17,100
wouldn't that be kind of wonderful?

132
00:05:17,100 --> 00:05:19,890
Well, it turns out that
if we use agentic RAG,

133
00:05:19,890 --> 00:05:22,410
we can address the complexity
of these different types

134
00:05:22,410 --> 00:05:25,107
of complicated queries
through flexibility.

135
00:05:25,107 --> 00:05:27,270
And in this talk, I'm gonna
go over a few techniques

136
00:05:27,270 --> 00:05:28,103
in order to do that,

137
00:05:28,103 --> 00:05:30,483
specifically with retrieval and databases.

138
00:05:32,220 --> 00:05:34,350
The contributions that
agentic RAG can make

139
00:05:34,350 --> 00:05:35,700
are the following,

140
00:05:35,700 --> 00:05:37,290
first is query understanding.

141
00:05:37,290 --> 00:05:39,300
In other words, we're
gonna ask the question,

142
00:05:39,300 --> 00:05:42,570
how can we interpret what
the user actually needs?

143
00:05:42,570 --> 00:05:45,660
And then serve recommendations
under that context.

144
00:05:45,660 --> 00:05:48,900
Second, we can optimize
retrieval patterns even further.

145
00:05:48,900 --> 00:05:50,670
If we know what they need,

146
00:05:50,670 --> 00:05:53,340
how do we retrieve the best context given

147
00:05:53,340 --> 00:05:55,260
for that information?

148
00:05:55,260 --> 00:05:57,510
Finally, with the agentic RAG

149
00:05:57,510 --> 00:06:00,510
we have the ability to
do iterative generation,

150
00:06:00,510 --> 00:06:03,420
so we don't have to stop
at the first retrieval.

151
00:06:03,420 --> 00:06:05,400
Once we have the best context,

152
00:06:05,400 --> 00:06:08,103
how do we generate the best response?

153
00:06:09,930 --> 00:06:12,870
The primary architecture
we're gonna be talking about

154
00:06:12,870 --> 00:06:13,703
in this talk,

155
00:06:13,703 --> 00:06:15,810
is gonna be the tool use
workflow architecture

156
00:06:15,810 --> 00:06:18,360
that is so easy to
implement with agentic RAG,

157
00:06:18,360 --> 00:06:21,660
and allows you to kind of
take a stab at this problem.

158
00:06:21,660 --> 00:06:23,227
So we might have some query like,

159
00:06:23,227 --> 00:06:25,020
"Hey, we need to eat
somewhere near our hotel

160
00:06:25,020 --> 00:06:25,853
with our budget.

161
00:06:25,853 --> 00:06:28,380
I avoid dairy and meat,
but I'm fine with eggs.

162
00:06:28,380 --> 00:06:30,090
I love spicy food and it's date night.

163
00:06:30,090 --> 00:06:31,170
So we need shareable plates."

164
00:06:31,170 --> 00:06:33,780
This is a real thing I've
said in real life, by the way.

165
00:06:33,780 --> 00:06:35,670
So an agent might take that query,

166
00:06:35,670 --> 00:06:37,950
it might have access to a
set of tools and workflows,

167
00:06:37,950 --> 00:06:42,210
like query transformation
procedures, criteria, evaluation,

168
00:06:42,210 --> 00:06:44,970
a bunch of different databases
like our dishes, restaurants,

169
00:06:44,970 --> 00:06:47,220
allergies, known allergens, and reviews,

170
00:06:47,220 --> 00:06:49,140
and then serve a pattern
of recommendations.

171
00:06:49,140 --> 00:06:51,720
And it's important to note
that in this architecture

172
00:06:51,720 --> 00:06:54,780
the agent is deciding
what tools to use when.

173
00:06:54,780 --> 00:06:57,060
So it's particularly flexible
to the types of queries

174
00:06:57,060 --> 00:06:58,160
that are being passed.

175
00:06:59,310 --> 00:07:01,660
Great, so let's begin
with query understanding.

176
00:07:02,700 --> 00:07:05,940
Agents are able to plan
queries for optimal retrieval.

177
00:07:05,940 --> 00:07:07,290
In a traditional RAG system,

178
00:07:07,290 --> 00:07:09,630
you're gonna have the query
hit the database directly,

179
00:07:09,630 --> 00:07:13,080
but an agent can modify the
query or add additional queries

180
00:07:13,080 --> 00:07:15,900
in order to retrieve optimize context.

181
00:07:15,900 --> 00:07:18,000
Here are three different
ways you can accomplish this.

182
00:07:18,000 --> 00:07:21,270
The first is subquery generation,
where we ask the question,

183
00:07:21,270 --> 00:07:23,400
what else could the user need

184
00:07:23,400 --> 00:07:25,380
based on the query that they're asking?

185
00:07:25,380 --> 00:07:26,700
The second is query routing.

186
00:07:26,700 --> 00:07:27,810
This is really important

187
00:07:27,810 --> 00:07:30,060
and underestimated by a lot of developers.

188
00:07:30,060 --> 00:07:32,310
ie, when we have an incoming query,

189
00:07:32,310 --> 00:07:34,050
where do we actually send that query

190
00:07:34,050 --> 00:07:36,030
and what databases are
relevant for the user

191
00:07:36,030 --> 00:07:38,100
at that given point in time?

192
00:07:38,100 --> 00:07:39,510
Finally, query expansion.

193
00:07:39,510 --> 00:07:40,980
If we have a given user query,

194
00:07:40,980 --> 00:07:43,560
what other terms or
concepts need to be included

195
00:07:43,560 --> 00:07:45,000
in order to retrieve those things?

196
00:07:45,000 --> 00:07:46,887
And what constraints in
addition to those terms

197
00:07:46,887 --> 00:07:49,983
and concepts do we need to be aware of?

198
00:07:51,180 --> 00:07:52,680
So what does this look like in practice?

199
00:07:52,680 --> 00:07:54,480
Imagine you're going to do query planning

200
00:07:54,480 --> 00:07:55,590
in the context of tool use.

201
00:07:55,590 --> 00:07:57,240
So we have this query I said before

202
00:07:57,240 --> 00:07:59,880
which was we need to eat
somewhere near our hotel,

203
00:07:59,880 --> 00:08:01,890
We have a budget, we avoid dairy and meat,

204
00:08:01,890 --> 00:08:03,420
but we're fine with eggs.

205
00:08:03,420 --> 00:08:04,980
I love spicy food and it's date night.

206
00:08:04,980 --> 00:08:06,720
So let's do shareable plates.

207
00:08:06,720 --> 00:08:09,840
The agent might intake
that query and understand

208
00:08:09,840 --> 00:08:11,910
and think about what tools are relevant

209
00:08:11,910 --> 00:08:14,280
in order to start parsing
and breaking this query down.

210
00:08:14,280 --> 00:08:16,380
So I've put in some example tools here

211
00:08:16,380 --> 00:08:18,360
that generate individual queries

212
00:08:18,360 --> 00:08:21,210
that we can all pass through
their relevant databases

213
00:08:21,210 --> 00:08:22,440
to retrieve context

214
00:08:22,440 --> 00:08:25,500
that are then reconciled for
the ultimate recommendation.

215
00:08:25,500 --> 00:08:28,800
For example, there are some
restrictions in the query here

216
00:08:28,800 --> 00:08:31,560
that are relevant to what
could be inside dishes.

217
00:08:31,560 --> 00:08:34,170
So I could have a tool that
parses those restrictions out

218
00:08:34,170 --> 00:08:35,520
to generate those filters.

219
00:08:35,520 --> 00:08:39,000
For example, food that
leans toward being spicy

220
00:08:39,000 --> 00:08:40,410
or we indicate some allergies.

221
00:08:40,410 --> 00:08:41,820
So we need another parsing step

222
00:08:41,820 --> 00:08:44,760
that can reliably pull that
information out of the query.

223
00:08:44,760 --> 00:08:45,780
There might be preferences

224
00:08:45,780 --> 00:08:47,520
that are more flexible in natural language

225
00:08:47,520 --> 00:08:49,980
that we can use in
criteria evaluation later,

226
00:08:49,980 --> 00:08:52,110
such as no dairy, meat, or eggs,

227
00:08:52,110 --> 00:08:54,420
or having family style serving.

228
00:08:54,420 --> 00:08:56,340
And finally, there are
restaurant level filters

229
00:08:56,340 --> 00:08:57,900
that we'll need to extract and interpret.

230
00:08:57,900 --> 00:09:00,870
For example, maybe we need
something that's under $40

231
00:09:00,870 --> 00:09:02,610
that has romantic atmosphere.

232
00:09:02,610 --> 00:09:05,580
That information might be
inside the reviews, for example,

233
00:09:05,580 --> 00:09:06,993
and that's four stars plus.

234
00:09:08,340 --> 00:09:10,230
What about retrieval?

235
00:09:10,230 --> 00:09:13,230
In order for agents to
work well with databases,

236
00:09:13,230 --> 00:09:16,770
you need to make the databases
ergonomic for those agents,

237
00:09:16,770 --> 00:09:18,750
and there are a few ways to do that.

238
00:09:18,750 --> 00:09:22,530
The first is you need to put
context around the data sources

239
00:09:22,530 --> 00:09:24,330
that your agents have access to.

240
00:09:24,330 --> 00:09:26,280
This is probably the number one mistake

241
00:09:26,280 --> 00:09:27,480
I see developers make,

242
00:09:27,480 --> 00:09:29,670
where they link their
database to their agents

243
00:09:29,670 --> 00:09:31,530
without properly informing

244
00:09:31,530 --> 00:09:33,300
and passing schemas back to the agents

245
00:09:33,300 --> 00:09:36,360
on what information is actually
contained in that database.

246
00:09:36,360 --> 00:09:38,220
So you need to ask the question,

247
00:09:38,220 --> 00:09:41,940
what data can the agents
access and how can it be used,

248
00:09:41,940 --> 00:09:44,460
and how should the agent
use that information?

249
00:09:44,460 --> 00:09:45,930
The second is the implementation

250
00:09:45,930 --> 00:09:47,730
of powerful search techniques.

251
00:09:47,730 --> 00:09:49,410
How do we interact with this data?

252
00:09:49,410 --> 00:09:50,640
How is it stored,

253
00:09:50,640 --> 00:09:53,490
and how do we use it in
order to maximize relevance?

254
00:09:53,490 --> 00:09:56,010
For example, there may be
specific search techniques

255
00:09:56,010 --> 00:09:58,560
that are more appropriate for
certain kinds of databases

256
00:09:58,560 --> 00:09:59,433
than for others.

257
00:10:00,300 --> 00:10:03,060
Finally, we should be using
filters as much as we can

258
00:10:03,060 --> 00:10:06,450
in order to reduce the search
space and decrease latency.

259
00:10:06,450 --> 00:10:08,250
How should we store this data

260
00:10:08,250 --> 00:10:11,150
in order to reduce that latency
and time to first request?

261
00:10:12,000 --> 00:10:13,740
So what does this look like?

262
00:10:13,740 --> 00:10:18,180
I've created a table here
of different databases

263
00:10:18,180 --> 00:10:19,950
that we could use in our application,

264
00:10:19,950 --> 00:10:21,240
and how we would wanna store

265
00:10:21,240 --> 00:10:23,700
and represent that data
in order to retrieve it

266
00:10:23,700 --> 00:10:25,290
and make it ergonomic.

267
00:10:25,290 --> 00:10:28,320
Suppose we have an index of
restaurants in this first row,

268
00:10:28,320 --> 00:10:30,060
it might contain names, descriptions,

269
00:10:30,060 --> 00:10:32,580
some metadata about the
restaurants like location.

270
00:10:32,580 --> 00:10:34,230
We might wanna do some pre-processing,

271
00:10:34,230 --> 00:10:36,090
like summarizing what
the restaurant is about

272
00:10:36,090 --> 00:10:37,680
across all of the reviews.

273
00:10:37,680 --> 00:10:40,080
That allows us to search
over all the restaurants

274
00:10:40,080 --> 00:10:41,850
with the same exact schema,

275
00:10:41,850 --> 00:10:44,100
thus resulting in standardization.

276
00:10:44,100 --> 00:10:45,600
There might be some applicable filters

277
00:10:45,600 --> 00:10:47,190
that are important for
our agent to know about,

278
00:10:47,190 --> 00:10:49,710
like pricing, moods, location,

279
00:10:49,710 --> 00:10:52,050
and it might be best to implement
a form of hybrid search,

280
00:10:52,050 --> 00:10:54,300
which allows us to leverage
the semantic descriptions

281
00:10:54,300 --> 00:10:56,040
that restaurants naturally have.

282
00:10:56,040 --> 00:10:57,720
In addition to the keywords
that we care about,

283
00:10:57,720 --> 00:10:59,120
like romantic or date night.

284
00:11:00,180 --> 00:11:02,970
For dishes, we might
need a separate index,

285
00:11:02,970 --> 00:11:04,590
and that index might be multimodal,

286
00:11:04,590 --> 00:11:06,120
because people take photos of their food

287
00:11:06,120 --> 00:11:08,070
and we care what they look like.

288
00:11:08,070 --> 00:11:10,200
There might be descriptions
and linked reviews.

289
00:11:10,200 --> 00:11:12,180
We might need to generate
potential ingredients

290
00:11:12,180 --> 00:11:14,220
that could be missing in
order to caution users

291
00:11:14,220 --> 00:11:16,443
against potential cross contamination.

292
00:11:17,400 --> 00:11:19,050
And there might be allergen level filters

293
00:11:19,050 --> 00:11:20,310
that we'll have to think about.

294
00:11:20,310 --> 00:11:21,990
And because people really care about

295
00:11:21,990 --> 00:11:23,700
what they ultimately will
eat at the restaurant,

296
00:11:23,700 --> 00:11:25,110
we might need to implement some re-ranking

297
00:11:25,110 --> 00:11:27,750
in order to optimize the relevancy there.

298
00:11:27,750 --> 00:11:29,250
Finally, we have the review index,

299
00:11:29,250 --> 00:11:30,780
which is also inherently multimodal.

300
00:11:30,780 --> 00:11:32,670
People are typing their descriptions

301
00:11:32,670 --> 00:11:35,790
and also putting images
of the food that's there.

302
00:11:35,790 --> 00:11:37,740
We might need to implement
an image to image search

303
00:11:37,740 --> 00:11:38,820
or an image to text search,

304
00:11:38,820 --> 00:11:40,680
and we need to think about
how to instrument this

305
00:11:40,680 --> 00:11:41,943
for our agent at hand.

306
00:11:43,530 --> 00:11:45,120
Finally, we need to think about

307
00:11:45,120 --> 00:11:47,613
how to improve the underlying generation.

308
00:11:49,800 --> 00:11:51,270
The thing about vanilla RAG

309
00:11:51,270 --> 00:11:53,280
is that very often people
will shoot out a query

310
00:11:53,280 --> 00:11:54,240
to a database

311
00:11:54,240 --> 00:11:56,100
and return those results
that are generated

312
00:11:56,100 --> 00:11:59,310
by an LLM directly to the user.

313
00:11:59,310 --> 00:12:01,650
But there's a lot of
opportunity lost there

314
00:12:01,650 --> 00:12:03,450
where we could spend even more time

315
00:12:03,450 --> 00:12:05,370
understanding whether
the results are relevant

316
00:12:05,370 --> 00:12:08,820
to that specific user in
that specific context.

317
00:12:08,820 --> 00:12:10,620
And we'll talk briefly
about some techniques

318
00:12:10,620 --> 00:12:13,080
that are helpful for this situation.

319
00:12:13,080 --> 00:12:16,560
First is thinking about loops
and looping your retrieval.

320
00:12:16,560 --> 00:12:18,300
So what else could the user need,

321
00:12:18,300 --> 00:12:19,890
and could we spend this time

322
00:12:19,890 --> 00:12:22,260
and exchange latency for
some more information

323
00:12:22,260 --> 00:12:24,330
that would be relevant to the user?

324
00:12:24,330 --> 00:12:27,210
The second is identifying
implied preferences.

325
00:12:27,210 --> 00:12:30,120
Users are notoriously bad
at describing what they want

326
00:12:30,120 --> 00:12:32,370
and the first interaction
you're going to have with them.

327
00:12:32,370 --> 00:12:34,140
So you need to build an architecture

328
00:12:34,140 --> 00:12:35,970
that allows us to understand

329
00:12:35,970 --> 00:12:38,280
what information we need to follow up with

330
00:12:38,280 --> 00:12:40,740
in order to retrieve the
appropriate information.

331
00:12:40,740 --> 00:12:43,680
And what of that information
is actually useful for us

332
00:12:43,680 --> 00:12:46,680
in context of the data
sources we're working with.

333
00:12:46,680 --> 00:12:49,290
Finally is, using structured generation.

334
00:12:49,290 --> 00:12:51,780
In other words, we should
be constraining the things

335
00:12:51,780 --> 00:12:53,670
that we are sending back to the user,

336
00:12:53,670 --> 00:12:55,830
presenting them in
information that is helpful

337
00:12:55,830 --> 00:12:57,720
for us to understand and analyze,

338
00:12:57,720 --> 00:13:00,963
so that it's possible when the
user gets the recommendation.

339
00:13:02,160 --> 00:13:04,530
What does that look like in practice?

340
00:13:04,530 --> 00:13:06,840
For example, one of my
favorite design patterns

341
00:13:06,840 --> 00:13:10,560
for implementing evaluation

342
00:13:10,560 --> 00:13:13,080
in agentic retrieval is checklists.

343
00:13:13,080 --> 00:13:15,270
So you might have an initial query,

344
00:13:15,270 --> 00:13:16,710
such as the one we've been working with

345
00:13:16,710 --> 00:13:17,760
where you have to eat somewhere.

346
00:13:17,760 --> 00:13:19,230
You have a bunch of restrictions

347
00:13:19,230 --> 00:13:21,150
and you can shoot that
query at your database

348
00:13:21,150 --> 00:13:22,770
and orchestrate it with your agent

349
00:13:22,770 --> 00:13:25,110
to retrieve all sorts of context,

350
00:13:25,110 --> 00:13:28,800
such as your restaurants,
your dishes, and your reviews.

351
00:13:28,800 --> 00:13:30,450
And you can pass that to the agent

352
00:13:30,450 --> 00:13:32,190
with all of that context being there,

353
00:13:32,190 --> 00:13:33,900
and say, hey, why don't you generate

354
00:13:33,900 --> 00:13:35,940
an initial set of recommendations?

355
00:13:35,940 --> 00:13:38,370
But at the same time, in parallel,

356
00:13:38,370 --> 00:13:39,510
what you could do

357
00:13:39,510 --> 00:13:42,510
is dynamically create
an evaluation checklist

358
00:13:42,510 --> 00:13:45,510
of the criteria that you need to satisfy

359
00:13:45,510 --> 00:13:48,090
in order to provide a satisfactory set

360
00:13:48,090 --> 00:13:51,150
of recommended restaurants
and dishes back to the user,

361
00:13:51,150 --> 00:13:53,550
as a sort of manual double checking.

362
00:13:53,550 --> 00:13:55,080
Because there's a lot of querying

363
00:13:55,080 --> 00:13:57,270
that happens in between the initial query

364
00:13:57,270 --> 00:13:58,830
and the retrieved context,

365
00:13:58,830 --> 00:14:01,620
you're gonna want something
that persists beyond that,

366
00:14:01,620 --> 00:14:05,040
that evaluates against what
the agent has already generated

367
00:14:05,040 --> 00:14:07,890
in order to increase the
quality of the results.

368
00:14:07,890 --> 00:14:10,170
For example, it's extremely important

369
00:14:10,170 --> 00:14:11,850
that we adhere to the allergens

370
00:14:11,850 --> 00:14:13,740
that are described inside this query.

371
00:14:13,740 --> 00:14:17,010
So it makes sense for us
to extract that as a item

372
00:14:17,010 --> 00:14:18,150
in our checklist

373
00:14:18,150 --> 00:14:20,580
and to evaluate the
return results at the end

374
00:14:20,580 --> 00:14:23,670
of this querying workflow
against the agent

375
00:14:23,670 --> 00:14:27,000
to ensure that those tests pass.

376
00:14:27,000 --> 00:14:28,980
Or we wanna make sure that the restaurant

377
00:14:28,980 --> 00:14:30,360
has a date night atmosphere,

378
00:14:30,360 --> 00:14:31,800
so on and so forth.

379
00:14:31,800 --> 00:14:34,770
Having the opportunity to
implement this additional check

380
00:14:34,770 --> 00:14:36,900
at the end is really useful

381
00:14:36,900 --> 00:14:39,300
for us to guarantee the
quality of the results

382
00:14:39,300 --> 00:14:42,750
that we end up passing back
to the recommendation system.

383
00:14:42,750 --> 00:14:44,310
And we're comfortable sacrificing

384
00:14:44,310 --> 00:14:45,930
some of the latency costs here,

385
00:14:45,930 --> 00:14:47,970
because of the increase in the relevancy

386
00:14:47,970 --> 00:14:50,154
at the end of this workflow.

387
00:14:50,154 --> 00:14:53,820
So the main takeaways
behind this architecture is,

388
00:14:53,820 --> 00:14:56,250
we're able to use agentic retrieval

389
00:14:56,250 --> 00:14:58,500
in areas where traditional RAG would fail

390
00:14:58,500 --> 00:15:00,780
and three specific benefits.

391
00:15:00,780 --> 00:15:02,820
The first is query understanding,

392
00:15:02,820 --> 00:15:05,520
which is we allow for a deep planning

393
00:15:05,520 --> 00:15:09,150
and reasoning capability to
decompose complex queries

394
00:15:09,150 --> 00:15:13,170
and serve users that have
really complicated preferences.

395
00:15:13,170 --> 00:15:15,600
The second is optimizing retrieval,

396
00:15:15,600 --> 00:15:18,600
where agentic RAG allows
us to have dynamic access

397
00:15:18,600 --> 00:15:20,340
to all of the data sources

398
00:15:20,340 --> 00:15:23,430
which have been made ergonomic
for the agent to use,

399
00:15:23,430 --> 00:15:25,350
provided that they're accessible.

400
00:15:25,350 --> 00:15:27,540
And this allows us to optimize the context

401
00:15:27,540 --> 00:15:30,720
that is then retrieved
for the generation step.

402
00:15:30,720 --> 00:15:33,570
Finally, we implement
iterative generation,

403
00:15:33,570 --> 00:15:35,190
which allows for looping

404
00:15:35,190 --> 00:15:36,960
and increases the perceived quality

405
00:15:36,960 --> 00:15:38,100
of the generation results.

406
00:15:38,100 --> 00:15:39,840
And like I said, we're comfortable

407
00:15:39,840 --> 00:15:42,120
sacrificing some of the latency costs here

408
00:15:42,120 --> 00:15:43,710
in order to increase the
quality of the results,

409
00:15:43,710 --> 00:15:45,750
because we care so much about making sure

410
00:15:45,750 --> 00:15:47,700
that couple goes on a great first date.

411
00:15:49,320 --> 00:15:51,510
Now if you wanna learn
how to build agentic RAG

412
00:15:51,510 --> 00:15:53,430
and you're kind of a
little tired of the example

413
00:15:53,430 --> 00:15:54,750
that I'm kind of going through,

414
00:15:54,750 --> 00:15:56,370
go ahead and scan this QR code

415
00:15:56,370 --> 00:15:59,220
where you can learn about how
other customers with Pinecone

416
00:15:59,220 --> 00:16:01,140
have implemented agentic RAG,

417
00:16:01,140 --> 00:16:05,400
such as Delphi, Aquant,
Terminal X, and CustomGPT.

418
00:16:05,400 --> 00:16:07,530
This will take you straight
to the case study section

419
00:16:07,530 --> 00:16:08,550
on our website

420
00:16:08,550 --> 00:16:10,350
where we can learn how real customers

421
00:16:10,350 --> 00:16:12,450
have implemented real architectures

422
00:16:12,450 --> 00:16:13,923
implementing agentic RAG.

423
00:16:16,020 --> 00:16:17,580
Thanks so much for coming to my talk.

424
00:16:17,580 --> 00:16:19,980
If you have any more questions
for me about how to do this,

425
00:16:19,980 --> 00:16:21,300
please meet me at the back.

426
00:16:21,300 --> 00:16:22,860
I'll be happy to speak with you.

427
00:16:22,860 --> 00:16:26,130
My team is at booth 534
in that corner over there,

428
00:16:26,130 --> 00:16:26,963
so if you're interested

429
00:16:26,963 --> 00:16:28,650
in having a more in-depth conversation,

430
00:16:28,650 --> 00:16:30,060
we'd be happy to have you.

431
00:16:30,060 --> 00:16:31,310
Thanks so much everybody.

