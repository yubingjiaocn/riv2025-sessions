1
00:00:00,810 --> 00:00:04,620
- Hi everyone, and welcome to DEV 415

2
00:00:04,620 --> 00:00:05,790
where we are gonna look at

3
00:00:05,790 --> 00:00:10,470
how to build scalable,
self-orchestrating AI workflows

4
00:00:10,470 --> 00:00:12,900
with A2A and MCP.

5
00:00:12,900 --> 00:00:14,190
My name is Gunnar Grosch,

6
00:00:14,190 --> 00:00:16,203
I am a developer advocate at AWS.

7
00:00:17,250 --> 00:00:19,410
- And my name is Allen Helton.

8
00:00:19,410 --> 00:00:21,030
I'm an AWS serverless hero

9
00:00:21,030 --> 00:00:24,300
and an ecosystem engineer at Momento.

10
00:00:24,300 --> 00:00:26,790
- So, this is a 400-level session,

11
00:00:26,790 --> 00:00:30,990
so we're gonna assume that
you know some things about AWS

12
00:00:30,990 --> 00:00:34,410
and certain things about the
services we're gonna use,

13
00:00:34,410 --> 00:00:36,900
but we are specifically
gonna focus on a few things.

14
00:00:36,900 --> 00:00:39,960
For instance, the
agent-to-agent protocol, A2A,

15
00:00:39,960 --> 00:00:42,510
MCP, Model Context Protocol,

16
00:00:42,510 --> 00:00:44,940
and some of the specifics
around the services

17
00:00:44,940 --> 00:00:47,910
we're using to build these agents.

18
00:00:47,910 --> 00:00:51,180
And we're gonna do it by
showing a lot of the concepts.

19
00:00:51,180 --> 00:00:52,110
We're gonna jump in

20
00:00:52,110 --> 00:00:55,620
and show some demos as
well all throughout.

21
00:00:55,620 --> 00:00:58,980
So, this is basically,
what we're gonna cover.

22
00:00:58,980 --> 00:01:02,520
How you can design these
self-orchestrating systems

23
00:01:02,520 --> 00:01:06,090
using choreography instead
of central control.

24
00:01:06,090 --> 00:01:10,710
We will look at, like I said,
the A2A protocol and MCP.

25
00:01:10,710 --> 00:01:12,000
How you can use that so they

26
00:01:12,000 --> 00:01:14,280
can discover each other, these agents,

27
00:01:14,280 --> 00:01:15,930
and how they can do that

28
00:01:15,930 --> 00:01:18,540
and invoke each other in a dynamical way.

29
00:01:18,540 --> 00:01:22,710
And then how MCP gives
agents the consistent way

30
00:01:22,710 --> 00:01:25,470
to access tools, context, and data.

31
00:01:25,470 --> 00:01:28,800
And then finally, how AgentCore and Lambda

32
00:01:28,800 --> 00:01:33,303
can turn these agents into
autonomous, scalable workloads.

33
00:01:35,820 --> 00:01:37,800
- Okay, so why are we here?

34
00:01:37,800 --> 00:01:41,970
Why is there even a session
on this in the first place?

35
00:01:41,970 --> 00:01:45,420
Well, if anyone here has used AI agents

36
00:01:45,420 --> 00:01:47,070
before generative AI,

37
00:01:47,070 --> 00:01:49,470
we should already know that generative AI

38
00:01:49,470 --> 00:01:51,540
doesn't really follow linear playbooks.

39
00:01:51,540 --> 00:01:52,440
It's kinda the Wild West.

40
00:01:52,440 --> 00:01:54,240
You never know what you're gonna get.

41
00:01:54,240 --> 00:01:57,270
Reasoning jumps based on context,

42
00:01:57,270 --> 00:01:59,910
definitely not on your code.

43
00:01:59,910 --> 00:02:01,800
So, we need to prepare for that.

44
00:02:01,800 --> 00:02:05,700
And every single task
that you give an AI agent

45
00:02:05,700 --> 00:02:07,500
can potentially take a different path,

46
00:02:07,500 --> 00:02:12,000
even if you call it multiple
times with the same context.

47
00:02:12,000 --> 00:02:15,810
And so, because of that, that
whole paradigm in general,

48
00:02:15,810 --> 00:02:19,440
static wiring with traditional
orchestration services

49
00:02:19,440 --> 00:02:23,100
don't really work the same way.

50
00:02:23,100 --> 00:02:27,120
So, what we need is to break out agents

51
00:02:27,120 --> 00:02:29,100
and we need to have agents
that talk to each other,

52
00:02:29,100 --> 00:02:33,030
agents that collaborate
with each other at runtime.

53
00:02:33,030 --> 00:02:36,520
Ones that can adapt workflows safely

54
00:02:37,410 --> 00:02:41,310
and ones that have stable outcomes,

55
00:02:41,310 --> 00:02:45,900
even if their reasoning
isn't always right on track.

56
00:02:45,900 --> 00:02:49,350
And this really can be
boiled down to the debate

57
00:02:49,350 --> 00:02:52,230
of choreography versus orchestration.

58
00:02:52,230 --> 00:02:56,073
And it is, it is kind of, kind of.

59
00:02:57,270 --> 00:02:59,310
Choreography is powerful,

60
00:02:59,310 --> 00:03:00,720
but if you've ever used it,

61
00:03:00,720 --> 00:03:04,110
it can be a little bit
tricky when you start

62
00:03:04,110 --> 00:03:07,623
introducing non-determinism
in your structure.

63
00:03:09,030 --> 00:03:12,090
And as much as we'd like to think

64
00:03:12,090 --> 00:03:17,090
that coordinating agents is
just this ideal pie in the sky,

65
00:03:17,130 --> 00:03:19,290
it's a lot like a game of telephone,

66
00:03:19,290 --> 00:03:21,060
if you've ever played that.

67
00:03:21,060 --> 00:03:25,650
Where each agent along the chain
adds its own interpretation

68
00:03:25,650 --> 00:03:29,520
instead of clarity on the
commands that came in.

69
00:03:29,520 --> 00:03:31,770
And so, these small little deviations

70
00:03:31,770 --> 00:03:35,160
compound into major workflow errors

71
00:03:35,160 --> 00:03:37,920
or very, very different outcomes,

72
00:03:37,920 --> 00:03:40,260
if you don't set it up right.

73
00:03:40,260 --> 00:03:43,380
Maybe you have the wrong
collaborator inside of a workflow

74
00:03:43,380 --> 00:03:45,090
or you have the wrong action,

75
00:03:45,090 --> 00:03:46,920
either way, you're gonna
get the wrong outcome,

76
00:03:46,920 --> 00:03:49,070
which is really what
we're concerned about.

77
00:03:50,940 --> 00:03:55,113
Collaborating on a shared
plan, separating that work out,

78
00:03:56,490 --> 00:03:57,630
is really what we're looking for.

79
00:03:57,630 --> 00:03:59,220
So, if you don't have that,

80
00:03:59,220 --> 00:04:02,940
which sometimes can be
seen in choreography,

81
00:04:02,940 --> 00:04:04,110
you're not gonna be able
to reproduce results.

82
00:04:04,110 --> 00:04:05,700
You're not gonna get consistent outcomes

83
00:04:05,700 --> 00:04:08,040
inside of your complex workflows.

84
00:04:08,040 --> 00:04:10,920
So, debugging and when you're
actually in production,

85
00:04:10,920 --> 00:04:14,190
practical considerations means that

86
00:04:14,190 --> 00:04:17,670
you have to reconstruct a he
said she said kind of deal,

87
00:04:17,670 --> 00:04:19,170
and that's very difficult.

88
00:04:19,170 --> 00:04:22,170
So, what we're here today
really to talk about

89
00:04:22,170 --> 00:04:27,030
is that autonomy without rules is chaos.

90
00:04:27,030 --> 00:04:32,030
Absolute sheer and utter
use case for no success.

91
00:04:32,550 --> 00:04:34,680
And that's why we're
gonna be talking about

92
00:04:34,680 --> 00:04:36,330
deterministic coordination

93
00:04:36,330 --> 00:04:39,000
and really hounding on determinism

94
00:04:39,000 --> 00:04:41,523
in a non-deterministic paradigm.

95
00:04:42,930 --> 00:04:46,080
- So, we're gonna jump
straight into our first demo.

96
00:04:46,080 --> 00:04:48,360
Before we dive into actually,

97
00:04:48,360 --> 00:04:50,190
using multi-agent coordination,

98
00:04:50,190 --> 00:04:53,280
we're gonna start with one
single autonomous agent.

99
00:04:53,280 --> 00:04:56,130
So, that gives us all a
clean baseline basically,

100
00:04:56,130 --> 00:04:59,970
to see how agent in the loop in action

101
00:04:59,970 --> 00:05:01,950
without anything else involved.

102
00:05:01,950 --> 00:05:05,130
So, think of this as kind
of a warmup to it all then.

103
00:05:05,130 --> 00:05:09,300
One task, one agent,
and one clean workflow.

104
00:05:09,300 --> 00:05:11,550
So once you understand how this works,

105
00:05:11,550 --> 00:05:13,440
I think a lot of the
things around multi-agent

106
00:05:13,440 --> 00:05:16,410
will become much easier
to understand as well.

107
00:05:16,410 --> 00:05:19,530
So, this is the first demo.

108
00:05:19,530 --> 00:05:22,560
We're looking at a, think
very common situation

109
00:05:22,560 --> 00:05:24,680
in the last mile delivery.

110
00:05:24,680 --> 00:05:27,240
Driver arrives at a customer's address

111
00:05:27,240 --> 00:05:28,530
to drop off a package,

112
00:05:28,530 --> 00:05:30,510
but the customer isn't home.

113
00:05:30,510 --> 00:05:34,980
So, instead of turning this
into a manual exception

114
00:05:34,980 --> 00:05:36,990
that someone has to follow up on later,

115
00:05:36,990 --> 00:05:40,530
we want the system to take
the next step automatically.

116
00:05:40,530 --> 00:05:42,363
So, the moment the driver reports

117
00:05:42,363 --> 00:05:45,420
that the delivery
attempt was unsuccessful,

118
00:05:45,420 --> 00:05:48,900
the agent will then
evaluate that situation.

119
00:05:48,900 --> 00:05:52,170
And this scenario is
intentionally very simple.

120
00:05:52,170 --> 00:05:54,450
It shows how one single agent

121
00:05:54,450 --> 00:05:57,630
can then react to these real-world events,

122
00:05:57,630 --> 00:05:59,370
interpret what it means,

123
00:05:59,370 --> 00:06:01,890
and take an appropriate next action.

124
00:06:01,890 --> 00:06:06,360
So, like I said, it's there to
give us a baseline for this.

125
00:06:06,360 --> 00:06:09,240
So, Allen, take it away.

126
00:06:09,240 --> 00:06:10,143
- [Allen] Okay.

127
00:06:12,390 --> 00:06:17,390
So, here we have our
delivery driver web portal.

128
00:06:17,790 --> 00:06:18,810
This is what they look at

129
00:06:18,810 --> 00:06:21,720
whenever they are unable
to deliver a package.

130
00:06:21,720 --> 00:06:24,930
And this is for my logistics
company, Swift Ship,

131
00:06:24,930 --> 00:06:26,883
number one competitor to amazon.com.

132
00:06:28,380 --> 00:06:31,740
And as you can see here, we're not,

133
00:06:31,740 --> 00:06:33,120
we don't have chat interfaces,

134
00:06:33,120 --> 00:06:35,520
really we're just filling out a web form.

135
00:06:35,520 --> 00:06:37,230
We're gonna say that the customer

136
00:06:37,230 --> 00:06:39,600
is not available for delivery.

137
00:06:39,600 --> 00:06:41,160
We'd left a notice on their mailbox,

138
00:06:41,160 --> 00:06:44,130
and we'll attempt redelivery tomorrow.

139
00:06:44,130 --> 00:06:45,510
This is this scenario I imagine

140
00:06:45,510 --> 00:06:48,273
many of us have run across before.

141
00:06:49,140 --> 00:06:52,380
Very frustrating, but
it is a fact of life.

142
00:06:52,380 --> 00:06:55,620
It's what we're gonna see here
is a peek behind the curtain

143
00:06:55,620 --> 00:06:59,400
for what is actually,
happening behind the scenes.

144
00:06:59,400 --> 00:07:01,083
And you can see here that,

145
00:07:01,920 --> 00:07:03,570
and this is updating in
real time by the way.

146
00:07:03,570 --> 00:07:05,370
So, you can see here that
we're gonna schedule that order

147
00:07:05,370 --> 00:07:08,310
for delivery with our
order management agent

148
00:07:08,310 --> 00:07:10,200
and then we're gonna notify the customer

149
00:07:10,200 --> 00:07:12,003
of that rescheduled delivery.

150
00:07:13,380 --> 00:07:17,490
Now, like you said, this is
an intentionally simple demo.

151
00:07:17,490 --> 00:07:20,340
Probably the most boring
one you'll see this week.

152
00:07:20,340 --> 00:07:22,050
- Underwhelming, I think is the word.

153
00:07:22,050 --> 00:07:22,883
- Underwhelming, yes,

154
00:07:22,883 --> 00:07:25,080
that's the word I was
definitely looking for.

155
00:07:25,080 --> 00:07:27,450
The word I used to describe all my demos.

156
00:07:27,450 --> 00:07:32,450
But the point there is that
that's an agentic workflow

157
00:07:33,000 --> 00:07:35,250
that is about as simple as it gets

158
00:07:35,250 --> 00:07:37,170
and it has run through everything

159
00:07:37,170 --> 00:07:38,760
that we are about to talk about.

160
00:07:38,760 --> 00:07:42,222
- Yeah, so before we start
wiring these agents together,

161
00:07:42,222 --> 00:07:45,420
we need to align on some
of the technical primitives

162
00:07:45,420 --> 00:07:48,270
that make these autonomous systems viable.

163
00:07:48,270 --> 00:07:52,020
So, these aren't high-level
concepts, they're mechanisms

164
00:07:52,020 --> 00:07:56,700
that then keep these multi-agent
workflows deterministic,

165
00:07:56,700 --> 00:07:59,430
like Allen talked about, and reliable.

166
00:07:59,430 --> 00:08:02,340
So, if these foundations aren't solid,

167
00:08:02,340 --> 00:08:06,000
well, choreography is
gonna break down quickly.

168
00:08:06,000 --> 00:08:09,750
So, let's look at some of
these foundation to begin with.

169
00:08:09,750 --> 00:08:12,030
And I've mentioned agent to agent,

170
00:08:12,030 --> 00:08:13,740
A2A protocol a couple of times.

171
00:08:13,740 --> 00:08:15,990
And that is what gives our agents

172
00:08:15,990 --> 00:08:19,620
a consistent way to discover each other,

173
00:08:19,620 --> 00:08:21,900
and then also to collaborate.

174
00:08:21,900 --> 00:08:24,270
Each agent they publish an agent card

175
00:08:24,270 --> 00:08:26,220
that defines its capabilities

176
00:08:26,220 --> 00:08:29,670
and the version of each
capability that it has,

177
00:08:29,670 --> 00:08:32,820
and the input schemas
that it's gonna expect.

178
00:08:32,820 --> 00:08:36,540
In our architecture, we are
using these capabilities

179
00:08:36,540 --> 00:08:39,810
and exposing them through
Lambda function URLs,

180
00:08:39,810 --> 00:08:41,490
you'll see that later.

181
00:08:41,490 --> 00:08:44,400
It means that each agent is reachable

182
00:08:44,400 --> 00:08:47,730
through just standard HTTP endpoints.

183
00:08:47,730 --> 00:08:50,400
And when one agent needs another

184
00:08:50,400 --> 00:08:52,530
to perform some sort of work,

185
00:08:52,530 --> 00:08:56,580
it is then just gonna create
a typed A2A invocation.

186
00:08:56,580 --> 00:08:59,910
And this invocation includes
the capability name,

187
00:08:59,910 --> 00:09:03,180
the version, the task identifier,

188
00:09:03,180 --> 00:09:05,940
and some sort of structured JSON payload

189
00:09:05,940 --> 00:09:08,550
that then conforms to that schema

190
00:09:08,550 --> 00:09:11,493
that was a advertised in the agent card.

191
00:09:12,840 --> 00:09:16,650
Then, we had Model Context Protocol, MCP.

192
00:09:16,650 --> 00:09:19,950
And that's, I think most
people now know what it means.

193
00:09:19,950 --> 00:09:21,960
It feels like it's been around for ages.

194
00:09:21,960 --> 00:09:24,420
It turned one year a month ago?

195
00:09:24,420 --> 00:09:25,920
- Yeah, if even.
- Something like that.

196
00:09:25,920 --> 00:09:28,260
So, but it feels like it's
something we all know by now,

197
00:09:28,260 --> 00:09:32,370
but MCP provides us with
this standardized way

198
00:09:32,370 --> 00:09:36,570
for agents to load context
and interact with tools.

199
00:09:36,570 --> 00:09:41,010
Instead of passing raw
text or unstructured data,

200
00:09:41,010 --> 00:09:43,890
agents can call these MCP tools

201
00:09:43,890 --> 00:09:47,310
that expose typed validated interfaces.

202
00:09:47,310 --> 00:09:50,730
So, that could be shipment
data, order information,

203
00:09:50,730 --> 00:09:55,730
it could be inventory levels,
other types of workflow inputs

204
00:09:55,950 --> 00:09:58,680
that are all retrieved
through these tools.

205
00:09:58,680 --> 00:10:01,500
So, MCP is what ensures

206
00:10:01,500 --> 00:10:04,020
that every interaction follows a schema.

207
00:10:04,020 --> 00:10:09,020
That removes ambiguity-
- Nice.

208
00:10:09,750 --> 00:10:13,680
- and improves the reliability
of model reasoning.

209
00:10:13,680 --> 00:10:17,370
So, MCP tools, they define

210
00:10:17,370 --> 00:10:20,580
these strict input and output shapes.

211
00:10:20,580 --> 00:10:24,600
Agents will then always work
with predictable structures.

212
00:10:24,600 --> 00:10:26,010
And that's super important,

213
00:10:26,010 --> 00:10:28,320
because it means that the
behavior of the system

214
00:10:28,320 --> 00:10:31,140
remains stable even when multiple agents

215
00:10:31,140 --> 00:10:33,063
are relying on that same data.

216
00:10:34,620 --> 00:10:37,110
And then we have our
core services, of course,

217
00:10:37,110 --> 00:10:39,540
and the system is built on

218
00:10:39,540 --> 00:10:42,120
three core system or services for us.

219
00:10:42,120 --> 00:10:45,180
Together that then support
these autonomous agents.

220
00:10:45,180 --> 00:10:47,700
The agents themselves in our architecture,

221
00:10:47,700 --> 00:10:50,490
they're gonna run as
standard Lambda functions.

222
00:10:50,490 --> 00:10:52,260
So, nothing strange about that.

223
00:10:52,260 --> 00:10:55,230
Each Lambda execution is isolated,

224
00:10:55,230 --> 00:10:59,520
which means that every Agent
Loop starts with a clean state

225
00:10:59,520 --> 00:11:01,590
and it loads exactly the state

226
00:11:01,590 --> 00:11:04,380
that it needs to have once it's invoked.

227
00:11:04,380 --> 00:11:08,157
So Lambda, as we all know,
it gives us elasticity,

228
00:11:08,157 --> 00:11:11,190
it's predictable concurrency behavior,

229
00:11:11,190 --> 00:11:13,140
so the things we need to be able

230
00:11:13,140 --> 00:11:15,600
to build these scalable systems.

231
00:11:15,600 --> 00:11:17,850
We have Bedrock AgentCore as well

232
00:11:17,850 --> 00:11:21,540
and we're using two capabilities
within Bedrock AgentCore.

233
00:11:21,540 --> 00:11:25,230
We're using memory and we use
observability for our agents.

234
00:11:25,230 --> 00:11:28,170
So, since Lambda doesn't have any

235
00:11:28,170 --> 00:11:30,780
built-in state between invocations,

236
00:11:30,780 --> 00:11:32,910
we are using AgentCore memory

237
00:11:32,910 --> 00:11:36,480
as a way to store and
retrieve task information.

238
00:11:36,480 --> 00:11:39,570
And that gives us a consistent view

239
00:11:39,570 --> 00:11:43,980
of what has already happened
basically within that workflow,

240
00:11:43,980 --> 00:11:47,130
even when multiple agents are contributing

241
00:11:47,130 --> 00:11:50,490
and collaborating on the same
tasks at different times.

242
00:11:50,490 --> 00:11:54,030
And then we're using Momento,
that's where Allen works.

243
00:11:54,030 --> 00:11:56,580
Momento is our,

244
00:11:56,580 --> 00:11:59,580
I think we can call it our
fast coordination layer.

245
00:11:59,580 --> 00:12:04,580
It's using this Momento
cache for lightweight state.

246
00:12:05,220 --> 00:12:09,464
Cashed MCP tool responses
and quick lookups

247
00:12:09,464 --> 00:12:13,560
to do things that really don't belong

248
00:12:13,560 --> 00:12:15,720
in any durable or long-term storage.

249
00:12:15,720 --> 00:12:20,370
So, this gives us low latency
access to shared information

250
00:12:20,370 --> 00:12:23,640
without slowing down
that entire Agent Loop

251
00:12:23,640 --> 00:12:24,630
that we'll look at.

252
00:12:24,630 --> 00:12:27,363
So, those are our three main components.

253
00:12:30,510 --> 00:12:32,640
- And before we go any further,

254
00:12:32,640 --> 00:12:34,440
we've talked about what we're building,

255
00:12:34,440 --> 00:12:35,610
but now we're gonna talk about

256
00:12:35,610 --> 00:12:38,400
what specifically we're gonna be building.

257
00:12:38,400 --> 00:12:39,900
In order to do that,

258
00:12:39,900 --> 00:12:43,080
I kinda wanna take you
three years back in time

259
00:12:43,080 --> 00:12:45,510
when ChatGPT was first introduced.

260
00:12:45,510 --> 00:12:48,990
It was a marvel at the time

261
00:12:48,990 --> 00:12:53,990
and looking at it now is still
great, but it is a chat bot.

262
00:12:54,540 --> 00:12:56,580
I ask it something, it responds to me,

263
00:12:56,580 --> 00:12:58,800
I ask it something else,
it responds to me again.

264
00:12:58,800 --> 00:13:01,110
And that's really the
extent of the exchange

265
00:13:01,110 --> 00:13:02,883
I can have with a chat bot.

266
00:13:04,230 --> 00:13:05,640
Fast forward a little bit,

267
00:13:05,640 --> 00:13:10,140
and the Model Context
Protocol releases last year

268
00:13:10,140 --> 00:13:14,550
and agents started booming,
everybody started making agents.

269
00:13:14,550 --> 00:13:17,100
Now, what's the difference
between an agent

270
00:13:17,100 --> 00:13:19,770
and what we were doing with ChatGPT?

271
00:13:19,770 --> 00:13:22,560
Well, an agent, it's basically a chat bot,

272
00:13:22,560 --> 00:13:24,930
but it's been empowered to do something.

273
00:13:24,930 --> 00:13:27,900
It's been given code via tools

274
00:13:27,900 --> 00:13:30,450
that it can actually go and
do things on your behalf.

275
00:13:30,450 --> 00:13:35,160
So, if you say, go book me
a flight or what, you know,

276
00:13:35,160 --> 00:13:39,030
where can I go to buy a
pineapple for my pizza?

277
00:13:39,030 --> 00:13:42,750
It'll look it up, say, "Oh
that's on Maui probably.

278
00:13:42,750 --> 00:13:44,659
Let me book you a flight
there," and it'll do that.

279
00:13:44,659 --> 00:13:47,309
It'll actually do that, but
as part of that exchange.

280
00:13:48,900 --> 00:13:51,510
But that's really not it.

281
00:13:51,510 --> 00:13:53,160
That's not what we're building today,

282
00:13:53,160 --> 00:13:56,760
because that's still a chat interface.

283
00:13:56,760 --> 00:13:58,800
I'm talking to it, it's
talking back to me,

284
00:13:58,800 --> 00:14:00,420
but it's also doing things too.

285
00:14:00,420 --> 00:14:04,830
But what we're talking about
today is autonomous agents.

286
00:14:04,830 --> 00:14:07,683
These are agents that you can't see.

287
00:14:09,420 --> 00:14:14,070
These sit behind and are placed
inside of your architecture.

288
00:14:14,070 --> 00:14:16,350
Ones that hopefully, you're
already pretty familiar with.

289
00:14:16,350 --> 00:14:20,280
That run async in the background
that never see humans.

290
00:14:20,280 --> 00:14:24,330
These are responding to
events in your system.

291
00:14:24,330 --> 00:14:27,840
These are actually, responding
to things that happen.

292
00:14:27,840 --> 00:14:30,300
So, in a very basic situation,

293
00:14:30,300 --> 00:14:34,860
really what the Swift Ship
delivery system is doing for us

294
00:14:34,860 --> 00:14:37,320
is inputs come in via API gateway.

295
00:14:37,320 --> 00:14:38,250
There's a compute layer,

296
00:14:38,250 --> 00:14:41,610
sometimes with Lambda, goes to DynamoDB

297
00:14:41,610 --> 00:14:44,670
and from there we can
execute our async workflows

298
00:14:44,670 --> 00:14:45,780
with something like EventBridge

299
00:14:45,780 --> 00:14:48,690
that then passes all the data necessary

300
00:14:48,690 --> 00:14:52,170
to an agent maybe running in Lambda

301
00:14:52,170 --> 00:14:54,810
that responds to that specific event.

302
00:14:54,810 --> 00:14:57,870
So, very different from a chat bot

303
00:14:57,870 --> 00:14:59,250
that has been given a tool.

304
00:14:59,250 --> 00:15:01,470
This is something that's interacting

305
00:15:01,470 --> 00:15:03,970
as a result of something
happening in your system.

306
00:15:06,690 --> 00:15:10,110
- So, the autonomous agents
that you'll see here today,

307
00:15:10,110 --> 00:15:13,020
they are built on what
we call the Agent Loop.

308
00:15:13,020 --> 00:15:14,460
It's a very simple,

309
00:15:14,460 --> 00:15:18,150
but yet very powerful
way to look at agents.

310
00:15:18,150 --> 00:15:21,270
And I think once you
understand the Agent Loop,

311
00:15:21,270 --> 00:15:22,590
a lot of the entire architecture

312
00:15:22,590 --> 00:15:24,340
makes a lot of sense straight away.

313
00:15:25,260 --> 00:15:28,440
So, the Agent Loop is the execution model

314
00:15:28,440 --> 00:15:30,990
that every agent should follow basically.

315
00:15:30,990 --> 00:15:32,250
No matter where it runs,

316
00:15:32,250 --> 00:15:34,710
if it's in Lambda as a Lambda function,

317
00:15:34,710 --> 00:15:37,350
if it's running in
AgentCore, or in a container,

318
00:15:37,350 --> 00:15:39,570
or in EC2 instance anywhere.

319
00:15:39,570 --> 00:15:43,230
This loop isn't tied to a
specific compute service.

320
00:15:43,230 --> 00:15:44,310
It's more of a discipline

321
00:15:44,310 --> 00:15:46,980
of how to build these autonomous agents

322
00:15:46,980 --> 00:15:50,490
so that they behave predictably at scale.

323
00:15:50,490 --> 00:15:53,070
So each iteration of the
loop, it looks the same.

324
00:15:53,070 --> 00:15:55,590
We start with the Compose phase,

325
00:15:55,590 --> 00:16:00,210
it loads its typed
context through MCP tools

326
00:16:00,210 --> 00:16:02,040
and retrieves tasks state

327
00:16:02,040 --> 00:16:04,860
from AgentCore memory for instance.

328
00:16:04,860 --> 00:16:08,370
Then we move on to query
where we call the model.

329
00:16:08,370 --> 00:16:11,370
And in our case that's using Bedrock

330
00:16:11,370 --> 00:16:12,930
where we call the model through.

331
00:16:12,930 --> 00:16:15,480
And that gives us a structured tool result

332
00:16:15,480 --> 00:16:17,373
and a schema-aligned output.

333
00:16:18,330 --> 00:16:19,890
Then we have the Execute phase

334
00:16:19,890 --> 00:16:21,750
where we actually do something,

335
00:16:21,750 --> 00:16:24,060
and that maps that structured output

336
00:16:24,060 --> 00:16:26,760
from the LLM to real actions.

337
00:16:26,760 --> 00:16:30,630
Those could be A2A in vocations,
it could be an API call,

338
00:16:30,630 --> 00:16:33,215
or memory updates for instance.

339
00:16:33,215 --> 00:16:35,010
And then we have a question,

340
00:16:35,010 --> 00:16:37,680
should we continue the
loop or are we done?

341
00:16:37,680 --> 00:16:41,370
So, we decide whether
the workflow is complete

342
00:16:41,370 --> 00:16:42,960
or if we should persist state

343
00:16:42,960 --> 00:16:45,480
and then run another iteration of it.

344
00:16:45,480 --> 00:16:48,870
So, by following this
pattern consistently,

345
00:16:48,870 --> 00:16:52,380
each one of our agents,
they become re-entrant,

346
00:16:52,380 --> 00:16:54,270
they become even potent,

347
00:16:54,270 --> 00:16:58,320
and they are safe to run
in a distributed system.

348
00:16:58,320 --> 00:17:00,060
So, let's break down these phases

349
00:17:00,060 --> 00:17:02,360
to look more exactly
what that actually means.

350
00:17:03,450 --> 00:17:05,190
So the first one Compose,

351
00:17:05,190 --> 00:17:08,910
that's the phase where we
transform an incoming event

352
00:17:08,910 --> 00:17:11,490
into a deterministic input package

353
00:17:11,490 --> 00:17:14,010
for each or for the model.

354
00:17:14,010 --> 00:17:17,100
So, even though our agents
run as Lambda functions,

355
00:17:17,100 --> 00:17:21,600
like we've said, this loop
structure is platform agnostic.

356
00:17:21,600 --> 00:17:25,140
And in Compose, the first thing
we do is we hydrate context

357
00:17:25,140 --> 00:17:27,180
through for instance MCP tools.

358
00:17:27,180 --> 00:17:32,180
And these tools enforce strict
schemas and validation rules.

359
00:17:32,430 --> 00:17:36,180
And the agent always begins
with types structured data

360
00:17:36,180 --> 00:17:39,510
instead of having loosely
formatted prompt text,

361
00:17:39,510 --> 00:17:41,400
like in a chat for instance.

362
00:17:41,400 --> 00:17:46,380
So after that, the agent
reconstructs any prior task state

363
00:17:46,380 --> 00:17:49,560
that it might have from
AgentCore memory in our case.

364
00:17:49,560 --> 00:17:52,200
And because Lambda
functions are stateless,

365
00:17:52,200 --> 00:17:55,320
this is what makes the loop re-entrant.

366
00:17:55,320 --> 00:17:59,400
Every iteration will
lo load its own history

367
00:17:59,400 --> 00:18:03,780
and the context instead of
relying on warm function state.

368
00:18:03,780 --> 00:18:05,400
And once the data is assembled,

369
00:18:05,400 --> 00:18:08,940
we start building that
system prompt that we use,

370
00:18:08,940 --> 00:18:11,790
and we follow something
called the RISEN framework.

371
00:18:11,790 --> 00:18:15,480
And this creates a stable contrast

372
00:18:15,480 --> 00:18:18,360
for the model and its behavior.

373
00:18:18,360 --> 00:18:20,910
The role section defines exactly

374
00:18:20,910 --> 00:18:23,430
what the agent is responsible for.

375
00:18:23,430 --> 00:18:26,580
So, it stays focused on its role.

376
00:18:26,580 --> 00:18:30,090
Instructions specify how
the model must behave

377
00:18:30,090 --> 00:18:34,680
and that includes constraints
and error handling rules.

378
00:18:34,680 --> 00:18:38,160
Then steps outline the
deterministic procedure

379
00:18:38,160 --> 00:18:42,930
that each agent follows
on every iteration.

380
00:18:42,930 --> 00:18:44,760
And then expectations that

381
00:18:44,760 --> 00:18:47,430
describes the precise output shape

382
00:18:47,430 --> 00:18:49,650
that the model must return,

383
00:18:49,650 --> 00:18:51,630
and that's anchored in the same schemas

384
00:18:51,630 --> 00:18:53,730
that our code will validate.

385
00:18:53,730 --> 00:18:55,680
And then finally narrowing.

386
00:18:55,680 --> 00:18:59,010
It makes the agent's boundaries explicit

387
00:18:59,010 --> 00:19:02,040
by stating what it must not do.

388
00:19:02,040 --> 00:19:06,140
So, to make it even more clear,
this is a simplified version

389
00:19:06,140 --> 00:19:09,720
of the system prompt used
by one of our agents.

390
00:19:09,720 --> 00:19:13,020
And it's structured as you
can see according to RISEN.

391
00:19:13,020 --> 00:19:15,870
So, when you read through
it through that lens,

392
00:19:15,870 --> 00:19:17,910
it becomes clear that it's not just

393
00:19:17,910 --> 00:19:21,270
a block of descriptive text for the agent,

394
00:19:21,270 --> 00:19:24,330
it's a behavioral contract
that it must follow.

395
00:19:24,330 --> 00:19:25,920
So, we have the role

396
00:19:25,920 --> 00:19:29,250
for the specific warehouse
management agent,

397
00:19:29,250 --> 00:19:31,950
we have the instructions,
we have the steps,

398
00:19:31,950 --> 00:19:34,680
what are the steps for
it, what it should do.

399
00:19:34,680 --> 00:19:37,470
Then we have the expectations,
what it's supposed to do,

400
00:19:37,470 --> 00:19:39,300
and then narrowing,

401
00:19:39,300 --> 00:19:42,303
making sure that it stays
within its boundaries.

402
00:19:45,030 --> 00:19:47,640
And at this stage of the Compose phase,

403
00:19:47,640 --> 00:19:49,980
the agent is not only building

404
00:19:49,980 --> 00:19:52,020
its system prompt using RISEN,

405
00:19:52,020 --> 00:19:55,590
it's also reconstructing its
understanding of the task

406
00:19:55,590 --> 00:19:57,933
by loading state from AgentCore memory.

407
00:19:58,770 --> 00:20:01,200
And since every Llamda vocation

408
00:20:01,200 --> 00:20:03,840
starts in that clean
environment, like I said,

409
00:20:03,840 --> 00:20:06,330
the agent depends on this memory

410
00:20:06,330 --> 00:20:09,360
to be able to restore the
context of the workflow.

411
00:20:09,360 --> 00:20:11,610
And it includes previous decisions,

412
00:20:11,610 --> 00:20:15,720
intermediate results,
correlation identifiers,

413
00:20:15,720 --> 00:20:17,730
and any other types of events

414
00:20:17,730 --> 00:20:22,350
that are generated during
earlier steps in the workflow.

415
00:20:22,350 --> 00:20:26,130
So, AgentCore memory, it is
structured and it's queryable.

416
00:20:26,130 --> 00:20:29,310
So, the agents loads
that specific name spaces

417
00:20:29,310 --> 00:20:33,390
instead of pulling out
big blobs of opaque text.

418
00:20:33,390 --> 00:20:34,980
So, this allows the agents

419
00:20:34,980 --> 00:20:39,240
to then build its prompt
in a deterministic way.

420
00:20:39,240 --> 00:20:41,940
So, the memory is also
optimized for reentry,

421
00:20:41,940 --> 00:20:46,650
which means that the agent
can safely then resume work

422
00:20:46,650 --> 00:20:50,160
even if the previous
invocation perhaps timed out

423
00:20:50,160 --> 00:20:52,383
or had some sort of retry as well.

424
00:20:55,514 --> 00:20:58,500
And agent discovery is in this system

425
00:20:58,500 --> 00:21:01,020
it is driven entirely by A2A

426
00:21:01,020 --> 00:21:03,690
and it's using something
called agent cards.

427
00:21:03,690 --> 00:21:07,110
So, tiny JSON text, you
don't need to read it really,

428
00:21:07,110 --> 00:21:11,520
but this is a document that is
the authoritative description

429
00:21:11,520 --> 00:21:13,860
of what an agent can do.

430
00:21:13,860 --> 00:21:16,680
It is machine-readable capability surface.

431
00:21:16,680 --> 00:21:20,340
So, instead of us hard
coding these RPC calls

432
00:21:20,340 --> 00:21:23,310
or maintaining some sort
of registry for our agent,

433
00:21:23,310 --> 00:21:27,090
instead every agent will
publish this capability card

434
00:21:27,090 --> 00:21:28,380
at a well-known path,

435
00:21:28,380 --> 00:21:31,740
and then when another agent
needs to delegate work,

436
00:21:31,740 --> 00:21:35,880
it fetches these cards,
interprets the capabilities,

437
00:21:35,880 --> 00:21:37,800
and decides how to interact

438
00:21:37,800 --> 00:21:41,520
based on the contract the card exposes.

439
00:21:41,520 --> 00:21:44,010
So, it defines the name of the agents,

440
00:21:44,010 --> 00:21:47,040
its purpose, the actions it supports,

441
00:21:47,040 --> 00:21:51,333
and the schemas for input
and outputs of each action.

442
00:21:52,320 --> 00:21:55,290
We have a more visualized
way of showing it as well,

443
00:21:55,290 --> 00:21:56,700
like a proper card.

444
00:21:56,700 --> 00:21:59,130
This is something Allen hacked together.

445
00:21:59,130 --> 00:22:00,450
I think you have it available

446
00:22:00,450 --> 00:22:03,660
so people can see it at the
end as well in the resources.

447
00:22:03,660 --> 00:22:07,200
But it's kind of a friendlier way

448
00:22:07,200 --> 00:22:09,030
of representing these agents

449
00:22:09,030 --> 00:22:10,800
and these cards in the same information.

450
00:22:10,800 --> 00:22:14,430
Turning that JSON into a
capability graph basically,

451
00:22:14,430 --> 00:22:17,520
that shows the actions
that the agents supports

452
00:22:17,520 --> 00:22:21,033
and how those actions fit
into the larger workflow.

453
00:22:23,340 --> 00:22:26,970
- Okay, so you've assembled
all of this context,

454
00:22:26,970 --> 00:22:28,530
you've built the system prompts,

455
00:22:28,530 --> 00:22:33,060
you have fetched additional
data to build the user prompt,

456
00:22:33,060 --> 00:22:36,210
you have loaded agent cards into memory,

457
00:22:36,210 --> 00:22:38,100
you've done everything
that you need to do.

458
00:22:38,100 --> 00:22:42,753
Now, it's time to feed
that all into an LLM,

459
00:22:43,920 --> 00:22:46,860
but it's not that simple
unfortunately never is,

460
00:22:46,860 --> 00:22:50,910
because models vary wildly

461
00:22:50,910 --> 00:22:53,340
in their output and their behaviors.

462
00:22:53,340 --> 00:22:57,120
I asked two different
LLMs the same question.

463
00:22:57,120 --> 00:22:58,863
All, you know, related
of course to Swift Ship

464
00:22:58,863 --> 00:23:02,853
when we were doing our
interviews for LLMs,

465
00:23:03,690 --> 00:23:05,400
and just gave it a prompt,

466
00:23:05,400 --> 00:23:07,020
what would you do in this situation?

467
00:23:07,020 --> 00:23:10,950
And I asked a LLM that's known

468
00:23:10,950 --> 00:23:14,880
to be very clear, very
blunt, Cohere, command R,

469
00:23:14,880 --> 00:23:17,283
and it gave me a blunt answer.

470
00:23:18,330 --> 00:23:21,180
And then I asked a model, it's
a little bit more capable,

471
00:23:21,180 --> 00:23:22,260
does some more reasoning.

472
00:23:22,260 --> 00:23:27,090
It's not quite as blunt, and
it gave me a longer answer,

473
00:23:27,090 --> 00:23:29,070
and probably a better answer

474
00:23:29,070 --> 00:23:32,343
for the situation that I am using it for.

475
00:23:34,290 --> 00:23:38,580
So, the model differences here,
they're not just stylistic.

476
00:23:38,580 --> 00:23:40,110
Really, they have to fit the scenario

477
00:23:40,110 --> 00:23:41,360
that you're building for,

478
00:23:42,210 --> 00:23:46,260
and that will ultimately end up shaping

479
00:23:46,260 --> 00:23:47,970
how the loop behaves,

480
00:23:47,970 --> 00:23:49,860
because it's going to be responsible

481
00:23:49,860 --> 00:23:52,683
for planning out a multi-step workflow.

482
00:23:53,580 --> 00:23:55,230
And speaking of that,

483
00:23:55,230 --> 00:23:56,940
this is about time where we branch into

484
00:23:56,940 --> 00:23:59,350
something a little bit deeper with A2A.

485
00:23:59,350 --> 00:24:04,290
Where we introduce two
different types of agents

486
00:24:04,290 --> 00:24:07,170
used primarily with A2A and
multi-agent collaboration.

487
00:24:07,170 --> 00:24:11,310
We have supervisors and we have workers,

488
00:24:11,310 --> 00:24:12,810
very much like an engineering team,

489
00:24:12,810 --> 00:24:15,942
exactly like a tech lead or a manager,

490
00:24:15,942 --> 00:24:20,580
and individual engineers that
are actually doing the work.

491
00:24:20,580 --> 00:24:24,540
So, the supervisors and the
workers, they run the same loop,

492
00:24:24,540 --> 00:24:27,870
but they have very different needs.

493
00:24:27,870 --> 00:24:30,570
And when it comes down to
which model you're selecting,

494
00:24:30,570 --> 00:24:33,630
very different model
capabilities that they require.

495
00:24:33,630 --> 00:24:37,110
Supervisors are kind of that orchestrator.

496
00:24:37,110 --> 00:24:39,330
They need to know everything.

497
00:24:39,330 --> 00:24:43,410
They need to be responsible
for global reasoning.

498
00:24:43,410 --> 00:24:45,690
So, a multiple planning out multiple steps

499
00:24:45,690 --> 00:24:47,340
in a long workflow.

500
00:24:47,340 --> 00:24:51,060
They need to be capable
of dependency resolution.

501
00:24:51,060 --> 00:24:53,790
So, what do I need in
order to satisfy this,

502
00:24:53,790 --> 00:24:56,220
or given the agent cards
that I've been presented,

503
00:24:56,220 --> 00:24:59,220
who do I need to call to
do this step or that step?

504
00:24:59,220 --> 00:25:01,620
And also, they need the ability

505
00:25:01,620 --> 00:25:04,440
to be able to judge an
output from a worker.

506
00:25:04,440 --> 00:25:05,310
Is this good enough?

507
00:25:05,310 --> 00:25:07,620
Does this satisfy the reason

508
00:25:07,620 --> 00:25:09,900
why I called you in the first place?

509
00:25:09,900 --> 00:25:14,900
Workers on the other hand are,
to put it simply, the grunts.

510
00:25:15,480 --> 00:25:17,700
They need to run fast,
they need to run cheap,

511
00:25:17,700 --> 00:25:20,310
they need to run deterministically,

512
00:25:20,310 --> 00:25:23,340
and they need to be really schema perfect,

513
00:25:23,340 --> 00:25:25,260
meaning, if I tell you, you need to

514
00:25:25,260 --> 00:25:28,290
have these parameters
to operate this tool,

515
00:25:28,290 --> 00:25:31,500
you need to use those
parameters to operate that tool.

516
00:25:31,500 --> 00:25:33,600
So, when we're thinking about

517
00:25:33,600 --> 00:25:37,083
this phase in the Agent Loop querying,

518
00:25:37,980 --> 00:25:39,330
really there's model selection,

519
00:25:39,330 --> 00:25:40,800
but there's also agent selection.

520
00:25:40,800 --> 00:25:43,710
So, you have multi-layer reasoning

521
00:25:43,710 --> 00:25:46,890
for what you're looking
for with the query.

522
00:25:46,890 --> 00:25:49,260
So, that's why you have for supervisors

523
00:25:49,260 --> 00:25:53,370
more reasoning capable
models, like Nova Pro,

524
00:25:53,370 --> 00:25:56,820
or there is a Nova Premier
in one of our rehearsals.

525
00:25:56,820 --> 00:25:58,320
I said that and Gunnar laughed at me,

526
00:25:58,320 --> 00:26:00,390
'cause he didn't think that was real,

527
00:26:00,390 --> 00:26:02,400
or you know, Sonnet, or opus 45,

528
00:26:02,400 --> 00:26:05,520
ones that are really
capable of strong reasoning

529
00:26:05,520 --> 00:26:09,570
versus ones that are workers
that do very specific things.

530
00:26:09,570 --> 00:26:11,550
So, you could do like Nova Canvas,

531
00:26:11,550 --> 00:26:14,910
if you're drawing an image,
or one of the Sonnet,

532
00:26:14,910 --> 00:26:17,850
or the Haiku, smaller,
lighter models that you need.

533
00:26:17,850 --> 00:26:19,850
Something just real quick and real fast.

534
00:26:21,210 --> 00:26:22,043
Okay.

535
00:26:23,130 --> 00:26:24,830
- I don't like you calling me out.

536
00:26:25,890 --> 00:26:30,890
So, all right, we've composed
and we've now queried the LLM

537
00:26:31,800 --> 00:26:33,390
and now it's time for phase three

538
00:26:33,390 --> 00:26:36,150
where we actually, do
something in the end.

539
00:26:36,150 --> 00:26:39,240
And like in our previous demo,

540
00:26:39,240 --> 00:26:41,880
now we can do some sort of simple action

541
00:26:41,880 --> 00:26:43,860
where we turn the model output

542
00:26:43,860 --> 00:26:45,780
into real effects in the system.

543
00:26:45,780 --> 00:26:50,040
And the first step, of
course, is schema validation.

544
00:26:50,040 --> 00:26:53,250
We need to make sure that
the expected output shape

545
00:26:53,250 --> 00:26:55,770
from that RISEN prompt and everything

546
00:26:55,770 --> 00:27:00,540
that doesn't conform to that
is gonna be rejected basically.

547
00:27:00,540 --> 00:27:04,350
This protects the system
from malformed model output

548
00:27:04,350 --> 00:27:09,350
and any type of partial structures
or drift across retries.

549
00:27:10,080 --> 00:27:11,820
Once the output is validated,

550
00:27:11,820 --> 00:27:14,880
the agent is then gonna
perform the action described.

551
00:27:14,880 --> 00:27:18,120
And for instance, that could
be updating a database,

552
00:27:18,120 --> 00:27:20,010
it could be calling an API,

553
00:27:20,010 --> 00:27:22,530
it could be writing to DynamoDB,

554
00:27:22,530 --> 00:27:25,350
updating state in AgentCore memory

555
00:27:25,350 --> 00:27:27,870
publishing event or anything else.

556
00:27:27,870 --> 00:27:31,260
Every action should use item potency keys

557
00:27:31,260 --> 00:27:33,990
that we derive from the task ID.

558
00:27:33,990 --> 00:27:35,820
So retries shouldn't be able

559
00:27:35,820 --> 00:27:38,700
to create any duplicate side effects.

560
00:27:38,700 --> 00:27:39,990
Most of the time,

561
00:27:39,990 --> 00:27:43,050
Execute produce some sort
of concrete system update.

562
00:27:43,050 --> 00:27:46,020
But in some cases, the
action the model request

563
00:27:46,020 --> 00:27:48,060
isn't a local update.

564
00:27:48,060 --> 00:27:49,830
Instead it's gonna be a handoff.

565
00:27:49,830 --> 00:27:52,770
When the model indicates
that another agent

566
00:27:52,770 --> 00:27:55,920
should take responsibility
for the next step,

567
00:27:55,920 --> 00:27:59,250
Execute isn't gonna
perform the work itself.

568
00:27:59,250 --> 00:28:04,230
Instead, we're gonna look
at A2A agent invocation.

569
00:28:04,230 --> 00:28:06,600
So, Execute has now determined

570
00:28:06,600 --> 00:28:10,470
that the next action
isn't any local update,

571
00:28:10,470 --> 00:28:12,570
it's gonna be a handoff to another one.

572
00:28:12,570 --> 00:28:16,890
So, we've composed a prompt,
we've queried the LLM,

573
00:28:16,890 --> 00:28:18,780
we're trying to execute something,

574
00:28:18,780 --> 00:28:21,510
and this agent can't do
that thing themselves.

575
00:28:21,510 --> 00:28:23,010
So, what happens then instead

576
00:28:23,010 --> 00:28:26,430
is that we construct an A2A payload

577
00:28:26,430 --> 00:28:29,040
that encodes the capability of version,

578
00:28:29,040 --> 00:28:33,180
the required typed input,
and the task identifier.

579
00:28:33,180 --> 00:28:37,080
And this is gonna conform
to that A2A protocol.

580
00:28:37,080 --> 00:28:39,270
So, the specification of the protocol

581
00:28:39,270 --> 00:28:42,240
tells what this message
is gonna look like.

582
00:28:42,240 --> 00:28:44,220
The receiving agent is then gonna know

583
00:28:44,220 --> 00:28:47,190
exactly what to do when it receives it.

584
00:28:47,190 --> 00:28:50,250
So, we then publish this message

585
00:28:50,250 --> 00:28:53,280
and that's gonna launch
an entirely new Agent Loop

586
00:28:53,280 --> 00:28:57,120
where we start off with
composing, we're querying,

587
00:28:57,120 --> 00:28:59,490
we're performing some sort of action,

588
00:28:59,490 --> 00:29:00,780
and that could be a local one,

589
00:29:00,780 --> 00:29:03,900
or it could once again spin off

590
00:29:03,900 --> 00:29:05,853
to a new Agent Loop to do something.

591
00:29:06,840 --> 00:29:09,150
Then it decides if it should continue.

592
00:29:09,150 --> 00:29:10,590
And if that one is done,

593
00:29:10,590 --> 00:29:14,610
we're closing that loop,
reporting that it's done,

594
00:29:14,610 --> 00:29:19,110
and can do the same decision
on that initial loop as well.

595
00:29:19,110 --> 00:29:21,120
So, this is how we get that

596
00:29:21,120 --> 00:29:25,050
distributed, scalable and
deterministic behavior

597
00:29:25,050 --> 00:29:27,660
without having any central orchestrator.

598
00:29:27,660 --> 00:29:31,683
The agents define if they need
to launch a new Agent Loop.

599
00:29:34,080 --> 00:29:35,670
- All right, phase four.

600
00:29:35,670 --> 00:29:38,722
Let's close the loop on closing the loop.

601
00:29:38,722 --> 00:29:40,350
(Allen chuckling)

602
00:29:40,350 --> 00:29:43,350
We're gonna again talk about
supervisors and workers here,

603
00:29:43,350 --> 00:29:45,540
'cause this is actually,
a really important piece.

604
00:29:45,540 --> 00:29:50,430
And before I go into details
on continuing the loop,

605
00:29:50,430 --> 00:29:53,580
I wanna talk about where we are in code,

606
00:29:53,580 --> 00:29:55,227
not gonna show code, but we're
just gonna talk about it.

607
00:29:55,227 --> 00:29:57,690
So, if I've written an agent,

608
00:29:57,690 --> 00:29:59,820
phase one is composing the prompts.

609
00:29:59,820 --> 00:30:01,560
This is actually, code that you write

610
00:30:01,560 --> 00:30:04,110
in your applications that's loading data,

611
00:30:04,110 --> 00:30:05,260
it's assembling string.

612
00:30:06,180 --> 00:30:08,160
We've curated the LLM,

613
00:30:08,160 --> 00:30:11,670
that could be the Bedrock
converse API invoke agent,

614
00:30:11,670 --> 00:30:13,260
whatever it is.

615
00:30:13,260 --> 00:30:15,033
We've done Execute action.

616
00:30:15,990 --> 00:30:17,220
As far as the code goes,

617
00:30:17,220 --> 00:30:19,203
we're still in that converse call.

618
00:30:20,100 --> 00:30:23,430
And now we're on phase four,
which is continuing the loop.

619
00:30:23,430 --> 00:30:24,510
We're still in that call.

620
00:30:24,510 --> 00:30:26,670
So, we haven't received a response yet.

621
00:30:26,670 --> 00:30:30,270
This is still in the
capabilities of that converse

622
00:30:30,270 --> 00:30:31,893
or invoking the actual agent.

623
00:30:32,970 --> 00:30:34,110
And what it's doing here,

624
00:30:34,110 --> 00:30:37,590
it's done work and it's asking itself,

625
00:30:37,590 --> 00:30:38,850
do I have enough information

626
00:30:38,850 --> 00:30:41,280
to finish the task that I'm working on?

627
00:30:41,280 --> 00:30:45,000
And based on whether or not
it's a supervisor or a worker,

628
00:30:45,000 --> 00:30:46,850
it's gonna evaluate different things.

629
00:30:47,730 --> 00:30:52,680
The supervisor, of course,
has its global perspective.

630
00:30:52,680 --> 00:30:55,950
What was the original
hierarching task at the top?

631
00:30:55,950 --> 00:30:57,300
What was the command that came in?

632
00:30:57,300 --> 00:30:58,637
What's the event that I'm responding to

633
00:30:58,637 --> 00:31:01,323
that I need to satisfy?

634
00:31:02,160 --> 00:31:04,950
It looks at the results
from the other agents.

635
00:31:04,950 --> 00:31:07,830
Basically, the output from
the tool calls it made

636
00:31:07,830 --> 00:31:10,890
when it invoked the sub-agent Loops.

637
00:31:10,890 --> 00:31:13,980
And then it's also considering
the unmet capabilities

638
00:31:13,980 --> 00:31:17,730
that track back to that
global parent task.

639
00:31:17,730 --> 00:31:18,930
It's doing things like validating

640
00:31:18,930 --> 00:31:20,310
the schemas returned by the workers.

641
00:31:20,310 --> 00:31:21,990
Is this actually, what I asked for?

642
00:31:21,990 --> 00:31:23,790
Does it have everything that I need?

643
00:31:24,630 --> 00:31:28,470
And what it's doing here
is it's figuring out,

644
00:31:28,470 --> 00:31:30,975
do I need to call more agents?

645
00:31:30,975 --> 00:31:32,700
Do I need to wait for some to respond?

646
00:31:32,700 --> 00:31:35,250
Maybe it's gone async and I need to wait,

647
00:31:35,250 --> 00:31:37,050
or am I actually done

648
00:31:37,050 --> 00:31:40,440
and I can really continue
on with the code?

649
00:31:40,440 --> 00:31:41,430
So, that loop's gonna continue.

650
00:31:41,430 --> 00:31:43,320
So, if that answer is I need to do

651
00:31:43,320 --> 00:31:45,690
one of the first things,

652
00:31:45,690 --> 00:31:48,600
it will go back and it will
build that system prompt again.

653
00:31:48,600 --> 00:31:50,340
It will execute actions.

654
00:31:50,340 --> 00:31:53,640
It will do everything that it needs to do.

655
00:31:53,640 --> 00:31:56,490
The worker, it's roughly the same thing,

656
00:31:56,490 --> 00:31:59,580
but its scope of what it's
concerned about is tighter.

657
00:31:59,580 --> 00:32:00,960
It's a little bit smaller,

658
00:32:00,960 --> 00:32:02,400
because it's not doing as much work,

659
00:32:02,400 --> 00:32:03,960
it's not doing the planning,

660
00:32:03,960 --> 00:32:06,270
it's figuring out, you know,

661
00:32:06,270 --> 00:32:09,240
did I satisfy the individual
work item that came in

662
00:32:09,240 --> 00:32:12,000
and the A2A terminology, that's a message.

663
00:32:12,000 --> 00:32:14,430
There's a task that goes
across all the agents

664
00:32:14,430 --> 00:32:16,020
and then there's individual messages

665
00:32:16,020 --> 00:32:17,700
that go to the sub-agents.

666
00:32:17,700 --> 00:32:20,040
Did I do what the message
said for me to do?

667
00:32:20,040 --> 00:32:22,050
Yes, cool.

668
00:32:22,050 --> 00:32:25,140
Maybe I need to run some more
tools and do some more work.

669
00:32:25,140 --> 00:32:26,430
Maybe I need to validate the results.

670
00:32:26,430 --> 00:32:29,157
Again, this is before you get
a response back in your code.

671
00:32:29,157 --> 00:32:31,290
And so, it's gonna go
and it's gonna decide,

672
00:32:31,290 --> 00:32:32,970
do I need to refine my results?

673
00:32:32,970 --> 00:32:34,650
Do I need to do it again

674
00:32:34,650 --> 00:32:38,163
for that one very specific requirements?

675
00:32:39,960 --> 00:32:42,810
Okay, I think it's time.

676
00:32:42,810 --> 00:32:43,643
- It is time.

677
00:32:45,450 --> 00:32:46,283
- We're gonna talk,

678
00:32:46,283 --> 00:32:48,060
we're gonna make things
a little bit harder

679
00:32:48,060 --> 00:32:53,060
for the Swift Ship delivery
and set it up first.

680
00:32:54,600 --> 00:32:56,790
Build it up, build up the excitement.

681
00:32:56,790 --> 00:32:58,920
Now, we've seen firsthand a single agent

682
00:32:58,920 --> 00:33:02,370
can satisfy a simple prompt,

683
00:33:02,370 --> 00:33:04,440
Customer wasn't home, I
left them on the door,

684
00:33:04,440 --> 00:33:05,273
I'm gonna reschedule it.

685
00:33:05,273 --> 00:33:06,930
Cool, that's not exciting.

686
00:33:06,930 --> 00:33:09,030
Versus Reinvent, we have exciting things

687
00:33:09,030 --> 00:33:10,500
that we're gonna talk about

688
00:33:10,500 --> 00:33:13,493
and I know I'm not supposed
to spoil what the scenario is.

689
00:33:13,493 --> 00:33:15,690
So, I'm not gonna talk about that.

690
00:33:15,690 --> 00:33:17,220
But what I am gonna talk about

691
00:33:17,220 --> 00:33:20,823
is why we need multiple
agents specifically,

692
00:33:21,810 --> 00:33:25,680
and what you don't want, actually, first,

693
00:33:25,680 --> 00:33:28,773
show of hands, does everybody
know what a monolith is?

694
00:33:31,035 --> 00:33:31,950
There's a lot more of you in here.

695
00:33:31,950 --> 00:33:33,000
I can't see you with the lights.

696
00:33:33,000 --> 00:33:34,980
Okay, everyone knows what a monolith is.

697
00:33:34,980 --> 00:33:37,743
Are they good? No.

698
00:33:40,230 --> 00:33:41,670
Okay, all right.

699
00:33:41,670 --> 00:33:44,010
So, there's a new term on the streets.

700
00:33:44,010 --> 00:33:45,990
They call it a mono agent,

701
00:33:45,990 --> 00:33:47,910
and it's an agent that does everything.

702
00:33:47,910 --> 00:33:49,830
It has access and the capabilities

703
00:33:49,830 --> 00:33:52,050
to access your payment systems,

704
00:33:52,050 --> 00:33:56,310
to access your ordering services.

705
00:33:56,310 --> 00:33:58,830
Has access to everything in the database.

706
00:33:58,830 --> 00:34:00,960
Think that's a good thing?

707
00:34:00,960 --> 00:34:03,270
Nah, it's not, it's not.

708
00:34:03,270 --> 00:34:05,580
What we need to do is
we need to scope agents

709
00:34:05,580 --> 00:34:07,473
down to specific domains.

710
00:34:10,500 --> 00:34:13,620
And in the case of Swift
Ship in our example,

711
00:34:13,620 --> 00:34:15,300
what does that look like?

712
00:34:15,300 --> 00:34:16,740
You know, we say that we need

713
00:34:16,740 --> 00:34:18,300
to scope things down to domains.

714
00:34:18,300 --> 00:34:22,020
Well, we're going to
have a supervisor agent,

715
00:34:22,020 --> 00:34:24,330
that I call triage agent,
figure out what to do.

716
00:34:24,330 --> 00:34:25,890
Here are your workers.

717
00:34:25,890 --> 00:34:30,240
And those workers are designed to be

718
00:34:30,240 --> 00:34:34,200
for a very specific part
of my application, domain.

719
00:34:34,200 --> 00:34:36,030
I have an agent for payments.

720
00:34:36,030 --> 00:34:39,270
One that is tasked only
with handling money.

721
00:34:39,270 --> 00:34:40,650
That's its only job.

722
00:34:40,650 --> 00:34:44,280
It's not responsible for
anything else besides money.

723
00:34:44,280 --> 00:34:45,799
I have another worker

724
00:34:45,799 --> 00:34:49,560
that's responsible for
the warehouse, inventory.

725
00:34:49,560 --> 00:34:51,030
Do I have what I need?

726
00:34:51,030 --> 00:34:54,630
Do I need to order more
things in the warehouse?

727
00:34:54,630 --> 00:34:56,973
Do I need to allocate stuff for an order?

728
00:34:57,960 --> 00:35:01,653
And then I also have
an order agent worker,

729
00:35:02,850 --> 00:35:04,050
and this is the one that's actually,

730
00:35:04,050 --> 00:35:05,640
responsible for moving that data along.

731
00:35:05,640 --> 00:35:10,640
I can update statuses, I can
duplicate orders, if I need.

732
00:35:11,160 --> 00:35:12,240
And so, what we're doing here

733
00:35:12,240 --> 00:35:15,963
is we're exposing capability
surfaces based on domain,

734
00:35:17,070 --> 00:35:19,620
and not one single agent

735
00:35:19,620 --> 00:35:23,430
is allowed to cross
those domain boundaries.

736
00:35:23,430 --> 00:35:25,560
Focus it in, tighten it up,

737
00:35:25,560 --> 00:35:30,243
only have the permissions for
one area of your application.

738
00:35:31,470 --> 00:35:32,640
I said a lot of words,

739
00:35:32,640 --> 00:35:36,120
this probably sounds
familiar to a lot of you.

740
00:35:36,120 --> 00:35:37,380
Is that familiar to you?

741
00:35:37,380 --> 00:35:39,720
- It does sound familiar to me.

742
00:35:39,720 --> 00:35:42,183
And has anyone heard about microservices?

743
00:35:44,640 --> 00:35:49,410
It's kind of familiar to how
these agents are working.

744
00:35:49,410 --> 00:35:52,380
So, even though the agents
they use LMS for reasoning,

745
00:35:52,380 --> 00:35:56,453
they behave much closer to
distributed microservices

746
00:35:56,453 --> 00:35:58,710
than I think most people expect.

747
00:35:58,710 --> 00:36:03,710
The same architectural patterns
that appear, we see here,

748
00:36:03,960 --> 00:36:07,080
but they surface through
A2A interactions instead

749
00:36:07,080 --> 00:36:09,480
and the Agent Loop instead of

750
00:36:09,480 --> 00:36:12,330
having rest calls perhaps
or service meshes.

751
00:36:12,330 --> 00:36:14,640
So, agent discovery works in

752
00:36:14,640 --> 00:36:17,280
a similar way to service discovery.

753
00:36:17,280 --> 00:36:18,660
So, instead of registering

754
00:36:18,660 --> 00:36:21,750
in some sort of mesh or DNS layer,

755
00:36:21,750 --> 00:36:23,820
each agent is gonna publish

756
00:36:23,820 --> 00:36:26,160
that agent card that I showed before,

757
00:36:26,160 --> 00:36:29,460
exposing capabilities,
versions, schemes, and so on.

758
00:36:29,460 --> 00:36:31,890
And then other agents can then

759
00:36:31,890 --> 00:36:34,920
resolve these capabilities during runtime.

760
00:36:34,920 --> 00:36:36,780
So, this gives us late binding

761
00:36:36,780 --> 00:36:38,913
without having hard-coded knowledge.

762
00:36:40,230 --> 00:36:44,670
And health behavior, well,
it also maps quite cleanly

763
00:36:44,670 --> 00:36:46,440
to how distributed system works.

764
00:36:46,440 --> 00:36:48,660
Instead of pulling health checks,

765
00:36:48,660 --> 00:36:51,420
agents will infer health from behavior.

766
00:36:51,420 --> 00:36:55,860
They will, let's say an A2A request fails,

767
00:36:55,860 --> 00:36:58,410
some sort of validation, or a times out,

768
00:36:58,410 --> 00:37:00,930
or it returns some sort
of inconsistent data.

769
00:37:00,930 --> 00:37:03,660
Well, the system will naturally retry

770
00:37:03,660 --> 00:37:07,440
and it chooses perhaps a
different execution path.

771
00:37:07,440 --> 00:37:10,380
So, there is no central
health manager in place.

772
00:37:10,380 --> 00:37:13,560
Instead the system converges
on healthy behavior,

773
00:37:13,560 --> 00:37:16,410
because agents respond
to real interactions

774
00:37:16,410 --> 00:37:18,660
not through external probes.

775
00:37:18,660 --> 00:37:20,130
And task distribution,

776
00:37:20,130 --> 00:37:23,790
while it works in a similar way
to load balancing basically.

777
00:37:23,790 --> 00:37:27,390
We rely on AgentCore memory
and distributed state

778
00:37:27,390 --> 00:37:30,480
to coordinate these task IDs that we have,

779
00:37:30,480 --> 00:37:35,040
but also item potency keys,
progress markers, and so on.

780
00:37:35,040 --> 00:37:37,500
So, a lot of this is
very familiar to things

781
00:37:37,500 --> 00:37:41,733
we've been doing for may
I say decades now even.

782
00:37:44,731 --> 00:37:46,950
But when we move from that single agent

783
00:37:46,950 --> 00:37:49,410
to a multi-agent workflow,

784
00:37:49,410 --> 00:37:51,090
the system only stays predictable,

785
00:37:51,090 --> 00:37:54,180
if every interaction is deterministic.

786
00:37:54,180 --> 00:37:56,160
Allen talked about that before as well.

787
00:37:56,160 --> 00:37:59,460
Choreography can remain elegant at scale,

788
00:37:59,460 --> 00:38:03,300
but only if each of these
agents follow the rules

789
00:38:03,300 --> 00:38:05,880
that remove randomness from the workflow.

790
00:38:05,880 --> 00:38:07,560
So, the idea here is simple.

791
00:38:07,560 --> 00:38:10,080
If the inputs are the same,

792
00:38:10,080 --> 00:38:13,170
well, the outcome should be the same

793
00:38:13,170 --> 00:38:15,630
even when several agents are involved

794
00:38:15,630 --> 00:38:18,120
and running in parallel maybe.

795
00:38:18,120 --> 00:38:21,060
So, we begin with clarity in prompts.

796
00:38:21,060 --> 00:38:24,060
Every agent should use the risk pattern.

797
00:38:24,060 --> 00:38:26,670
The model should start
with a stable contract

798
00:38:26,670 --> 00:38:28,710
for the behavior of the agent.

799
00:38:28,710 --> 00:38:31,680
The role section should
limit the scope of the agent.

800
00:38:31,680 --> 00:38:35,910
The instruction defines
the rules it must follow.

801
00:38:35,910 --> 00:38:39,510
The steps gives it predictable procedures

802
00:38:39,510 --> 00:38:41,460
that are repeatable.

803
00:38:41,460 --> 00:38:44,850
And then expectations
define the output structure,

804
00:38:44,850 --> 00:38:46,740
and narrowing section prevents it

805
00:38:46,740 --> 00:38:50,760
from drifting into responsibilities
that it shouldn't have,

806
00:38:50,760 --> 00:38:52,110
like Allen talked about.

807
00:38:52,110 --> 00:38:55,950
So, this removes
interpretation-type errors

808
00:38:55,950 --> 00:38:59,970
that can then ripple through
any type of distributed system.

809
00:38:59,970 --> 00:39:02,880
And item potency, super important here.

810
00:39:02,880 --> 00:39:05,340
In any type of distributed system,

811
00:39:05,340 --> 00:39:07,110
retries are not an exception.

812
00:39:07,110 --> 00:39:08,550
They happen all the time.

813
00:39:08,550 --> 00:39:12,900
It's regular to have that,
because of network variations,

814
00:39:12,900 --> 00:39:15,510
or perhaps cold starts
with Lambda functions,

815
00:39:15,510 --> 00:39:18,330
or timeouts in different
parts of the system.

816
00:39:18,330 --> 00:39:19,560
So, every agent must be able

817
00:39:19,560 --> 00:39:22,980
to receive the same
instruction multiple times

818
00:39:22,980 --> 00:39:26,730
without us ending up
transferring money multiple time

819
00:39:26,730 --> 00:39:28,440
to Allen's account for instance.

820
00:39:28,440 --> 00:39:30,570
And this is why we use task IDs,

821
00:39:30,570 --> 00:39:32,490
this is why we have memory checks,

822
00:39:32,490 --> 00:39:36,597
consistent verification
before executing any action.

823
00:39:36,597 --> 00:39:41,070
And we also make sure that
the APIs that we create,

824
00:39:41,070 --> 00:39:42,240
that they are authentic.

825
00:39:42,240 --> 00:39:44,910
Each call should represent

826
00:39:44,910 --> 00:39:47,550
a complete and safe unit of work.

827
00:39:47,550 --> 00:39:50,940
There shouldn't be any partial
updates within these systems.

828
00:39:50,940 --> 00:39:54,840
If an agent updates state
or performs an action,

829
00:39:54,840 --> 00:39:59,840
the workflow should be able
to perform it incompletely,

830
00:40:00,540 --> 00:40:03,993
completely, or it should be
able to roll back, if needed.

831
00:40:07,020 --> 00:40:09,600
We've pushed this ahead

832
00:40:09,600 --> 00:40:12,000
quite far in this
presentation, right, Allen?

833
00:40:12,000 --> 00:40:13,100
And I think it's time.

834
00:40:14,370 --> 00:40:17,040
- Yes, we did kick this can
down about as far as we can.

835
00:40:17,040 --> 00:40:18,660
Can't really talk about
production software

836
00:40:18,660 --> 00:40:22,260
without talking about observability
at least a little bit.

837
00:40:22,260 --> 00:40:23,340
And we're gonna talk about this

838
00:40:23,340 --> 00:40:24,750
before we even do the demo,

839
00:40:24,750 --> 00:40:27,060
because A2A really when
you're talking about

840
00:40:27,060 --> 00:40:30,060
multi-agent collaboration,
but specifically, with A2A,

841
00:40:30,060 --> 00:40:31,350
has a couple of really cool things

842
00:40:31,350 --> 00:40:35,370
that I wanna make sure that
we know before we see it.

843
00:40:35,370 --> 00:40:37,440
So, when you think of observability,

844
00:40:37,440 --> 00:40:39,120
typically, think of three things,

845
00:40:39,120 --> 00:40:42,810
metrics, logs, traces, it's the same.

846
00:40:42,810 --> 00:40:45,090
It's not really any different with agents.

847
00:40:45,090 --> 00:40:47,520
There's definitely
plenty of talks this week

848
00:40:47,520 --> 00:40:51,840
going very deep into this subject,

849
00:40:51,840 --> 00:40:54,663
but we'll talk about it
at least at a high level.

850
00:40:55,560 --> 00:41:00,560
Bedrock has a very brand
new observability dashboard.

851
00:41:01,830 --> 00:41:04,020
I think two weeks ago came out with this.

852
00:41:04,020 --> 00:41:05,370
That just works.

853
00:41:05,370 --> 00:41:06,800
If you use Bedrock,

854
00:41:06,800 --> 00:41:11,010
if you use really any of
the APIs inside of Bedrock,

855
00:41:11,010 --> 00:41:13,590
you get to see a CloudWatch dashboard

856
00:41:13,590 --> 00:41:17,040
that rolls up all the important metrics

857
00:41:17,040 --> 00:41:20,520
for operational cost performance.

858
00:41:20,520 --> 00:41:22,830
Things like what's your
total invocation count,

859
00:41:22,830 --> 00:41:25,920
what's your per model token spend,

860
00:41:25,920 --> 00:41:27,420
what's the invocation latency,

861
00:41:28,260 --> 00:41:30,570
what are the input tokens
versus the output tokens?

862
00:41:30,570 --> 00:41:33,450
Things that are going to act more or less

863
00:41:33,450 --> 00:41:34,650
like non-functional requirements,

864
00:41:34,650 --> 00:41:37,890
but definitely requirements
on your wallet.

865
00:41:37,890 --> 00:41:39,960
And Bedrock does actually,

866
00:41:39,960 --> 00:41:41,940
or CloudWatch does a really good job

867
00:41:41,940 --> 00:41:44,520
at servicing these things
front and center for you

868
00:41:44,520 --> 00:41:46,380
without really taking
anything into consideration.

869
00:41:46,380 --> 00:41:49,083
You don't have to build
anything to get this.

870
00:41:50,231 --> 00:41:53,430
What I want you to take away
here, metrics are important,

871
00:41:53,430 --> 00:41:55,230
but you can't really optimize

872
00:41:55,230 --> 00:41:58,560
multi-agent systems without metrics,

873
00:41:58,560 --> 00:42:01,350
because you're gonna be using
a lot of different models.

874
00:42:01,350 --> 00:42:03,120
You're gonna have different
models for workers,

875
00:42:03,120 --> 00:42:05,910
you're going to have different
models for your supervisors,

876
00:42:05,910 --> 00:42:08,550
and they're gonna be taking in
different amounts of tokens,

877
00:42:08,550 --> 00:42:10,800
they're gonna be spitting output tokens

878
00:42:10,800 --> 00:42:11,850
out at different rates.

879
00:42:11,850 --> 00:42:14,220
So, you need to have that insights

880
00:42:14,220 --> 00:42:19,220
so you don't spend all your money on LLMs.

881
00:42:19,800 --> 00:42:21,450
Okay, but here's the cool thing.

882
00:42:21,450 --> 00:42:25,770
Here's A2A that does a really cool job

883
00:42:25,770 --> 00:42:30,123
for observability, and
specifically with traces,

884
00:42:31,170 --> 00:42:35,810
and a task, an overarching task in A2A.

885
00:42:35,810 --> 00:42:36,990
If something comes in,

886
00:42:36,990 --> 00:42:39,783
a supervisor is going
to start up a new task.

887
00:42:39,783 --> 00:42:41,763
It's a multi-step plan.

888
00:42:42,600 --> 00:42:45,660
Goes all the way across the
life of this invocation.

889
00:42:45,660 --> 00:42:48,450
Supervisor lives with that task

890
00:42:48,450 --> 00:42:51,360
and then it's going to
cast out these messages

891
00:42:51,360 --> 00:42:54,990
to its sub-agents to
actually, do the work.

892
00:42:54,990 --> 00:42:58,830
And A2A provides a fantastic opportunity

893
00:42:58,830 --> 00:43:02,670
to hook in and watch in real time

894
00:43:02,670 --> 00:43:05,913
as these orchestrated workflows pan out.

895
00:43:07,093 --> 00:43:09,900
And this is where Momento comes into play.

896
00:43:09,900 --> 00:43:11,160
We have a service called Topics

897
00:43:11,160 --> 00:43:15,750
that's a centralized
third-party event bus.

898
00:43:15,750 --> 00:43:18,390
And you can just hook
straight into these messages

899
00:43:18,390 --> 00:43:20,280
inside the A2A protocol,

900
00:43:20,280 --> 00:43:23,430
and subscribe to 'em in the front end,

901
00:43:23,430 --> 00:43:24,540
which is why we're talking about this now

902
00:43:24,540 --> 00:43:26,100
before we see the demo.

903
00:43:26,100 --> 00:43:28,500
So, at the beginning, at the end,

904
00:43:28,500 --> 00:43:31,230
even at tool calls in the
middle for these agents,

905
00:43:31,230 --> 00:43:34,020
you get opportunity to see what on Earth

906
00:43:34,020 --> 00:43:37,050
is happening in this formerly black box

907
00:43:37,050 --> 00:43:38,493
that is agent execution.

908
00:43:40,470 --> 00:43:42,270
Okay, we talked about observability.

909
00:43:42,270 --> 00:43:47,270
- Yeah, it is finally time
for the real star of the show,

910
00:43:47,310 --> 00:43:50,820
which is our full
multi-agent workflow demo.

911
00:43:50,820 --> 00:43:52,620
This is where it gets exciting.

912
00:43:52,620 --> 00:43:54,183
So, new scenario.

913
00:43:55,590 --> 00:43:58,440
Allen or one of his drivers is out there

914
00:43:58,440 --> 00:44:00,580
trying to deliver a package.

915
00:44:00,580 --> 00:44:04,020
Now, we have a bit of a bigger issue.

916
00:44:04,020 --> 00:44:05,700
Driver arrives at the stop

917
00:44:05,700 --> 00:44:09,390
and discovers that the
package has been damaged.

918
00:44:09,390 --> 00:44:12,630
We can't just schedule a
redelivery in this case.

919
00:44:12,630 --> 00:44:15,750
Needs to trigger a bunch
of different actions

920
00:44:15,750 --> 00:44:19,200
inside the warehouse,
in the order department,

921
00:44:19,200 --> 00:44:21,390
and so on to make all of this happen.

922
00:44:21,390 --> 00:44:26,390
So, now let's see how that same system

923
00:44:27,030 --> 00:44:29,103
is able to handle this type of scenario.

924
00:44:30,240 --> 00:44:31,563
Let's jump over to.

925
00:44:33,750 --> 00:44:36,750
- Okay, so the reason that we use

926
00:44:36,750 --> 00:44:39,690
agents in a scenario like this,

927
00:44:39,690 --> 00:44:43,050
is 'cause of this comment box
right here that says Notes.

928
00:44:43,050 --> 00:44:46,710
We can code for anything that
happens in exception type,

929
00:44:46,710 --> 00:44:48,840
but notes, this is free text,

930
00:44:48,840 --> 00:44:52,350
anything can happen in the notes.

931
00:44:52,350 --> 00:44:55,320
So, we're gonna test it,
we're gonna see what happens.

932
00:44:55,320 --> 00:44:58,170
I have in here, "Package
severely damaged during transit.

933
00:44:58,170 --> 00:45:00,120
Contents appear compromised."

934
00:45:00,120 --> 00:45:01,563
Let's make that worse.

935
00:45:02,407 --> 00:45:07,407
"Contents caught on fire,
then were run over by my car,

936
00:45:09,540 --> 00:45:12,363
and the car behind me.

937
00:45:14,100 --> 00:45:16,113
Then the ashes caught on fire.

938
00:45:18,060 --> 00:45:18,960
This was my fault."

939
00:45:18,960 --> 00:45:21,000
- [Gunnar] Typical delivery event.

940
00:45:21,000 --> 00:45:24,240
- [Allen] Yeah, we see these
a lot at Swift Ship actually,

941
00:45:24,240 --> 00:45:25,860
it's kind of a problem.

942
00:45:25,860 --> 00:45:28,620
And so, I had a photo prepared,

943
00:45:28,620 --> 00:45:30,270
but I did the hackathon yesterday

944
00:45:30,270 --> 00:45:33,660
and now I just have 100
pictures of eggs on my machine.

945
00:45:33,660 --> 00:45:36,210
So, can't find.

946
00:45:36,210 --> 00:45:37,607
- [Gunnar] There is another a
picture of a package on fire.

947
00:45:37,607 --> 00:45:39,570
- [Allen] It's a package that was on fire

948
00:45:39,570 --> 00:45:41,013
that was run over by a car.

949
00:45:42,870 --> 00:45:46,470
Instead I'm not gonna show
a bunch of pictures of eggs.

950
00:45:46,470 --> 00:45:47,870
So, we're gonna submit this.

951
00:45:49,440 --> 00:45:50,520
So, now that we've done this,

952
00:45:50,520 --> 00:45:52,980
triage agent sees this package

953
00:45:52,980 --> 00:45:54,990
that got run over, it caught on fire,

954
00:45:54,990 --> 00:45:57,750
the ashes caught on fire,
they're gonna run over again.

955
00:45:57,750 --> 00:46:00,480
And there's definitely
things that have to be done

956
00:46:00,480 --> 00:46:04,293
more than rescheduling
that package for delivery.

957
00:46:05,490 --> 00:46:06,900
Gotta replace it.

958
00:46:06,900 --> 00:46:08,550
We're a good delivery company.

959
00:46:08,550 --> 00:46:10,437
We'll take care of your packages for you.

960
00:46:10,437 --> 00:46:12,570
And again, this is happening in real time.

961
00:46:12,570 --> 00:46:16,470
So, I'll zoom in, we'll take
a look at this in a minute,

962
00:46:16,470 --> 00:46:19,173
but we're gonna let it
run its course here.

963
00:46:20,130 --> 00:46:24,697
We have multiple agents
that's are in the mix.

964
00:46:28,080 --> 00:46:30,480
Now, I see why you wanted
me to record a demo before

965
00:46:30,480 --> 00:46:31,730
instead of doing it live,

966
00:46:32,640 --> 00:46:34,140
'cause this is not what I expected,

967
00:46:34,140 --> 00:46:37,650
but I feel like that just
drives the point home-

968
00:46:37,650 --> 00:46:38,483
- [Gunnar] Yes.

969
00:46:38,483 --> 00:46:40,110
- [Allen] that agents
are non-deterministic.

970
00:46:40,110 --> 00:46:44,670
So, what we did see, is
it an incomplete workflow

971
00:46:44,670 --> 00:46:48,877
of the triage agent saying,

972
00:46:48,877 --> 00:46:51,960
"Hey, we need to refund that package.

973
00:46:51,960 --> 00:46:53,520
It was destroyed."

974
00:46:53,520 --> 00:46:56,970
We're going to give them their money back,

975
00:46:56,970 --> 00:46:59,940
and they we're gonna
toss the responsibility

976
00:46:59,940 --> 00:47:01,530
over to the warehouse agent.

977
00:47:01,530 --> 00:47:03,610
And we're going to see

978
00:47:04,505 --> 00:47:08,610
is there inventory left in the warehouse

979
00:47:08,610 --> 00:47:11,940
to actually do a full
replacement and send it back out.

980
00:47:11,940 --> 00:47:14,700
My guess what happened is I
didn't reset our demo data

981
00:47:14,700 --> 00:47:17,910
and there was no inventory.

982
00:47:17,910 --> 00:47:19,083
So, what it's supposed to do,

983
00:47:19,083 --> 00:47:21,750
this actually might have been
a good demo we can restart.

984
00:47:21,750 --> 00:47:23,370
No, it's fine.

985
00:47:23,370 --> 00:47:25,860
What it's supposed to do
is allocate the inventory.

986
00:47:25,860 --> 00:47:27,180
Say, "Yes I have it."

987
00:47:27,180 --> 00:47:28,590
And the triage agent comes in

988
00:47:28,590 --> 00:47:31,380
and says, "Oh great, okay we're
gonna duplicate the order,

989
00:47:31,380 --> 00:47:33,420
we're gonna allocate that inventory again,

990
00:47:33,420 --> 00:47:35,520
and then we're gonna finalize that payment

991
00:47:35,520 --> 00:47:36,957
to payment processing."

992
00:47:37,920 --> 00:47:39,330
But that didn't happen,

993
00:47:39,330 --> 00:47:41,370
'cause I forgot to reset the demo data.

994
00:47:41,370 --> 00:47:45,120
But we did see multiple agents actually,

995
00:47:45,120 --> 00:47:47,430
collaborating based on that Wild West.

996
00:47:47,430 --> 00:47:50,550
That is the notes on the delivery system.

997
00:47:50,550 --> 00:47:51,690
- Let's quickly jump over

998
00:47:51,690 --> 00:47:54,330
just to show the architecture of it.

999
00:47:54,330 --> 00:47:55,800
We've been talking a lot about this.

1000
00:47:55,800 --> 00:47:58,769
I think it's cool to
actually, see what this means.

1001
00:47:58,769 --> 00:48:01,650
And it's nothing strange really.

1002
00:48:01,650 --> 00:48:03,973
It's similar to what Allen
showed earlier as well.

1003
00:48:03,973 --> 00:48:05,400
A very simple one.

1004
00:48:05,400 --> 00:48:07,650
It's Amazon API gateway

1005
00:48:07,650 --> 00:48:09,930
and he submits something in that form

1006
00:48:09,930 --> 00:48:13,380
that cause a Lambda function
that just stores something.

1007
00:48:13,380 --> 00:48:16,800
The delivery status message in DynamoDB.

1008
00:48:16,800 --> 00:48:19,290
It's connected, has a DynamoDB stream

1009
00:48:19,290 --> 00:48:21,570
that sends an event to EventBridge.

1010
00:48:21,570 --> 00:48:24,270
We have a rule there
that picks up that event,

1011
00:48:24,270 --> 00:48:26,610
and it's gonna trigger our triage agent.

1012
00:48:26,610 --> 00:48:31,170
That's the first agent that
then decides it runs the loop,

1013
00:48:31,170 --> 00:48:33,120
it decides what it's gonna do next.

1014
00:48:33,120 --> 00:48:36,300
Invoke the payment agent,
invoke the warehouse agent,

1015
00:48:36,300 --> 00:48:38,040
the order agent, and so on.

1016
00:48:38,040 --> 00:48:42,750
And all of these are using
Bedrock for querying the model,

1017
00:48:42,750 --> 00:48:44,906
but also for AgentCore memory.

1018
00:48:44,906 --> 00:48:47,400
So, it's a super simple

1019
00:48:47,400 --> 00:48:49,920
and very common serverless architecture.

1020
00:48:49,920 --> 00:48:52,170
There's nothing strange about it.

1021
00:48:52,170 --> 00:48:55,380
So, let's then move over
and see some code as well.

1022
00:48:55,380 --> 00:48:59,130
- Yes, we can talk about
it and see demos all day,

1023
00:48:59,130 --> 00:49:00,870
but for all the engineers in here,

1024
00:49:00,870 --> 00:49:01,710
if you're anything like me,

1025
00:49:01,710 --> 00:49:03,780
you're not really gonna
get it until you see it.

1026
00:49:03,780 --> 00:49:05,280
And we're gonna take a look.

1027
00:49:05,280 --> 00:49:09,480
So, A2A, we talked about the agent card,

1028
00:49:09,480 --> 00:49:13,890
which is how supervisors
know what you can do.

1029
00:49:13,890 --> 00:49:17,910
This is basically, their ID card,

1030
00:49:17,910 --> 00:49:19,590
has the name, has the description.

1031
00:49:19,590 --> 00:49:21,270
What can I do as far as capabilities go?

1032
00:49:21,270 --> 00:49:23,250
Do I stream, do I push?

1033
00:49:23,250 --> 00:49:25,170
But this is the important part here.

1034
00:49:25,170 --> 00:49:27,540
This is the part that
can change on the fly.

1035
00:49:27,540 --> 00:49:30,236
And in the future when supervisor agents

1036
00:49:30,236 --> 00:49:32,850
need to load information
about the order agent,

1037
00:49:32,850 --> 00:49:36,557
they see, oh, this guy, this order agent,

1038
00:49:36,557 --> 00:49:38,910
is responsible for changing order statuses

1039
00:49:38,910 --> 00:49:41,010
or duplicating orders.

1040
00:49:41,010 --> 00:49:43,410
And we have in here no schemas,

1041
00:49:43,410 --> 00:49:45,360
this is only natural language.

1042
00:49:45,360 --> 00:49:46,620
It's the beauty of A2A.

1043
00:49:46,620 --> 00:49:50,820
We're not really doing anything
that's tightly coupling us.

1044
00:49:50,820 --> 00:49:52,860
This is just natural language.

1045
00:49:52,860 --> 00:49:53,940
What can you do?

1046
00:49:53,940 --> 00:49:56,730
And what can I ask you
has in here examples

1047
00:49:56,730 --> 00:50:00,390
change the order from this
to that of that order,

1048
00:50:00,390 --> 00:50:01,860
and it knows what to do.

1049
00:50:01,860 --> 00:50:03,160
So, that's the agent card.

1050
00:50:05,040 --> 00:50:08,130
We have down here inside
of our agent handler,

1051
00:50:08,130 --> 00:50:09,330
our system prompt.

1052
00:50:09,330 --> 00:50:12,180
We also talked about
building that system prompt

1053
00:50:12,180 --> 00:50:13,500
with the RISEN framework.

1054
00:50:13,500 --> 00:50:14,580
What's your role?

1055
00:50:14,580 --> 00:50:16,080
What do I want you to do?

1056
00:50:16,080 --> 00:50:18,870
What are the steps to do
what I want you to do?

1057
00:50:18,870 --> 00:50:20,073
What do I expect?

1058
00:50:20,910 --> 00:50:24,000
And each one of these things
in here is used specifically,

1059
00:50:24,000 --> 00:50:26,700
to build up that determinism layer.

1060
00:50:26,700 --> 00:50:30,060
What do you do in this
situation or that situation?

1061
00:50:30,060 --> 00:50:34,120
And it will go through
and use this to figure out

1062
00:50:35,100 --> 00:50:36,843
what to do when the time comes.

1063
00:50:38,130 --> 00:50:39,080
We also have tools.

1064
00:50:39,990 --> 00:50:44,310
Cool, that's what takes
us from chat bot to agent.

1065
00:50:44,310 --> 00:50:45,143
What's a tool?

1066
00:50:46,500 --> 00:50:48,300
A tool has a schema.

1067
00:50:48,300 --> 00:50:50,070
This specific one is
changing the order status

1068
00:50:50,070 --> 00:50:51,420
and it accepts order ID

1069
00:50:51,420 --> 00:50:53,850
and the new status and then any notes.

1070
00:50:53,850 --> 00:50:55,170
And you know what it's doing?

1071
00:50:55,170 --> 00:50:58,200
Exactly what an API controller would do,

1072
00:50:58,200 --> 00:51:00,690
if you were trying to
change an order status.

1073
00:51:00,690 --> 00:51:02,880
It's calling DynamoDB.

1074
00:51:02,880 --> 00:51:04,770
That's it, there's no LLMs in here.

1075
00:51:04,770 --> 00:51:07,410
This is just running deterministic code

1076
00:51:07,410 --> 00:51:12,273
to set a status of an
order to a specific value.

1077
00:51:13,500 --> 00:51:17,733
An agent knows based on the
real, the description up here,

1078
00:51:19,350 --> 00:51:21,900
exactly what to do and what to expect

1079
00:51:21,900 --> 00:51:23,100
when it calls that tool.

1080
00:51:24,660 --> 00:51:29,040
So, we looked at a worker
agent, and we looked at a tool.

1081
00:51:29,040 --> 00:51:30,573
Let's look at the supervisor.

1082
00:51:34,110 --> 00:51:36,990
Surprise, surprise, it's the same,

1083
00:51:36,990 --> 00:51:39,090
because really we're doing the same thing.

1084
00:51:39,090 --> 00:51:42,720
It's not different just
because we have the supervisor

1085
00:51:42,720 --> 00:51:45,600
versus the worker.

1086
00:51:45,600 --> 00:51:47,300
We might give it a little
bit more information.

1087
00:51:47,300 --> 00:51:48,930
In this case we do.

1088
00:51:48,930 --> 00:51:52,860
We tell it what to do
in different scenarios.

1089
00:51:52,860 --> 00:51:55,950
So, if there's just a basic non-delivery,

1090
00:51:55,950 --> 00:51:57,660
just reschedule it.

1091
00:51:57,660 --> 00:51:59,433
What do you do in a total loss?

1092
00:52:00,420 --> 00:52:03,027
And that's where we were supposed
to see the payment agent,

1093
00:52:03,027 --> 00:52:05,550
and the order agent,
and the warehouse agent,

1094
00:52:05,550 --> 00:52:08,670
but the data wasn't there
in the database to do it.

1095
00:52:08,670 --> 00:52:10,080
But this is where you again

1096
00:52:10,080 --> 00:52:11,670
are defining deterministic behaviors.

1097
00:52:11,670 --> 00:52:14,700
It's really important to build these out

1098
00:52:14,700 --> 00:52:16,440
so you don't have to
build them out in code.

1099
00:52:16,440 --> 00:52:20,070
It's telling the agent what
to do in given scenarios.

1100
00:52:20,070 --> 00:52:23,760
And we've tailored these steps

1101
00:52:23,760 --> 00:52:26,430
based on the types of events

1102
00:52:26,430 --> 00:52:29,613
that it's gonna be responding
to in our system, not chat.

1103
00:52:33,990 --> 00:52:35,730
And that's about it is the same.

1104
00:52:35,730 --> 00:52:39,810
Here, this is probably the last thing

1105
00:52:39,810 --> 00:52:42,660
that we'll look at in the code
here is registering agents.

1106
00:52:42,660 --> 00:52:44,340
So, we just have the URL

1107
00:52:44,340 --> 00:52:47,940
of the agent card of all of these agents.

1108
00:52:47,940 --> 00:52:49,260
And what this is gonna do

1109
00:52:49,260 --> 00:52:51,030
is in the code that I wrote specifically,

1110
00:52:51,030 --> 00:52:52,860
this is a layer on top of A2A.

1111
00:52:52,860 --> 00:52:53,850
It's gonna go and it's gonna

1112
00:52:53,850 --> 00:52:55,890
fetch the agent card from that URL

1113
00:52:55,890 --> 00:52:58,500
and inject that into the system prompt.

1114
00:52:58,500 --> 00:53:01,560
So, the triage agent knows
what the capabilities are

1115
00:53:01,560 --> 00:53:02,910
of these three agents.

1116
00:53:02,910 --> 00:53:04,083
All it is a URL.

1117
00:53:05,850 --> 00:53:10,309
The last thing, actual
last thing, for real,

1118
00:53:10,309 --> 00:53:14,250
is the how does a supervisor agent

1119
00:53:14,250 --> 00:53:16,023
actually, talk to a worker?

1120
00:53:16,023 --> 00:53:19,380
This is a big aha moment for me

1121
00:53:19,380 --> 00:53:21,580
when I was building
this several months ago.

1122
00:53:22,620 --> 00:53:23,793
It's just a tool call.

1123
00:53:24,720 --> 00:53:27,757
Supervisors have a tool that says,

1124
00:53:27,757 --> 00:53:30,660
"Invoke agent, give me the agent URL

1125
00:53:30,660 --> 00:53:32,100
and give me the command,

1126
00:53:32,100 --> 00:53:34,650
give me the task ID so I can track it."

1127
00:53:34,650 --> 00:53:37,500
And all it's doing is
it's using the A2A client,

1128
00:53:37,500 --> 00:53:41,130
published by Google, and
sending a message to it.

1129
00:53:41,130 --> 00:53:43,560
And then we kick off our
Agent Loops on the sub-agents

1130
00:53:43,560 --> 00:53:47,193
and it returns that data back
in our Execute action step.

1131
00:53:48,270 --> 00:53:50,340
And that's really all there is to it.

1132
00:53:50,340 --> 00:53:52,740
That's multi-agent collaboration and code.

1133
00:53:52,740 --> 00:53:53,573
- Easy, right?

1134
00:53:54,510 --> 00:53:57,483
All right, so let's
bring this all together.

1135
00:53:59,250 --> 00:54:03,000
Few key takeaways that I think
you should try to remember.

1136
00:54:03,000 --> 00:54:06,843
That agents are what drives this system.

1137
00:54:06,843 --> 00:54:08,490
It's not workflows.

1138
00:54:08,490 --> 00:54:11,130
You don't design these
flows, you design behaviors.

1139
00:54:11,130 --> 00:54:14,130
So, each agent is responsible
for a specific job

1140
00:54:14,130 --> 00:54:18,330
and the system emerges from
how they collaborate together.

1141
00:54:18,330 --> 00:54:20,640
And A2A is really the key

1142
00:54:20,640 --> 00:54:23,310
to what enables this real collaboration.

1143
00:54:23,310 --> 00:54:26,190
Instead of having some sort
of central orchestrator,

1144
00:54:26,190 --> 00:54:28,410
the agents discover each other at runtime

1145
00:54:28,410 --> 00:54:32,520
and they delegate work and they
launch new autonomous loops.

1146
00:54:32,520 --> 00:54:35,910
And MCP is what makes context reliable.

1147
00:54:35,910 --> 00:54:38,520
Being able to use tools and schemas

1148
00:54:38,520 --> 00:54:42,783
that returns this
deterministic typed data.

1149
00:54:43,620 --> 00:54:47,820
And AgentCore together with
service infrastructure,

1150
00:54:47,820 --> 00:54:52,470
it allows us for massive scale
when we build these systems

1151
00:54:52,470 --> 00:54:57,470
and with very, very little
undifferentiating heavy lifting.

1152
00:54:58,230 --> 00:54:59,490
I love that phrase.

1153
00:54:59,490 --> 00:55:03,840
So, deterministic and determinism

1154
00:55:03,840 --> 00:55:07,230
is what then difference from chaos

1155
00:55:07,230 --> 00:55:09,783
into a system that is reliable.

1156
00:55:10,620 --> 00:55:14,220
And make sure that just like
with any distributed system,

1157
00:55:14,220 --> 00:55:17,640
you design the system for item potency

1158
00:55:17,640 --> 00:55:20,073
and with compensating actions.

1159
00:55:21,660 --> 00:55:23,520
I'm sure you all want to try out

1160
00:55:23,520 --> 00:55:27,900
and start competing with Swift Ship.

1161
00:55:27,900 --> 00:55:29,100
And from the looks of it,

1162
00:55:29,100 --> 00:55:31,420
we can easily compete with Swift Ship

1163
00:55:33,150 --> 00:55:35,100
since packages aren't delivered.

1164
00:55:35,100 --> 00:55:38,760
But scan the QR code
takes you to a GitHub repo

1165
00:55:38,760 --> 00:55:40,440
where all the code is available,

1166
00:55:40,440 --> 00:55:44,841
and feel free to submit
pull requests, I guess,

1167
00:55:44,841 --> 00:55:48,300
to create a new agent that
can order from the supplier.

1168
00:55:48,300 --> 00:55:49,980
So, then the demo would work,

1169
00:55:49,980 --> 00:55:50,813
yeah.
- Yes.

1170
00:55:50,813 --> 00:55:53,310
- So, you can deploy this
yourself and experiment with it.

1171
00:55:53,310 --> 00:55:56,160
And you can use it with or
without Momento as well.

1172
00:55:56,160 --> 00:55:57,750
- Yes. Yep.

1173
00:55:57,750 --> 00:55:59,880
- So with that, we want to thank you all

1174
00:55:59,880 --> 00:56:01,830
for joining us in this session

1175
00:56:01,830 --> 00:56:05,100
about building autonomous
multi-agent systems.

1176
00:56:05,100 --> 00:56:07,710
I hope you found it enjoyable.

1177
00:56:07,710 --> 00:56:10,950
Remember, to fill out this
session survey as always

1178
00:56:10,950 --> 00:56:13,860
and we'll stick around on the outside,

1179
00:56:13,860 --> 00:56:15,750
if anyone has any questions.

1180
00:56:15,750 --> 00:56:17,048
Thank you all very much.
- Thank you.

1181
00:56:17,048 --> 00:56:17,881
(audience applauding)

