1
00:00:00,840 --> 00:00:02,970
- [Parnab Basak] Welcome
to day one of "re:Invent".

2
00:00:02,970 --> 00:00:04,740
If you have not already been

3
00:00:04,740 --> 00:00:06,750
to a day-one events before,

4
00:00:06,750 --> 00:00:09,090
this is the day you realize

5
00:00:09,090 --> 00:00:13,860
that there is more in Vegas
than just its casinos.

6
00:00:13,860 --> 00:00:15,990
This is also a day you realize

7
00:00:15,990 --> 00:00:19,560
that your biggest friend
are your sneakers,

8
00:00:19,560 --> 00:00:23,610
while finding rooms in Vegas.

9
00:00:23,610 --> 00:00:26,100
And this is also a day you realize

10
00:00:26,100 --> 00:00:28,230
that jet lag is real, okay?

11
00:00:28,230 --> 00:00:30,420
So, just raise of hands,

12
00:00:30,420 --> 00:00:33,180
how many of you are jet-lagged already?

13
00:00:33,180 --> 00:00:35,190
Because you are already,
okay, I see a lot of it.

14
00:00:35,190 --> 00:00:37,020
That's nothing you should be shy about.

15
00:00:37,020 --> 00:00:40,830
I'm jet-lagged too and I am
in central time zone, okay?

16
00:00:40,830 --> 00:00:42,540
So, I can understand from people

17
00:00:42,540 --> 00:00:44,220
that are traveling all across the world.

18
00:00:44,220 --> 00:00:45,990
So, this session is not

19
00:00:45,990 --> 00:00:50,580
about jet lag or your shoes or your Vegas.

20
00:00:50,580 --> 00:00:51,960
- [Tom Romano] Or the need for chapstick.

21
00:00:51,960 --> 00:00:54,180
- [Parnab Basak] Yeah, or a
need for chapsticks either,

22
00:00:54,180 --> 00:00:55,013
okay?

23
00:00:55,013 --> 00:00:55,846
So, this session,

24
00:00:55,846 --> 00:00:58,200
is about building fault-tolerant
messaging systems,

25
00:00:58,200 --> 00:01:00,000
using AWS services.

26
00:01:00,000 --> 00:01:01,920
A quick show of hands,

27
00:01:01,920 --> 00:01:03,990
how many of you are using,

28
00:01:03,990 --> 00:01:07,260
or planning to use an
AWS messaging service

29
00:01:07,260 --> 00:01:09,990
in your workloads in any shape or format?

30
00:01:09,990 --> 00:01:13,620
I see, okay, Plad, you
are in the right room.

31
00:01:13,620 --> 00:01:17,490
Trust me, this is the talk
on AWS messaging services.

32
00:01:17,490 --> 00:01:20,640
So, on that same note, let
me ask you another question.

33
00:01:20,640 --> 00:01:22,593
How many of you have been,

34
00:01:23,460 --> 00:01:28,460
had to handle outages in
your messaging systems

35
00:01:28,860 --> 00:01:31,560
and you have to be called
in the middle of the night,

36
00:01:31,560 --> 00:01:36,010
middle of your weekend or
middle of your non-working hours

37
00:01:36,930 --> 00:01:38,490
to handle a complex issue?

38
00:01:38,490 --> 00:01:39,780
I see one there.

39
00:01:39,780 --> 00:01:40,613
- [Tom Romano] Yeah.

40
00:01:40,613 --> 00:01:42,240
- [Parnab Basak] I see a
few more rising up, okay.

41
00:01:42,240 --> 00:01:43,500
- [Tom Romano] Over
there, lots over there.

42
00:01:43,500 --> 00:01:44,910
- [Parnab Basak] Yeah, hopefully,

43
00:01:44,910 --> 00:01:48,360
this session and the
learnings from it help you

44
00:01:48,360 --> 00:01:51,210
to not be in that situation anymore.

45
00:01:51,210 --> 00:01:53,790
So, with that, let me introduce myself.

46
00:01:53,790 --> 00:01:55,290
I'm Parnab Basak.

47
00:01:55,290 --> 00:01:57,000
I'm a senior solutions architect,

48
00:01:57,000 --> 00:02:01,140
helping out our public-sector
customers adopt AWS

49
00:02:01,140 --> 00:02:02,790
for their needs.

50
00:02:02,790 --> 00:02:05,190
And I'm a developer at heart.

51
00:02:05,190 --> 00:02:06,570
With me is Tom.

52
00:02:06,570 --> 00:02:07,470
Tom?

53
00:02:07,470 --> 00:02:08,610
- [Tom Romano] Hi, my name's Tom Romano.

54
00:02:08,610 --> 00:02:10,170
I'm also a senior solutions architect.

55
00:02:10,170 --> 00:02:12,810
I've been working with Parnab
for about five years now.

56
00:02:12,810 --> 00:02:14,370
And we are both members

57
00:02:14,370 --> 00:02:17,340
of a serverless technical field community.

58
00:02:17,340 --> 00:02:18,173
- [Parnab Basak] Hmm.

59
00:02:18,173 --> 00:02:19,006
- [Tom Romano] And I'm also a member

60
00:02:19,006 --> 00:02:20,850
of the analytics
technical field community.

61
00:02:20,850 --> 00:02:21,723
- [Parnab Basak] Wow!

62
00:02:21,723 --> 00:02:22,556
- [Tom Romano] In data engineering,

63
00:02:22,556 --> 00:02:23,730
we use these patterns a lot as well.

64
00:02:23,730 --> 00:02:24,563
- [Parnab Basak] Awesome!

65
00:02:24,563 --> 00:02:25,830
So, what you mean to say Tom,

66
00:02:25,830 --> 00:02:28,530
is you can imply this if
you're running a data pipeline,

67
00:02:28,530 --> 00:02:30,900
or a messaging service, you
can imply all these patterns-

68
00:02:30,900 --> 00:02:31,733
- [Tom Romano] Yes.

69
00:02:31,733 --> 00:02:32,566
- [Parnab Basak] There?
- [Tom Romano] Yep.

70
00:02:32,566 --> 00:02:34,650
- [Parnab Basak] Fantastic,
so, you get two for one, okay,

71
00:02:34,650 --> 00:02:37,680
like all the Black Friday
sales, buy one, get one free.

72
00:02:37,680 --> 00:02:39,150
So, there's a BOGO offer.

73
00:02:39,150 --> 00:02:42,690
Okay, let's go with what we
have in plan today, okay?

74
00:02:42,690 --> 00:02:46,050
So, we're gonna talk
about very briefly, okay,

75
00:02:46,050 --> 00:02:49,530
about what the AWS messaging services are,

76
00:02:49,530 --> 00:02:51,090
the patterns of it.

77
00:02:51,090 --> 00:02:54,180
Again, this is a code
talk, a 300 level at that.

78
00:02:54,180 --> 00:02:56,580
So, most of the time,

79
00:02:56,580 --> 00:02:59,070
the hopeless Tom is going to live-code

80
00:02:59,070 --> 00:03:01,350
in front of this big of an audience, okay,

81
00:03:01,350 --> 00:03:03,900
without using generative AI, okay?

82
00:03:03,900 --> 00:03:07,046
And please say a prayer for him

83
00:03:07,046 --> 00:03:08,910
(Tom laughs)

84
00:03:08,910 --> 00:03:11,550
and let the demo gods be still be with him

85
00:03:11,550 --> 00:03:12,930
during the latter part of the session.

86
00:03:12,930 --> 00:03:13,952
- [Tom Romano] And I never had-

87
00:03:13,952 --> 00:03:15,090
- [Parnab Basak] I get
to get the easiest part,

88
00:03:15,090 --> 00:03:17,280
talk about the slide deck, right?

89
00:03:17,280 --> 00:03:19,110
So, we're gonna talk about some

90
00:03:19,110 --> 00:03:21,420
of the resiliency considerations
you should worry about,

91
00:03:21,420 --> 00:03:24,180
while designing messaging
patterns and systems.

92
00:03:24,180 --> 00:03:25,290
We'll talk about patterns,

93
00:03:25,290 --> 00:03:27,090
which is the highlight of your talk.

94
00:03:27,090 --> 00:03:30,510
And then, code and of course, Q&A.

95
00:03:30,510 --> 00:03:32,400
Again, keep those Q&A coming.

96
00:03:32,400 --> 00:03:34,260
We would need some time to deploy.

97
00:03:34,260 --> 00:03:35,850
So, that's the time that we can ask

98
00:03:35,850 --> 00:03:37,500
for any feedback questions,

99
00:03:37,500 --> 00:03:38,940
talking about your architecture,

100
00:03:38,940 --> 00:03:41,610
something that you have
learned would be useful.

101
00:03:41,610 --> 00:03:46,050
So, with that, let's level-set, okay?

102
00:03:46,050 --> 00:03:47,970
You might be already using these services.

103
00:03:47,970 --> 00:03:50,550
You might already have
used these services before.

104
00:03:50,550 --> 00:03:53,460
So, if you look at AWS messaging services,

105
00:03:53,460 --> 00:03:56,310
this deck probably encompasses everything.

106
00:03:56,310 --> 00:03:58,800
So, we have AWS-native services

107
00:03:58,800 --> 00:04:00,420
and there is a bunch of those.

108
00:04:00,420 --> 00:04:03,450
We have event stores,
we have event routers.

109
00:04:03,450 --> 00:04:07,020
You can look at simple
queuing service or Amazon SQS

110
00:04:07,020 --> 00:04:11,190
for FIFO queues, standard
queues, et cetera,

111
00:04:11,190 --> 00:04:13,890
or if you're willing to go
use a topic-based system

112
00:04:13,890 --> 00:04:16,530
for pub/sub messaging patterns,

113
00:04:16,530 --> 00:04:19,860
you can use Amazon Simple
Notification Service.

114
00:04:19,860 --> 00:04:21,540
If you're looking at a streaming service,

115
00:04:21,540 --> 00:04:23,670
Amazon Kinesis with all its variations,

116
00:04:23,670 --> 00:04:27,930
does give you that streaming interface.

117
00:04:27,930 --> 00:04:31,560
And if you're looking for
an enterprise service bus

118
00:04:31,560 --> 00:04:33,630
for point-to-point integrations,

119
00:04:33,630 --> 00:04:35,853
you can look at Amazon
EventBridge as well.

120
00:04:37,350 --> 00:04:40,380
Then, comes another set of services

121
00:04:40,380 --> 00:04:43,980
that we call that AWS
managed open-source services.

122
00:04:43,980 --> 00:04:46,590
What we have done is taken
their open-source code

123
00:04:46,590 --> 00:04:48,060
and given you

124
00:04:48,060 --> 00:04:53,060
as customers, as users, as
developers, an access to those

125
00:04:53,130 --> 00:04:54,360
through a managed interface,

126
00:04:54,360 --> 00:04:58,020
so that you don't have worry
about setting that yourself

127
00:04:58,020 --> 00:04:59,760
on an EC2 instance.

128
00:04:59,760 --> 00:05:02,010
So, this comes in two forms.

129
00:05:02,010 --> 00:05:05,970
You have Amazon MQ or
Message Queing services.

130
00:05:05,970 --> 00:05:09,547
It has two support for both
the RabbitMQ and ActiveMQ.

131
00:05:10,410 --> 00:05:13,140
So, if you are building
those hybrid architectures,

132
00:05:13,140 --> 00:05:17,490
bringing in your existing
RabbitMQ or ActiveMQ over to AWS,

133
00:05:17,490 --> 00:05:19,770
you can look at Amazon MQ as an option.

134
00:05:19,770 --> 00:05:20,670
And then,

135
00:05:20,670 --> 00:05:24,540
you have Amazon Managed Streaming
Service for Apache Kafka.

136
00:05:24,540 --> 00:05:26,670
Again, that's a mouthful of a name.

137
00:05:26,670 --> 00:05:28,830
So, we call it Amazon MSK,

138
00:05:28,830 --> 00:05:32,100
also gives you that managed platform

139
00:05:32,100 --> 00:05:35,000
if you are planning to use
Kafka within your architecture.

140
00:05:36,030 --> 00:05:38,940
So, just a quick raise of hands,

141
00:05:38,940 --> 00:05:42,723
how many of you are using
an AWS-native service?

142
00:05:44,790 --> 00:05:47,340
I see a few there, few here as well.

143
00:05:47,340 --> 00:05:50,073
How many of you use managed
open-source service?

144
00:05:51,390 --> 00:05:52,920
Okay.

145
00:05:52,920 --> 00:05:55,350
Just by count of hands, roughly,

146
00:05:55,350 --> 00:05:58,800
it seems there's a more inclination

147
00:05:58,800 --> 00:06:01,980
to use an AWS-native service,
which is perfectly okay.

148
00:06:01,980 --> 00:06:05,220
Now, both of these patterns
are good to implement depending

149
00:06:05,220 --> 00:06:06,720
on what you are doing.

150
00:06:06,720 --> 00:06:08,040
But during our talk,

151
00:06:08,040 --> 00:06:11,940
we're gonna use more of
this AWS-native approach.

152
00:06:11,940 --> 00:06:14,940
But we will also sprinkling in some ideas

153
00:06:14,940 --> 00:06:17,403
about managed open-source services too.

154
00:06:18,720 --> 00:06:20,610
So, everybody probably knows

155
00:06:20,610 --> 00:06:22,800
what an architecture or components

156
00:06:22,800 --> 00:06:24,720
of a messaging service looks like.

157
00:06:24,720 --> 00:06:29,130
You have a producer, you have
a consumer, as simple as that.

158
00:06:29,130 --> 00:06:30,870
In between, you have a messaging service

159
00:06:30,870 --> 00:06:33,180
that can be a router, that can be a topic,

160
00:06:33,180 --> 00:06:35,970
that can be an event bus, doesn't matter.

161
00:06:35,970 --> 00:06:38,760
If you look at this architecture,

162
00:06:38,760 --> 00:06:41,370
when you talk about resiliency
of this architecture,

163
00:06:41,370 --> 00:06:45,753
'cause nobody wants to get
pinged at 12:00 AM at night,

164
00:06:46,920 --> 00:06:48,720
you have multiple points of failure.

165
00:06:49,770 --> 00:06:51,930
Your producer can go bad,

166
00:06:51,930 --> 00:06:54,750
it might not publish messages,
which is a good thing.

167
00:06:54,750 --> 00:06:57,210
You don't have to worry
about the message coming in,

168
00:06:57,210 --> 00:06:59,400
you don't have to worry
about any resiliency.

169
00:06:59,400 --> 00:07:01,650
Then, they might still be live,

170
00:07:01,650 --> 00:07:03,480
but they might start pushing in messages,

171
00:07:03,480 --> 00:07:06,750
which may not be in the correct
format, which is a problem.

172
00:07:06,750 --> 00:07:08,650
Either they have not been communicated

173
00:07:09,510 --> 00:07:10,680
that there is a change

174
00:07:10,680 --> 00:07:13,050
in your messaging pattern or structure,

175
00:07:13,050 --> 00:07:18,050
or your most senior developer
has made the most simplest

176
00:07:18,660 --> 00:07:20,790
of errors by making a field mandatory

177
00:07:20,790 --> 00:07:22,040
in the messaging service.

178
00:07:23,640 --> 00:07:26,280
Your messaging services can also go down,

179
00:07:26,280 --> 00:07:30,150
because of either persistent
errors or transient errors.

180
00:07:30,150 --> 00:07:33,390
And then, lastly, your
consumer can also be downed,

181
00:07:33,390 --> 00:07:35,730
because of some networking problems,

182
00:07:35,730 --> 00:07:38,400
or somebody forgot to deploy a service,

183
00:07:38,400 --> 00:07:41,823
although, the CI/CD pipeline
said it is deployed.

184
00:07:42,720 --> 00:07:43,590
So, during the talk,

185
00:07:43,590 --> 00:07:45,480
we're gonna talk about all these patterns

186
00:07:45,480 --> 00:07:47,490
and all these areas of failure

187
00:07:47,490 --> 00:07:49,823
and address them through
architectural patterns.

188
00:07:49,823 --> 00:07:51,510
(Parnab Basak clears throat)

189
00:07:51,510 --> 00:07:53,100
To talk about it,

190
00:07:53,100 --> 00:07:54,840
the first pattern that
we're gonna talk about,

191
00:07:54,840 --> 00:07:59,840
is the dead-letter queue
pattern or the DLQ pattern.

192
00:07:59,850 --> 00:08:02,940
And what this does is you have a producer,

193
00:08:02,940 --> 00:08:05,910
in this case, I'm using Amazon SQS queue

194
00:08:05,910 --> 00:08:10,140
as an intermediary messaging service.

195
00:08:10,140 --> 00:08:12,870
Then, you have the consumer too.

196
00:08:12,870 --> 00:08:15,900
So, if your messages are erroneous,

197
00:08:15,900 --> 00:08:18,930
you can configure an
Amazon dead-letter queue,

198
00:08:18,930 --> 00:08:21,840
which is nothing but a
simple standard queue

199
00:08:21,840 --> 00:08:23,690
to push those messages to this queue.

200
00:08:24,810 --> 00:08:27,450
You can implement this very easily

201
00:08:27,450 --> 00:08:30,060
in your existing
application if you have one.

202
00:08:30,060 --> 00:08:34,230
All you have to do is
define a dead-letter queue.

203
00:08:34,230 --> 00:08:38,970
And even certain services
like AWS Lambda has the option

204
00:08:38,970 --> 00:08:40,950
to configure dead-letter queues

205
00:08:40,950 --> 00:08:43,200
in case you're able to pick up Lambda,

206
00:08:43,200 --> 00:08:44,700
it's not able to process certain messages,

207
00:08:44,700 --> 00:08:46,890
because of certain issues,

208
00:08:46,890 --> 00:08:49,890
runtimes, code issues, bugs, et cetera,

209
00:08:49,890 --> 00:08:51,450
and they can be pushed over

210
00:08:51,450 --> 00:08:54,573
to a standard SQS queue
configured as a dead-letter queue.

211
00:08:55,860 --> 00:08:57,810
Now, I always have a problem

212
00:08:57,810 --> 00:09:01,050
with calling this as dead-letter queues.

213
00:09:01,050 --> 00:09:03,660
These messages are not dead, okay?

214
00:09:03,660 --> 00:09:06,210
So, somebody perhaps took this reference

215
00:09:06,210 --> 00:09:09,030
from the old postal service systems

216
00:09:09,030 --> 00:09:12,090
where messages were being,
all letters were being sent

217
00:09:12,090 --> 00:09:14,880
and there was no recipients
or an incorrect address.

218
00:09:14,880 --> 00:09:16,890
So, they didn't know what to do.

219
00:09:16,890 --> 00:09:19,290
In this case, they are not dead.

220
00:09:19,290 --> 00:09:21,540
I rather would call them
error message queue,

221
00:09:22,650 --> 00:09:25,980
so that you as a developer,
you as an administrator,

222
00:09:25,980 --> 00:09:29,160
you as a business owner can
intercept those messages,

223
00:09:29,160 --> 00:09:31,950
either manually or through systematic way

224
00:09:31,950 --> 00:09:34,860
and then republish them
back to the SQS queue

225
00:09:34,860 --> 00:09:36,390
by correcting them.

226
00:09:36,390 --> 00:09:37,920
Typical examples,

227
00:09:37,920 --> 00:09:41,910
let's say, somebody has made
a field a mandatory one, okay?

228
00:09:41,910 --> 00:09:43,890
Let's call it, the ID field is mandatory,

229
00:09:43,890 --> 00:09:45,480
which was not previously.

230
00:09:45,480 --> 00:09:48,780
So, anything that does not
have an ID can be sent back

231
00:09:48,780 --> 00:09:50,010
to the producer

232
00:09:50,010 --> 00:09:52,800
and then you can put in
an ID, an arbitrary one

233
00:09:52,800 --> 00:09:54,150
to go process it.

234
00:09:54,150 --> 00:09:57,300
And then, that redrive happens, sorry,

235
00:09:57,300 --> 00:10:01,590
redrive happens back to
the original SQS queue

236
00:10:01,590 --> 00:10:03,570
for it to be processed.

237
00:10:03,570 --> 00:10:04,440
Again, Tom is going

238
00:10:04,440 --> 00:10:06,150
to walk through the
dead-letter queue pattern

239
00:10:06,150 --> 00:10:07,230
through his code.

240
00:10:07,230 --> 00:10:09,450
We'll look at what
configurations you need,

241
00:10:09,450 --> 00:10:10,680
what permissions you need

242
00:10:10,680 --> 00:10:13,320
in order to configure dead-letter queues.

243
00:10:13,320 --> 00:10:14,850
Has anybody implemented
a dead-letter queue

244
00:10:14,850 --> 00:10:16,980
in their application before?

245
00:10:16,980 --> 00:10:18,120
Wow!

246
00:10:18,120 --> 00:10:21,005
Well, I shouldn't have talked
about this at such a length.

247
00:10:21,005 --> 00:10:21,840
(Parnab laughs)
(Tom laughs)

248
00:10:21,840 --> 00:10:24,420
Okay, anyways, for folks
that didn't use it,

249
00:10:24,420 --> 00:10:25,920
probably, you get some value add

250
00:10:25,920 --> 00:10:29,940
as we talk about this during
your code implementations.

251
00:10:29,940 --> 00:10:33,420
The next pattern is what we call

252
00:10:33,420 --> 00:10:36,393
as a retry with a backoff pattern, okay?

253
00:10:37,800 --> 00:10:42,800
So, this is particularly
important for transient errors

254
00:10:42,810 --> 00:10:47,810
that your message bus or your
consumer might end up having.

255
00:10:48,030 --> 00:10:49,350
A typical example,

256
00:10:49,350 --> 00:10:53,130
let's say, you have
temporary networking failure,

257
00:10:53,130 --> 00:10:56,280
or you have a overload of messages

258
00:10:56,280 --> 00:10:58,530
where you end up having service quotas.

259
00:10:58,530 --> 00:11:03,530
Because of an erratic producer
producing too many messages.

260
00:11:03,540 --> 00:11:05,370
So, in this case, what you end up doing,

261
00:11:05,370 --> 00:11:09,690
is you kind of configure a retry

262
00:11:09,690 --> 00:11:12,090
with a exponential backoff pattern

263
00:11:12,090 --> 00:11:16,710
in which case, we are
publishing subsequent messages

264
00:11:16,710 --> 00:11:18,660
with a time difference between them,

265
00:11:18,660 --> 00:11:22,260
so that each subsequent message
is delayed to the matter.

266
00:11:22,260 --> 00:11:23,700
And why you do it?

267
00:11:23,700 --> 00:11:25,740
The primary reason for doing this,

268
00:11:25,740 --> 00:11:28,770
is you are giving sufficient time

269
00:11:28,770 --> 00:11:31,740
for your message service or your consumer

270
00:11:31,740 --> 00:11:33,930
to keep up to its healthy state

271
00:11:33,930 --> 00:11:36,420
before it can go receive messages.

272
00:11:36,420 --> 00:11:38,190
So, that's the high-level idea.

273
00:11:38,190 --> 00:11:41,403
Anybody using this retry
with backoff pattern?

274
00:11:42,360 --> 00:11:44,880
Okay, I see a few folks all across.

275
00:11:44,880 --> 00:11:46,230
Thank you for using it.

276
00:11:46,230 --> 00:11:49,950
Certain services already
have this in-built.

277
00:11:49,950 --> 00:11:53,310
For example, SNS, when it's
trying to publish messages

278
00:11:53,310 --> 00:11:55,080
to multiple other endpoints,

279
00:11:55,080 --> 00:12:00,003
has retry with backoff by
default configured within it.

280
00:12:01,350 --> 00:12:06,350
Lambda also has this when it's
receiving messages from S3,

281
00:12:06,390 --> 00:12:10,320
or publishing to other
services like SQS queues too.

282
00:12:10,320 --> 00:12:13,380
You can of course override
them as you want to.

283
00:12:13,380 --> 00:12:17,580
But that's a very nitty option

284
00:12:17,580 --> 00:12:20,313
to have it already
configured as a part of it.

285
00:12:21,780 --> 00:12:24,780
Now, let's talk about
some persistent errors.

286
00:12:24,780 --> 00:12:26,700
We talked about transient errors.

287
00:12:26,700 --> 00:12:30,273
Those appear and go away
without you doing much, okay?

288
00:12:31,110 --> 00:12:33,070
What about some use cases

289
00:12:34,646 --> 00:12:35,700
where you see the producer,

290
00:12:35,700 --> 00:12:40,050
or the consumer having
more transient errors?

291
00:12:40,050 --> 00:12:41,040
So, for example,

292
00:12:41,040 --> 00:12:44,760
if your consumer ends up
having pertinent errors,

293
00:12:44,760 --> 00:12:48,060
which is not recoverable
and which are not temporary,

294
00:12:48,060 --> 00:12:49,890
then you can employ something,

295
00:12:49,890 --> 00:12:52,350
called a circuit breaker pattern.

296
00:12:52,350 --> 00:12:53,910
What the circuit breaker pattern does,

297
00:12:53,910 --> 00:12:58,770
is if everything is fine,
the circuit is closed.

298
00:12:58,770 --> 00:13:01,500
Taking an example from
an electrical systems.

299
00:13:01,500 --> 00:13:05,220
But if there are issues like
a persistent error issue

300
00:13:05,220 --> 00:13:06,600
with the consumer,

301
00:13:06,600 --> 00:13:08,850
we call the circuit being open.

302
00:13:08,850 --> 00:13:10,740
And what you can do in this scenario,

303
00:13:10,740 --> 00:13:14,280
is you can use services
like AWS Step Functions,

304
00:13:14,280 --> 00:13:17,940
or even Lambda functions, which
Tom would be going to show

305
00:13:17,940 --> 00:13:19,920
during these code demonstrations

306
00:13:19,920 --> 00:13:24,120
to push them to an SQS queue
again as a temporary store

307
00:13:24,120 --> 00:13:27,300
and then have an Amazon
EventBridge Scheduler,

308
00:13:27,300 --> 00:13:29,970
which is going to pull from
the messages from that queue

309
00:13:29,970 --> 00:13:34,590
and then redrive them back
again, back to the consumer.

310
00:13:34,590 --> 00:13:39,030
So, in this case, the circuit is open.

311
00:13:39,030 --> 00:13:41,520
It's not handling in its irregular state.

312
00:13:41,520 --> 00:13:44,940
But you have an option
to do health checks,

313
00:13:44,940 --> 00:13:47,160
understand when the
consumer is back up and open

314
00:13:47,160 --> 00:13:49,110
and then redrive those messages back

315
00:13:49,110 --> 00:13:50,913
to the original consumer.

316
00:13:52,230 --> 00:13:54,453
Anybody implemented
circuit breaker pattern?

317
00:13:56,100 --> 00:13:56,970
Okay, I see one.

318
00:13:56,970 --> 00:13:58,500
So, if you look at the patterns,

319
00:13:58,500 --> 00:14:00,810
DLQ had the most adoption,

320
00:14:00,810 --> 00:14:03,363
going by backoff with
retry being the next best,

321
00:14:04,320 --> 00:14:07,320
circuit breaker pattern be
the third one there, okay?

322
00:14:07,320 --> 00:14:09,270
Let's see how far we go down the route

323
00:14:09,270 --> 00:14:11,703
and see how far that
option rate is currently.

324
00:14:13,230 --> 00:14:15,960
But you may not have one consumer,

325
00:14:15,960 --> 00:14:19,020
one consumer's circuit breaker
pattern works perfectly okay.

326
00:14:19,020 --> 00:14:23,310
What about you trying to push
this to multiple consumers?

327
00:14:23,310 --> 00:14:25,470
So, in this case, I have two consumers

328
00:14:25,470 --> 00:14:28,080
and you want to have a
distributed transaction.

329
00:14:28,080 --> 00:14:29,940
And what I mean by a
distributed transaction,

330
00:14:29,940 --> 00:14:32,580
is your messaging service
wants to push this

331
00:14:32,580 --> 00:14:34,050
to two consumers

332
00:14:34,050 --> 00:14:37,350
and both the states of the
consumers should be committed

333
00:14:37,350 --> 00:14:38,640
in order for the transaction

334
00:14:38,640 --> 00:14:41,550
to entirely be successful, right?

335
00:14:41,550 --> 00:14:43,350
So, you have two local transactions,

336
00:14:43,350 --> 00:14:45,180
one going to consumer one.

337
00:14:45,180 --> 00:14:48,480
But in this case, let's say the
consumer two is unavailable,

338
00:14:48,480 --> 00:14:51,630
because a junior developer
is doing a deployment

339
00:14:51,630 --> 00:14:53,850
outside the green zone, okay?

340
00:14:53,850 --> 00:14:56,250
So, what happens in this case?

341
00:14:56,250 --> 00:14:59,640
You have a system where it's inconsistent,

342
00:14:59,640 --> 00:15:03,240
meaning your consumer one and
consumer two are out of state

343
00:15:03,240 --> 00:15:05,580
and that's not an acceptable solution.

344
00:15:05,580 --> 00:15:09,840
So, what you end up doing
is you kind of do this

345
00:15:09,840 --> 00:15:13,890
with Step Functions
that you push or pull in

346
00:15:13,890 --> 00:15:15,750
in between the messaging service

347
00:15:15,750 --> 00:15:20,670
and Step Functions knows how
to compensate the transaction.

348
00:15:20,670 --> 00:15:24,210
What I mean by it is if
Step Functions understands

349
00:15:24,210 --> 00:15:26,880
that your consumer two is down,

350
00:15:26,880 --> 00:15:30,240
what it can do is it can do
a compensatory transaction,

351
00:15:30,240 --> 00:15:34,140
reverting the comment made to consumer one

352
00:15:34,140 --> 00:15:37,110
and then store it again
either in a database system,

353
00:15:37,110 --> 00:15:41,250
or on a totally different queue
or maybe even a DLQ, okay,

354
00:15:41,250 --> 00:15:45,003
or maybe it might do a backoff
with retry pattern as well.

355
00:15:46,110 --> 00:15:49,560
So, those are options and solutions

356
00:15:49,560 --> 00:15:51,060
that you can go implement

357
00:15:51,060 --> 00:15:54,243
and what we call this as a saga pattern,

358
00:15:55,410 --> 00:15:57,750
specifically, a saga
orchestration pattern,

359
00:15:57,750 --> 00:16:00,963
because we are orchestrating
between two consumers here.

360
00:16:01,830 --> 00:16:04,590
Just for fun fact, this came,

361
00:16:04,590 --> 00:16:06,120
the naming of this pattern came

362
00:16:06,120 --> 00:16:11,120
from the fact that a saga
means a big, long, epic story

363
00:16:11,670 --> 00:16:13,800
where each of the characters are episodes

364
00:16:13,800 --> 00:16:15,993
within that story, unlike consumers here.

365
00:16:16,830 --> 00:16:19,020
Again, in software engineering,

366
00:16:19,020 --> 00:16:24,020
we seem to always get examples
from non-software things,

367
00:16:25,440 --> 00:16:30,440
like electrical systems, post
offices and now epic stories.

368
00:16:31,350 --> 00:16:33,840
Anyway, moving on to the last pattern

369
00:16:33,840 --> 00:16:37,740
before we get into the code
is the redundancy pattern.

370
00:16:37,740 --> 00:16:40,140
In the rare, uneventful case

371
00:16:40,140 --> 00:16:43,650
that your infrastructure,
your messaging service may,

372
00:16:43,650 --> 00:16:48,650
or may not be available because
of not a fault on your side.

373
00:16:48,660 --> 00:16:51,720
You can definitely look
at the redundancy pattern.

374
00:16:51,720 --> 00:16:55,410
Certain service like Amazon
MQ message broker allows you

375
00:16:55,410 --> 00:16:59,070
to define an active standby pair

376
00:16:59,070 --> 00:17:03,780
wherein you define two Amazon MQ brokers

377
00:17:03,780 --> 00:17:05,820
in two separate availability zones

378
00:17:05,820 --> 00:17:09,603
and then have an EFS file
system connected to it.

379
00:17:10,470 --> 00:17:12,600
What happens during this scenario,

380
00:17:12,600 --> 00:17:15,180
is if the primary goes down,

381
00:17:15,180 --> 00:17:17,820
the standby can be quickly activated.

382
00:17:17,820 --> 00:17:20,190
If you need more higher resiliencies

383
00:17:20,190 --> 00:17:24,090
where you cannot afford the time it takes

384
00:17:24,090 --> 00:17:26,190
to pull up the standby,

385
00:17:26,190 --> 00:17:27,240
you can definitely look

386
00:17:27,240 --> 00:17:29,400
at a multi-region,

387
00:17:29,400 --> 00:17:34,400
multi-availability-zone ActiveMQ setup,

388
00:17:34,470 --> 00:17:38,250
in which case you are looking
at a network of brokers

389
00:17:38,250 --> 00:17:41,670
that are distributed and
deployed across all these regions

390
00:17:41,670 --> 00:17:44,313
to enable zero downtime.

391
00:17:45,690 --> 00:17:49,560
So, with that, I will conclude
my presentation, okay?

392
00:17:49,560 --> 00:17:53,010
I hope this was understandable

393
00:17:53,010 --> 00:17:57,570
and this is a good segue
to look at code, okay?

394
00:17:57,570 --> 00:17:58,860
Tom, why don't you take it over?

395
00:17:58,860 --> 00:18:01,200
- [Tom Romano] Okay, yeah,
let's take a look at some code.

396
00:18:01,200 --> 00:18:02,970
So, before we dive into the code,

397
00:18:02,970 --> 00:18:05,610
what I'm hoping to show you
today is that implementing some

398
00:18:05,610 --> 00:18:09,450
of these patterns can
be done fairly easily

399
00:18:09,450 --> 00:18:12,570
without really affecting
your main application code.

400
00:18:12,570 --> 00:18:14,010
And to demonstrate that,

401
00:18:14,010 --> 00:18:16,950
I built a little coffee
order processing system.

402
00:18:16,950 --> 00:18:19,590
And it's very straightforward.

403
00:18:19,590 --> 00:18:22,260
I can put in my name, I
can put in my coffee order,

404
00:18:22,260 --> 00:18:24,240
I can submit my order.

405
00:18:24,240 --> 00:18:27,543
And if everything works,
which it did, yay,

406
00:18:28,620 --> 00:18:30,420
then a coffee is submitted.

407
00:18:30,420 --> 00:18:33,660
And then I can go look at
my coffee order history,

408
00:18:33,660 --> 00:18:34,493
pretty straight.

409
00:18:34,493 --> 00:18:35,470
- [Parnab Basak] Are you
really getting coffees,

410
00:18:35,470 --> 00:18:36,303
or it's just a demo?

411
00:18:36,303 --> 00:18:37,136
- [Tom Romano] No, no, this
is just a demonstration.

412
00:18:37,136 --> 00:18:39,840
We're getting virtual
coffee, simulated coffee.

413
00:18:39,840 --> 00:18:43,053
And refresh the order history.

414
00:18:45,630 --> 00:18:48,780
Ah, the demo gods are just
not working with us today.

415
00:18:48,780 --> 00:18:51,240
So, I know why.

416
00:18:51,240 --> 00:18:52,073
- [Parnab Basak] Should we start

417
00:18:52,073 --> 00:18:53,520
by praying to the demo gods before we-

418
00:18:53,520 --> 00:18:55,050
- [Tom Romano] Oh, absolutely, absolutely!

419
00:18:55,050 --> 00:18:56,610
- [Parnab Basak] Okay,
what should the prayer be?

420
00:18:56,610 --> 00:19:00,660
I know, I do this with
regular gods, but I'm no way-

421
00:19:00,660 --> 00:19:02,460
- [Tom Romano] There we go, yep, yep.

422
00:19:02,460 --> 00:19:06,000
Okay, so, we got our coffee
order, so we're good to go.

423
00:19:06,000 --> 00:19:07,200
Awesome.

424
00:19:07,200 --> 00:19:08,670
Look how quickly I fixed my demo.

425
00:19:08,670 --> 00:19:10,290
That was, so, let's take a look

426
00:19:10,290 --> 00:19:13,140
at what the architecture
looks behind the scenes here.

427
00:19:13,140 --> 00:19:15,540
So, this is a pretty
straightforward consumer.

428
00:19:15,540 --> 00:19:19,260
We've got, the producer is my
application that I created.

429
00:19:19,260 --> 00:19:20,850
It's going through Amazon Gateway,

430
00:19:20,850 --> 00:19:23,040
which is my API front door.

431
00:19:23,040 --> 00:19:25,530
It logs a message directly to SQS

432
00:19:25,530 --> 00:19:27,120
and then immediately returns.

433
00:19:27,120 --> 00:19:29,640
So, I get very fast
response to my front end.

434
00:19:29,640 --> 00:19:30,870
It's all decoupled.

435
00:19:30,870 --> 00:19:33,663
This is good event-driven
architecture 101.

436
00:19:34,680 --> 00:19:35,850
We could have any broker here.

437
00:19:35,850 --> 00:19:38,430
I'm just gonna use SQS,
'cause it's convenient.

438
00:19:38,430 --> 00:19:39,690
And then, our consumer

439
00:19:39,690 --> 00:19:42,450
in the background is a Lambda function,

440
00:19:42,450 --> 00:19:44,340
which is a serverless compute function

441
00:19:44,340 --> 00:19:46,620
that is processing the coffee orders.

442
00:19:46,620 --> 00:19:48,420
And as part of that, it does two things.

443
00:19:48,420 --> 00:19:50,700
The first thing it does is
it sends the payment out

444
00:19:50,700 --> 00:19:52,683
to an external payment system.

445
00:19:53,730 --> 00:19:55,320
And then, it will place the coffee order,

446
00:19:55,320 --> 00:19:59,043
which for now, just places the
record in a database table.

447
00:20:00,570 --> 00:20:04,410
But our external payment
system often goes down

448
00:20:04,410 --> 00:20:06,030
for maintenance.

449
00:20:06,030 --> 00:20:07,890
Anyone have this problem?

450
00:20:07,890 --> 00:20:09,120
Yep.

451
00:20:09,120 --> 00:20:12,300
Okay, so, and it typically goes down

452
00:20:12,300 --> 00:20:13,710
for maintenance during a "re:Invent" talk.

453
00:20:13,710 --> 00:20:16,560
So, we'll simulate that too.

454
00:20:16,560 --> 00:20:20,010
So, for example, just to demonstrate this,

455
00:20:20,010 --> 00:20:23,430
I can inject a fault.

456
00:20:23,430 --> 00:20:25,920
So, I'm gonna do a fault injection

457
00:20:25,920 --> 00:20:27,393
and break my payment system.

458
00:20:28,890 --> 00:20:30,330
And then, when I go to order

459
00:20:30,330 --> 00:20:32,610
and I'll order Parnab a few coffees.

460
00:20:32,610 --> 00:20:34,050
- [Parnab Basak] Yeah,
I want that coffee, FYI

461
00:20:34,050 --> 00:20:35,013
without being paid.

462
00:20:36,180 --> 00:20:38,820
- [Tom Romano] I will get
it after the presentation.

463
00:20:38,820 --> 00:20:40,503
I'll submit a few orders.

464
00:20:42,330 --> 00:20:45,230
Okay, you notice that the API
responses are going through.

465
00:20:46,440 --> 00:20:48,603
But when I go to look at order history,

466
00:20:50,490 --> 00:20:52,683
Parnab is not getting his coffee.

467
00:20:53,520 --> 00:20:57,240
The payment system is down,
coffees are not happening.

468
00:20:57,240 --> 00:21:01,140
So, we need to evolve this architecture

469
00:21:01,140 --> 00:21:03,090
to accommodate for this.

470
00:21:03,090 --> 00:21:06,120
And not only it's part of
not getting his coffee,

471
00:21:06,120 --> 00:21:10,410
but let's look at what's going
on behind the scenes here.

472
00:21:10,410 --> 00:21:14,310
I'm gonna go look at my
observability in CloudWatch.

473
00:21:14,310 --> 00:21:18,930
And I submitted my coffee
order, boom, great,

474
00:21:18,930 --> 00:21:21,660
that's how it should look, okay?

475
00:21:21,660 --> 00:21:23,970
But when I look at my message numbers,

476
00:21:23,970 --> 00:21:27,840
I only ordered three coffees
and look at all these messages.

477
00:21:27,840 --> 00:21:31,560
Every 10 seconds, I'm
getting another six messages?

478
00:21:31,560 --> 00:21:33,480
Wow, that's a lot of messages
for just three coffees.

479
00:21:33,480 --> 00:21:36,480
Imagine if this was like Starbucks
with thousands of orders.

480
00:21:37,440 --> 00:21:40,080
I can see that my SQS
depth is staying at three.

481
00:21:40,080 --> 00:21:42,210
Those three messages are
just getting recycled

482
00:21:42,210 --> 00:21:44,793
over and over and over
for those three coffees.

483
00:21:46,740 --> 00:21:49,263
But what's worse is what's
happening with Lambda.

484
00:21:51,030 --> 00:21:52,860
For three cups of coffee,

485
00:21:52,860 --> 00:21:55,020
look at all these invocations.

486
00:21:55,020 --> 00:21:58,233
Invocation, by the way, is
the area underneath the curve.

487
00:21:59,520 --> 00:22:01,410
I'm getting lots of Lambda invocations

488
00:22:01,410 --> 00:22:06,410
and those invocations are
for 30 seconds an invocation.

489
00:22:06,630 --> 00:22:08,733
That's my timeout on my Lambda functions.

490
00:22:10,110 --> 00:22:11,100
So, what's happening?

491
00:22:11,100 --> 00:22:14,790
I'm spending a lot of
compute and getting nowhere.

492
00:22:14,790 --> 00:22:17,670
It's just cycling over
and over these messages.

493
00:22:17,670 --> 00:22:19,140
- [Parnab Basak] And I'm not
getting my coffee as well.

494
00:22:19,140 --> 00:22:20,730
- [Tom Romano] And you're
still not getting your coffee.

495
00:22:20,730 --> 00:22:22,980
It's still gonna be a while
before you get your coffee.

496
00:22:22,980 --> 00:22:25,140
We're just gonna improve this first.

497
00:22:25,140 --> 00:22:25,973
- [Parnab Basak] Okay.

498
00:22:25,973 --> 00:22:28,080
- [Tom Romano] So, from a
cost-optimization standpoint,

499
00:22:28,080 --> 00:22:30,240
I don't want my system
to go out of control

500
00:22:30,240 --> 00:22:31,650
in a failure situation.

501
00:22:31,650 --> 00:22:33,660
I do not want it to go out of control.

502
00:22:33,660 --> 00:22:36,360
I want it to land well.

503
00:22:36,360 --> 00:22:41,313
So, that's why I want to add the DLQ.

504
00:22:45,090 --> 00:22:47,670
So, I'm gonna add a little
bit of architecture here.

505
00:22:47,670 --> 00:22:49,810
As Parnab mentioned, I'm gonna add a DLQ

506
00:22:51,030 --> 00:22:54,690
and so that when a single
message is retried three times,

507
00:22:54,690 --> 00:22:57,063
it'll be automatically moved to the DLQ.

508
00:22:59,700 --> 00:23:01,230
The other thing I wanna do is be able

509
00:23:01,230 --> 00:23:04,950
to redrive those messages
back into the main order queue

510
00:23:04,950 --> 00:23:07,053
when my payment system comes back up.

511
00:23:08,370 --> 00:23:11,640
This sounds like a lot of
work, but it's really not.

512
00:23:11,640 --> 00:23:14,883
And that's because there
are features built into SQS

513
00:23:14,883 --> 00:23:19,470
that can really help us with
some of this implementation,

514
00:23:19,470 --> 00:23:22,383
so that I really don't have
to modify my application much.

515
00:23:24,030 --> 00:23:26,253
Okay, code, yay!

516
00:23:27,690 --> 00:23:29,190
Let's not look at that.

517
00:23:29,190 --> 00:23:32,010
So, I've been using Kiro,

518
00:23:32,010 --> 00:23:34,830
I don't know, has anyone been using Kiro?

519
00:23:34,830 --> 00:23:36,120
I'm like really into it.

520
00:23:36,120 --> 00:23:37,620
I was a VS Code person before.

521
00:23:37,620 --> 00:23:38,453
- [Parnab Basak] Yeah, that's awesome.

522
00:23:38,453 --> 00:23:41,580
Nobody has used Kiro,
okay, which is great.

523
00:23:41,580 --> 00:23:46,470
And you get to see a live
coding how Kiro performs

524
00:23:46,470 --> 00:23:49,260
and you can downvote Kiro, upvote Kiro

525
00:23:49,260 --> 00:23:51,930
in your comments too as we go down.

526
00:23:51,930 --> 00:23:54,300
- [Tom Romano] Yeah, Kiro's available now.

527
00:23:54,300 --> 00:23:55,650
Okay, so, behind my application,

528
00:23:55,650 --> 00:23:56,520
it's infrastructure as code.

529
00:23:56,520 --> 00:23:57,870
Can everyone see that okay?

530
00:23:57,870 --> 00:23:59,190
It's a little hard.

531
00:23:59,190 --> 00:24:00,128
- [Parnab Basak] Yeah.

532
00:24:00,128 --> 00:24:00,961
- [Tom Romano] It's about
as big as I can make-

533
00:24:00,961 --> 00:24:01,794
- [Parnab Basak] Actually, folks

534
00:24:01,794 --> 00:24:02,940
in the last row see that okay?

535
00:24:02,940 --> 00:24:04,080
Thumbs up?

536
00:24:04,080 --> 00:24:04,913
Cool.

537
00:24:04,913 --> 00:24:07,860
- [Tom Romano] Okay, just
wanted to make sure, oops.

538
00:24:07,860 --> 00:24:12,860
So, this is my queue, this
is my current order queue.

539
00:24:12,960 --> 00:24:14,860
That's where the coffee orders all go.

540
00:24:15,810 --> 00:24:17,640
And to add a DLQ,

541
00:24:17,640 --> 00:24:20,940
what we do is we just
create another queue.

542
00:24:20,940 --> 00:24:22,620
And you could do this with anything,

543
00:24:22,620 --> 00:24:24,033
any other messaging service.

544
00:24:25,530 --> 00:24:29,220
And yeah, I actually,

545
00:24:29,220 --> 00:24:31,747
I just hit pound and Kiro said,

546
00:24:31,747 --> 00:24:33,327
"Oh, do you want a DLQ with this?"

547
00:24:33,327 --> 00:24:36,090
And it's like, "Thanks."

548
00:24:36,090 --> 00:24:38,337
So, yeah, we'll take that.

549
00:24:38,337 --> 00:24:39,630
(Tom laughs)

550
00:24:39,630 --> 00:24:42,150
I'm not gonna argue, but let
me walk through the code.

551
00:24:42,150 --> 00:24:44,580
So, I'm gonna create an OrderDLQ,

552
00:24:44,580 --> 00:24:48,720
which is a standard SQS queue,
nothing special about it,

553
00:24:48,720 --> 00:24:53,720
except my message retention
period is 1,209,600 seconds,

554
00:24:57,270 --> 00:24:59,280
or 14 days.

555
00:24:59,280 --> 00:25:01,020
Why did I do that, Parnab?

556
00:25:01,020 --> 00:25:01,853
- [Parnab Basak] I want to get coffee

557
00:25:01,853 --> 00:25:03,705
for the next 14 days for free?

558
00:25:03,705 --> 00:25:04,924
(Tom laughs)

559
00:25:04,924 --> 00:25:05,757
- [Tom Romano] Oh, well, not quite that,

560
00:25:05,757 --> 00:25:08,280
but I need to give myself time to recover.

561
00:25:08,280 --> 00:25:09,113
- [Parnab Basak] Oh, okay.

562
00:25:09,113 --> 00:25:09,946
- [Tom Romano] Yeah, so,

563
00:25:09,946 --> 00:25:11,250
I wanna give myself the time it takes

564
00:25:11,250 --> 00:25:13,410
to notice that the system's
down and recover the system.

565
00:25:13,410 --> 00:25:16,260
So, I'm gonna let this queue messages sit

566
00:25:16,260 --> 00:25:18,203
in this queue for a longer period of time.

567
00:25:19,440 --> 00:25:20,790
Okay, well, that's great, Tom.

568
00:25:20,790 --> 00:25:21,720
You've got a DLQ.

569
00:25:21,720 --> 00:25:25,050
Now, you've gotta go modify
your application, right?

570
00:25:25,050 --> 00:25:27,663
Nope, it's built into SQS.

571
00:25:28,590 --> 00:25:31,650
So, I can go back over
to my normal SQS queue

572
00:25:31,650 --> 00:25:34,893
and I can create a redrive policy.

573
00:25:38,520 --> 00:25:40,863
And when I create a redrive policy,

574
00:25:42,930 --> 00:25:44,880
wow, I don't have to type it all, do I?

575
00:25:46,110 --> 00:25:50,100
When I create my redrive
policy, you specify two things.

576
00:25:50,100 --> 00:25:52,920
First, where you want
those dead-letter messages

577
00:25:52,920 --> 00:25:54,360
to go, what queue

578
00:25:54,360 --> 00:25:56,290
and I wanna send them to my OrderDLQ

579
00:25:57,990 --> 00:25:59,490
and then a maxReceiveCount,

580
00:25:59,490 --> 00:26:01,860
which is like how many
times do I wanna retry

581
00:26:01,860 --> 00:26:04,260
before I move them over to the DLQ.

582
00:26:04,260 --> 00:26:05,760
And give them a couple of tries,

583
00:26:05,760 --> 00:26:06,993
give them two or three.

584
00:26:08,670 --> 00:26:10,420
But then move them over to the DLQ.

585
00:26:11,490 --> 00:26:14,253
And yeah, Kiro really helped me out there.

586
00:26:15,960 --> 00:26:17,100
Now, the other thing I need to do,

587
00:26:17,100 --> 00:26:18,690
is grant it some permissions

588
00:26:18,690 --> 00:26:22,320
and not really wanting to
type in front of everyone.

589
00:26:22,320 --> 00:26:24,030
'Cause I never had to type in class.

590
00:26:24,030 --> 00:26:25,860
I'm just gonna uncomment this.

591
00:26:25,860 --> 00:26:27,270
But basically, what I'm doing now,

592
00:26:27,270 --> 00:26:32,270
is giving my functions access
to the dead-letter queue

593
00:26:34,230 --> 00:26:35,930
and we'll see why I do that later.

594
00:26:39,060 --> 00:26:40,920
So, just giving some permissions.

595
00:26:40,920 --> 00:26:42,750
And then, the final thing I'm going to do,

596
00:26:42,750 --> 00:26:47,737
is send the dead-letter
queue's name and URL,

597
00:26:49,260 --> 00:26:51,240
or ARN and URL over

598
00:26:51,240 --> 00:26:54,210
to my Lambda functions
and environment variables.

599
00:26:54,210 --> 00:26:57,150
That way, my Lambda functions
now know about the DLQ.

600
00:26:57,150 --> 00:27:01,383
They don't have to yet,
but let's just do that.

601
00:27:04,080 --> 00:27:05,730
That's it.

602
00:27:05,730 --> 00:27:08,400
That's all you have to
do to your application.

603
00:27:08,400 --> 00:27:10,560
But now, we do need a redrive function.

604
00:27:10,560 --> 00:27:13,260
So, we need to be able to recover this.

605
00:27:13,260 --> 00:27:17,560
So, I have a Lambda function
that's already kind of a shell

606
00:27:18,780 --> 00:27:23,780
and this Lambda function
is not implemented yet.

607
00:27:23,940 --> 00:27:26,340
But if you can see on my screen,

608
00:27:26,340 --> 00:27:28,140
this is the main logic of it.

609
00:27:28,140 --> 00:27:32,490
It comes in and I have this class,

610
00:27:32,490 --> 00:27:35,163
called test_payment_with_canary_success.

611
00:27:36,180 --> 00:27:38,460
This is part of the pattern
you wanna put in your redrive.

612
00:27:38,460 --> 00:27:40,140
The first thing you wanna do,

613
00:27:40,140 --> 00:27:43,200
is see if your dependency is available.

614
00:27:43,200 --> 00:27:45,870
Because one thing you
don't wanna do is redrive,

615
00:27:45,870 --> 00:27:48,840
or send all those messages
back to be processed

616
00:27:48,840 --> 00:27:50,703
if your downstream system is broken.

617
00:27:52,920 --> 00:27:55,500
So, do a check, do a canary check,

618
00:27:55,500 --> 00:27:57,330
make sure that system's healthy.

619
00:27:57,330 --> 00:27:58,713
And if it is, great.

620
00:28:01,260 --> 00:28:03,420
Once I'm sure that that's healthy,

621
00:28:03,420 --> 00:28:05,970
I can then redrive the messages.

622
00:28:05,970 --> 00:28:09,810
And to do that, I'm going
to use a feature of SQS.

623
00:28:09,810 --> 00:28:13,200
SQS has the ability to pick
messages up for one queue

624
00:28:13,200 --> 00:28:15,300
and deposit them into another

625
00:28:15,300 --> 00:28:19,140
at a rate that you specify automatically.

626
00:28:19,140 --> 00:28:21,000
You don't have to do it manually.

627
00:28:21,000 --> 00:28:23,610
You can just tell SQS, "Go, do it."

628
00:28:23,610 --> 00:28:25,760
And so, we're gonna
use that functionality.

629
00:28:26,970 --> 00:28:29,550
So, I am going to type response,

630
00:28:29,550 --> 00:28:32,403
just so I have a place for
the response of the API call.

631
00:28:34,530 --> 00:28:36,580
And no matter what language you're using,

632
00:28:37,920 --> 00:28:42,920
there is a AWS SDK with
a SQS client in it.

633
00:28:44,880 --> 00:28:47,153
I'm using Python, so, I've got Boto3.

634
00:28:50,333 --> 00:28:52,783
And I'm going to use the
start_message_move_task.

635
00:28:59,160 --> 00:29:00,750
This is the API called the SQS,

636
00:29:00,750 --> 00:29:03,690
that'll move messages from
one queue to the other.

637
00:29:03,690 --> 00:29:07,260
And it takes just two really parameters

638
00:29:07,260 --> 00:29:11,730
that you absolutely need,
which is SourceQueueUrl,

639
00:29:11,730 --> 00:29:13,407
that's where to move messages from

640
00:29:13,407 --> 00:29:17,100
and DestinationQueueUrl where's to.

641
00:29:17,100 --> 00:29:22,100
Now, generative AI is often
helpful and sometimes, it's not.

642
00:29:24,360 --> 00:29:27,956
And it has reversed how I want to do this.

643
00:29:27,956 --> 00:29:28,789
(Tom laughs)

644
00:29:28,789 --> 00:29:33,390
So, I want to move things
from the dead-letter queue

645
00:29:33,390 --> 00:29:34,593
to my order queue.

646
00:29:38,670 --> 00:29:41,460
And I don't wanna move just 10 messages,

647
00:29:41,460 --> 00:29:43,650
I really wanna move them all.

648
00:29:43,650 --> 00:29:46,433
There's a different parameter
I want to use here, which is,

649
00:29:50,130 --> 00:29:51,880
sorry, it just went out of my head.

650
00:29:54,180 --> 00:29:55,937
Number of messages per second.

651
00:30:08,520 --> 00:30:09,510
There we go.

652
00:30:09,510 --> 00:30:13,710
And this specifies how fast
you wanna move everything over.

653
00:30:13,710 --> 00:30:14,640
So, I'm gonna do it,

654
00:30:14,640 --> 00:30:17,070
actually, I'll just do it
at one message per second.

655
00:30:17,070 --> 00:30:18,270
And I'll spell it right.

656
00:30:19,440 --> 00:30:20,273
There we go.

657
00:30:23,280 --> 00:30:25,440
And then, last thing I'm gonna do,

658
00:30:25,440 --> 00:30:26,400
is I'm just gonna make sure

659
00:30:26,400 --> 00:30:29,580
that it actually started that task.

660
00:30:29,580 --> 00:30:34,580
And so, I'm gonna say,
it returns a task handle.

661
00:30:42,840 --> 00:30:45,840
And so, if the task
handle is in the response,

662
00:30:45,840 --> 00:30:49,320
I can say that the redrive
task started successfully,

663
00:30:49,320 --> 00:30:50,370
otherwise, it didn't.

664
00:30:55,890 --> 00:30:57,213
Any questions on that?

665
00:30:59,880 --> 00:31:01,470
Pretty straightforward?

666
00:31:01,470 --> 00:31:03,081
- [Parnab Basak] So, basically,
what you're doing, Tom,

667
00:31:03,081 --> 00:31:08,081
is you're trying to redrive
the messages back from the DLQ

668
00:31:08,580 --> 00:31:10,860
to over to the actual queue,

669
00:31:10,860 --> 00:31:13,590
assuming that the consumer
is now back alive.

670
00:31:13,590 --> 00:31:14,610
- [Tom Romano] Correct.

671
00:31:14,610 --> 00:31:15,443
- [Parnab Basak] Okay.

672
00:31:15,443 --> 00:31:16,276
- [Tom Romano] Yep.

673
00:31:16,276 --> 00:31:17,303
- [Parnab Basak] Yes, sir?
- [Tom Romano] Question?

674
00:31:20,010 --> 00:31:22,610
- [Parnab Basak] Can you
show us the canary success?

675
00:31:24,450 --> 00:31:26,280
- [Tom Romano] Oh, the success check?

676
00:31:26,280 --> 00:31:27,113
- [Parnab Basak] Okay.

677
00:31:27,113 --> 00:31:27,946
- [Tom Romano] Yep, we can do that.

678
00:31:27,946 --> 00:31:28,936
- [Parnab Basak] The question,

679
00:31:28,936 --> 00:31:30,360
is can we show us the
canary success check,

680
00:31:30,360 --> 00:31:32,370
how we are doing it in the original code?

681
00:31:32,370 --> 00:31:34,020
Again, this is Python, but again,

682
00:31:34,020 --> 00:31:38,040
I think that's the most
easiest language to understand.

683
00:31:38,040 --> 00:31:40,680
So, if you are a developer
from other languages,

684
00:31:40,680 --> 00:31:41,910
just follow us along.

685
00:31:41,910 --> 00:31:43,740
There are equivalents of these-

686
00:31:43,740 --> 00:31:44,573
- [Tom Romano] Okay.

687
00:31:44,573 --> 00:31:46,950
- [Parnab Basak] Available
in Java, .NET and-

688
00:31:46,950 --> 00:31:48,600
- [Tom Romano] So, this is my canary.

689
00:31:48,600 --> 00:31:53,040
And what the canary does
is it sends a test order,

690
00:31:53,040 --> 00:31:55,620
an order that the payment
system will ignore

691
00:31:55,620 --> 00:31:57,540
when it receives it,

692
00:31:57,540 --> 00:31:59,700
but it's basically full up testing it out.

693
00:31:59,700 --> 00:32:03,330
It's sending an order for
zero just to make sure,

694
00:32:03,330 --> 00:32:05,220
it's like a heartbeat check.

695
00:32:05,220 --> 00:32:06,450
And I could do a lot with this.

696
00:32:06,450 --> 00:32:08,340
I could find out what the delay is.

697
00:32:08,340 --> 00:32:11,910
I could measure latency.

698
00:32:11,910 --> 00:32:15,330
I could, yeah, see what
the response time is.

699
00:32:15,330 --> 00:32:18,000
So, basically, I've negotiated
with the payment system

700
00:32:18,000 --> 00:32:20,790
to ignore this particular test message.

701
00:32:20,790 --> 00:32:22,380
And I can send it whenever I want.

702
00:32:22,380 --> 00:32:25,470
- [Parnab Basak] The best piece
I love is the amount is 0.0.

703
00:32:25,470 --> 00:32:26,303
- [Tom Romano] Yep.

704
00:32:26,303 --> 00:32:27,554
- [Parnab Basak] That's the
only thing that matters, yes?

705
00:32:27,554 --> 00:32:29,075
- [Tom Romano] That's what I'm doing.

706
00:32:29,075 --> 00:32:30,243
- [Audience Member 1] Is
there some sort of TTL,

707
00:32:30,243 --> 00:32:31,333
being managed for you

708
00:32:31,333 --> 00:32:34,443
and so, you don't end up
getting a forever loop or-

709
00:32:34,443 --> 00:32:35,991
- [Tom Romano] Yes, there was, oops-

710
00:32:35,991 --> 00:32:36,824
- [Parnab Basak] The question is,

711
00:32:36,824 --> 00:32:39,000
is there a TTL for the loop for canary

712
00:32:39,000 --> 00:32:42,750
to ensure that you're
not checking the health

713
00:32:42,750 --> 00:32:45,464
of the system too many times?

714
00:32:45,464 --> 00:32:46,297
- [Audience Member 1] No, no, no.

715
00:32:46,297 --> 00:32:48,320
It's just so the message
doesn't get redrived

716
00:32:48,320 --> 00:32:50,400
and move between queues a 4 billion times.

717
00:32:50,400 --> 00:32:51,450
- [Tom Romano] Ah, okay, yep,

718
00:32:51,450 --> 00:32:53,520
move between queues a number of times.

719
00:32:53,520 --> 00:32:56,490
So, when I did the redrive-

720
00:32:56,490 --> 00:32:58,170
- [Parnab Basak] You want
to repeat the question?

721
00:32:58,170 --> 00:32:59,003
- [Tom Romano] So, the question,

722
00:32:59,003 --> 00:33:00,390
was how do you stop the messages

723
00:33:00,390 --> 00:33:02,400
from constantly bouncing back and forth

724
00:33:02,400 --> 00:33:05,520
between the DLQ and the actual queue?

725
00:33:05,520 --> 00:33:10,520
And that's really taken
care of in the redrive logic

726
00:33:10,800 --> 00:33:15,090
by ensuring that the
system is ready and able

727
00:33:15,090 --> 00:33:16,350
to handle those messages

728
00:33:16,350 --> 00:33:18,780
before I send them back
to the order queue.

729
00:33:18,780 --> 00:33:21,900
So, I verify that that
order queue will work

730
00:33:21,900 --> 00:33:26,013
and will process those before
I send them over there.

731
00:33:28,740 --> 00:33:30,000
And that's key.

732
00:33:30,000 --> 00:33:32,100
Sometimes, I've seen implementations

733
00:33:32,100 --> 00:33:32,933
where they don't do that.

734
00:33:32,933 --> 00:33:35,050
And yeah, you get a
bouncing back and forth.

735
00:33:36,499 --> 00:33:37,332
- [Audience Member 2] Right,

736
00:33:37,332 --> 00:33:39,240
what if is the problem with
the actual message itself

737
00:33:39,240 --> 00:33:42,210
that the logic is gonna
be built is bouncing back?

738
00:33:42,210 --> 00:33:43,043
- [Tom Romano] What if the problem,

739
00:33:43,043 --> 00:33:44,970
is with the actual message itself

740
00:33:44,970 --> 00:33:47,070
and it continues to get
bounced back and forth?

741
00:33:47,070 --> 00:33:48,660
- [Parnab Basak] That's
a very good question.

742
00:33:48,660 --> 00:33:50,730
Okay, so, the way we have implemented one

743
00:33:50,730 --> 00:33:54,120
of the best practice there
is there are two use cases

744
00:33:54,120 --> 00:33:57,060
that you can do multiple DLQ patterns.

745
00:33:57,060 --> 00:34:00,600
One is for messages that
need manual intervention,

746
00:34:00,600 --> 00:34:04,410
either from developers,
sysadmins, ops, et cetera,

747
00:34:04,410 --> 00:34:07,200
to be able to make a
correction on those messages.

748
00:34:07,200 --> 00:34:08,610
That's a separate DLQ.

749
00:34:08,610 --> 00:34:10,950
And the other DLQ can be a queue

750
00:34:10,950 --> 00:34:14,190
where you are just parking the messages

751
00:34:14,190 --> 00:34:16,830
in order for them to be processed later

752
00:34:16,830 --> 00:34:18,510
when the source systems becomes healthy.

753
00:34:18,510 --> 00:34:19,677
For example, in this case,

754
00:34:19,677 --> 00:34:21,600
the payment system becomes healthy.

755
00:34:21,600 --> 00:34:24,630
So, that's a divide and conquer approach.

756
00:34:24,630 --> 00:34:28,290
You cannot just have one
single DLQ to handle everything

757
00:34:28,290 --> 00:34:32,100
from manual intervention,
schema mismatches,

758
00:34:32,100 --> 00:34:33,963
or service unavailability.

759
00:34:39,510 --> 00:34:41,640
- [Tom Romano] Okay,
so, I deployed my DLQ.

760
00:34:41,640 --> 00:34:42,660
And I'm gonna show you this,

761
00:34:42,660 --> 00:34:45,630
but then I'm gonna show you
another kind of view of this.

762
00:34:45,630 --> 00:34:47,640
Remember that we had ordered some coffees?

763
00:34:47,640 --> 00:34:48,473
- [Parnab Basak] Yeah.

764
00:34:48,473 --> 00:34:50,220
- [Tom Romano] And they
were bouncing around?

765
00:34:50,220 --> 00:34:52,260
Well, as soon as I deployed my DLQ,

766
00:34:52,260 --> 00:34:54,510
it's starting to get back under control.

767
00:34:54,510 --> 00:34:57,030
You can see the numbers
are starting to dip down.

768
00:34:57,030 --> 00:35:00,063
But let me show you maybe
a cleaner view of that.

769
00:35:04,350 --> 00:35:07,230
So, here's the behavior with DLQ.

770
00:35:07,230 --> 00:35:08,063
So, first of all,

771
00:35:08,063 --> 00:35:10,803
I don't have that continual
bouncing of messages.

772
00:35:11,640 --> 00:35:14,523
Things get under control
relatively quickly.

773
00:35:16,800 --> 00:35:18,150
But the more important story,

774
00:35:18,150 --> 00:35:19,833
is what's happening with Lambda.

775
00:35:20,700 --> 00:35:24,270
Yes, I'm getting a few
executions of 30 seconds,

776
00:35:24,270 --> 00:35:26,040
but not continuously.

777
00:35:26,040 --> 00:35:28,500
I'm not getting Lambda storms,

778
00:35:28,500 --> 00:35:30,120
I'm not spinning my wheels trying to,

779
00:35:30,120 --> 00:35:31,893
they're moving over to the DLQ.

780
00:35:36,210 --> 00:35:39,480
And even though Parnab still
doesn't have his coffee-

781
00:35:39,480 --> 00:35:41,345
- [Parnab Basak] Yep.
- [Tom Romano] Right?

782
00:35:41,345 --> 00:35:43,428
- [Parnab Basak] I don't.

783
00:35:44,460 --> 00:35:46,313
- [Tom Romano] You still
don't have your coffee.

784
00:35:47,620 --> 00:35:50,070
And this is where we again
pray to the demo gods,

785
00:35:51,030 --> 00:35:53,940
we're gonna do a redrive,
which gave me an error.

786
00:35:53,940 --> 00:35:58,140
So, I wasn't able to show that on that.

787
00:35:58,140 --> 00:36:00,300
But what we would do is we
would redrive it right over

788
00:36:00,300 --> 00:36:01,293
to the messages.

789
00:36:06,540 --> 00:36:09,990
Not wanting you to be left without,

790
00:36:09,990 --> 00:36:11,283
let's do a redrive demo.

791
00:36:14,430 --> 00:36:19,430
So, basically, what we're going
to do now is with the DLQ,

792
00:36:20,160 --> 00:36:23,280
we're gonna take the
messages that were in the DLQ

793
00:36:23,280 --> 00:36:24,760
and use the redrive function

794
00:36:26,760 --> 00:36:28,760
to redrive them back to the event queue.

795
00:36:32,730 --> 00:36:35,823
So, we'll break the system,
order a few coffees.

796
00:36:42,570 --> 00:36:43,683
Submit that.

797
00:36:45,240 --> 00:36:46,173
I'll submit a few.

798
00:36:53,160 --> 00:36:55,890
- [Parnab Basak] So, DLQ
test needs three coffees now?

799
00:36:55,890 --> 00:36:56,783
- [Tom Romano] Yeah.

800
00:36:57,990 --> 00:36:59,550
- [Parnab Basak] And I don't get any?

801
00:36:59,550 --> 00:37:00,990
- [Tom Romano] You don't get any.

802
00:37:00,990 --> 00:37:02,070
- [Parnab Basak] That's not good.

803
00:37:02,070 --> 00:37:03,070
- [Tom Romano] Okay.

804
00:37:04,260 --> 00:37:08,673
Yep, we see the system behavior
gets under control quick.

805
00:37:10,410 --> 00:37:12,480
The messages drop off quickly.

806
00:37:12,480 --> 00:37:15,033
Our Lambda function is in control.

807
00:37:16,500 --> 00:37:19,200
So, a little bit of processing
there, but not too bad.

808
00:37:20,790 --> 00:37:22,540
Now, I can go fix my payment system

809
00:37:25,020 --> 00:37:26,313
and redrive the orders.

810
00:37:30,630 --> 00:37:32,643
So, it starts the redrive process.

811
00:37:33,540 --> 00:37:35,760
If I go look at order history,

812
00:37:35,760 --> 00:37:38,700
we start to see, it starts
to redrive those messages,

813
00:37:38,700 --> 00:37:39,870
one coffee a second.

814
00:37:39,870 --> 00:37:41,313
So, there's the first order.

815
00:37:46,320 --> 00:37:47,770
The second order has arrived.

816
00:37:48,810 --> 00:37:50,963
And they're all coming
out of the redrive queue.

817
00:37:57,840 --> 00:38:00,420
So, that's the demo about how it works.

818
00:38:00,420 --> 00:38:02,400
- [Parnab Basak] Okay, before
we move into the next pattern,

819
00:38:02,400 --> 00:38:03,570
any questions?

820
00:38:03,570 --> 00:38:05,190
Is there anything that we are missing here

821
00:38:05,190 --> 00:38:06,600
that we should be implementing?

822
00:38:06,600 --> 00:38:07,865
Yes, sir?

823
00:38:07,865 --> 00:38:10,493
- [Audience Member 3]
I'm a security officer

824
00:38:10,493 --> 00:38:13,290
and (indistinct) manual redrive,

825
00:38:13,290 --> 00:38:14,850
I have an operator and I see some stuff

826
00:38:14,850 --> 00:38:17,684
in my (indistinct)
redrive guidance program.

827
00:38:17,684 --> 00:38:21,290
I've (indistinct) there
something not quite (indistinct).

828
00:38:22,350 --> 00:38:24,150
- [Parnab Basak] So, the
question that has that,

829
00:38:24,150 --> 00:38:26,610
is there an option in the console

830
00:38:26,610 --> 00:38:31,443
for manual redrive of
messages back to the queue,

831
00:38:33,480 --> 00:38:34,830
which needs manual intervention?

832
00:38:34,830 --> 00:38:38,250
So, a message comes in
probably for coffee,

833
00:38:38,250 --> 00:38:40,470
maybe the coffee type was not mentioned

834
00:38:40,470 --> 00:38:42,240
and that's a mandatory message.

835
00:38:42,240 --> 00:38:44,280
It gets pushed over to the DLQ.

836
00:38:44,280 --> 00:38:46,433
And somebody needs to
actually really tell, okay,

837
00:38:46,433 --> 00:38:49,290
"Parnab needs mocha and not latte," right?

838
00:38:49,290 --> 00:38:51,150
Okay and then once you
go change that feeling,

839
00:38:51,150 --> 00:38:53,040
that what's the option to do it?

840
00:38:53,040 --> 00:38:54,960
You wanna answer the question?

841
00:38:54,960 --> 00:38:55,950
- [Tom Romano] No, I'm good.

842
00:38:55,950 --> 00:38:56,820
- [Parnab Basak] Okay, cool.
(Tom laughs)

843
00:38:56,820 --> 00:38:57,990
So, the way to do this,

844
00:38:57,990 --> 00:39:00,327
yes, you have this
option to do this, okay?

845
00:39:00,327 --> 00:39:02,700
So, you have, there is a,

846
00:39:02,700 --> 00:39:05,250
I think, AWS Samples also have a utility

847
00:39:05,250 --> 00:39:06,390
by which you can point it

848
00:39:06,390 --> 00:39:08,880
to your dead-letter queues
in this in the samples

849
00:39:08,880 --> 00:39:11,310
by which I don't think
there is a direct way

850
00:39:11,310 --> 00:39:16,050
to make a change on the
message in the console, okay?

851
00:39:16,050 --> 00:39:18,690
You have to create some
utility of your own.

852
00:39:18,690 --> 00:39:20,550
And I think there are
a few samples out there

853
00:39:20,550 --> 00:39:22,380
that gives you the option to do this

854
00:39:22,380 --> 00:39:26,400
where you configure the DLQ

855
00:39:26,400 --> 00:39:28,170
and as well as the target queue

856
00:39:28,170 --> 00:39:30,390
to be able to push those messages, okay?

857
00:39:30,390 --> 00:39:35,220
Because AWS Console does
not give any options

858
00:39:35,220 --> 00:39:38,670
to make any changes to the
messages through the console.

859
00:39:38,670 --> 00:39:40,951
It shows you the messages,
the structure of it.

860
00:39:40,951 --> 00:39:41,784
- [Tom Romano] Mm-hmm (affirmative).

861
00:39:41,784 --> 00:39:43,080
- [Parnab Basak] And count of it, okay?

862
00:39:43,080 --> 00:39:44,400
How it looks like.

863
00:39:44,400 --> 00:39:48,840
But there is no other
options to change them live

864
00:39:48,840 --> 00:39:51,090
and then be able to
redirect them back again.

865
00:39:52,560 --> 00:39:54,000
Any other questions?

866
00:39:54,000 --> 00:39:54,833
Yes, sir.

867
00:39:55,676 --> 00:40:00,343
(Audience Member 4 speaks indistinctly)

868
00:40:04,950 --> 00:40:08,700
So, what is the, the
question that he has is,

869
00:40:08,700 --> 00:40:10,800
so, how are you pulling up the messages

870
00:40:10,800 --> 00:40:13,890
from the DLQ to be able to push them back

871
00:40:13,890 --> 00:40:15,420
into the standard queue?

872
00:40:15,420 --> 00:40:18,690
Is it by age, is it by count of messages,

873
00:40:18,690 --> 00:40:20,340
is it by message type?

874
00:40:20,340 --> 00:40:21,965
Did I get your question right?

875
00:40:21,965 --> 00:40:23,676
- [Audience Member 4]
Use the native redrive,

876
00:40:23,676 --> 00:40:26,610
does it use properties,
for example, the age,

877
00:40:26,610 --> 00:40:29,220
the initial age, rather the
age when it was pushed back

878
00:40:29,220 --> 00:40:32,599
from the DLQ to the main order queue?

879
00:40:32,599 --> 00:40:33,432
- [Parnab Basak] Hmm.

880
00:40:33,432 --> 00:40:34,265
- [Audience Member 4]
So, is it a new message,

881
00:40:34,265 --> 00:40:35,730
or is it the same message

882
00:40:35,730 --> 00:40:38,380
and these properties are basically kept?

883
00:40:38,380 --> 00:40:40,190
- [Parnab Basak] Yeah, so
the message, if you are,

884
00:40:40,190 --> 00:40:41,400
so the question that he has,

885
00:40:41,400 --> 00:40:45,270
is let's say you are pushing in a message

886
00:40:45,270 --> 00:40:48,510
to the regular queue

887
00:40:48,510 --> 00:40:51,060
and that message gets
pushed over to the DLQ.

888
00:40:51,060 --> 00:40:52,980
What happens with the age of the message,

889
00:40:52,980 --> 00:40:54,720
some of the properties there?

890
00:40:54,720 --> 00:40:57,870
So, essentially, the
message is kept as is.

891
00:40:57,870 --> 00:40:59,970
There are some additional
metadata properties

892
00:40:59,970 --> 00:41:02,490
that get changed for that messages.

893
00:41:02,490 --> 00:41:04,200
But these are two different messages

894
00:41:04,200 --> 00:41:06,450
in two different queues there, okay?

895
00:41:06,450 --> 00:41:08,970
So, let's say, message A,

896
00:41:08,970 --> 00:41:13,473
original message has a
timestamp of 10:45, okay?

897
00:41:14,670 --> 00:41:16,410
And then when you push the messages over

898
00:41:16,410 --> 00:41:19,350
to the standard queue or DLQ,

899
00:41:19,350 --> 00:41:22,680
it probably will have a 10:46
with the different timestamp.

900
00:41:22,680 --> 00:41:25,380
But the contents of the
messages will remain as is,

901
00:41:25,380 --> 00:41:27,530
unless you are making
manual changes to it.

902
00:41:28,912 --> 00:41:29,745
Okay?

903
00:41:29,745 --> 00:41:32,730
So, what you define as
the message is important.

904
00:41:32,730 --> 00:41:34,350
- [Tom Romano] And if order is important,

905
00:41:34,350 --> 00:41:37,419
if your order queue is FIFO,
then your DLQ needs to be FIFO.

906
00:41:37,419 --> 00:41:38,252
- [Parnab Basak] Yes.

907
00:41:38,252 --> 00:41:39,960
So, some of the best practices there,

908
00:41:39,960 --> 00:41:44,960
so, Amazon SQS also supports
a first-in, first-out queue

909
00:41:45,750 --> 00:41:47,250
in which the ordering

910
00:41:47,250 --> 00:41:50,400
of which they were
published in is maintained.

911
00:41:50,400 --> 00:41:52,410
So, if your original queue,

912
00:41:52,410 --> 00:41:55,350
is an Amazon Simple Queuing Service,

913
00:41:55,350 --> 00:41:57,210
first-in, first-out queue,

914
00:41:57,210 --> 00:42:02,070
probably a best practice
is to use a similar DLQ

915
00:42:02,070 --> 00:42:03,393
to maintain the ordering.

916
00:42:05,160 --> 00:42:06,840
- [Tom Romano] Okay.

917
00:42:06,840 --> 00:42:08,730
Let's switch to the next architecture.

918
00:42:08,730 --> 00:42:11,340
And what we're gonna do is evolve the DLQ.

919
00:42:11,340 --> 00:42:13,470
Oh, there's one more question.

920
00:42:13,470 --> 00:42:15,754
- [Parnab Basak] Oh, sorry, yeah?

921
00:42:15,754 --> 00:42:19,994
- [Audience Member 5] So, in
terms of triggering the drive-

922
00:42:19,994 --> 00:42:20,959
- [Parnab Basak] Redrive.

923
00:42:20,959 --> 00:42:23,364
- [Audience Member 5] Redrive,

924
00:42:23,364 --> 00:42:25,049
so, what's the best practice?

925
00:42:25,049 --> 00:42:29,040
(Audience Member 5 speaks indistinctly)

926
00:42:29,040 --> 00:42:30,360
How do you work out that?

927
00:42:30,360 --> 00:42:31,710
- [Tom Romano] Great question.

928
00:42:31,710 --> 00:42:33,870
I'm actually gonna share
you a couple of options

929
00:42:33,870 --> 00:42:35,220
in the circuit breaker.

930
00:42:35,220 --> 00:42:37,113
- [Parnab Basak] So, let
me repeat the question.

931
00:42:37,113 --> 00:42:37,946
- [Tom Romano] Yep.

932
00:42:37,946 --> 00:42:39,720
- [Parnab Basak] So, what
is the best time to redrive?

933
00:42:39,720 --> 00:42:42,300
At what frequency should
I redrive these messages

934
00:42:42,300 --> 00:42:45,960
from the DLQ back to the original queue?

935
00:42:45,960 --> 00:42:47,250
What's a good practice there?

936
00:42:47,250 --> 00:42:48,930
How soon, how frequently,

937
00:42:48,930 --> 00:42:50,940
how infrequently should we do that?

938
00:42:50,940 --> 00:42:55,920
And Parnab's, no, Tom's
response like any other SAs is-

939
00:42:55,920 --> 00:42:56,753
- [Tom Romano] It depends.

940
00:42:56,753 --> 00:42:57,719
- [Parnab Basak] It depends.

941
00:42:57,719 --> 00:42:58,560
(Tom laughs)

942
00:42:58,560 --> 00:42:59,700
And with that,

943
00:42:59,700 --> 00:43:01,590
he's going to talk about
some other architectures

944
00:43:01,590 --> 00:43:03,870
that talks about that in mind.

945
00:43:03,870 --> 00:43:04,703
- [Tom Romano] Yeah, I do,

946
00:43:04,703 --> 00:43:06,960
I wanna extend the DLQ architecture now

947
00:43:06,960 --> 00:43:08,460
into the circuit breaker architecture.

948
00:43:08,460 --> 00:43:11,220
And also, I wanna start
looking at self-healing.

949
00:43:11,220 --> 00:43:13,830
Like how do we make the
redrive happen automatically,

950
00:43:13,830 --> 00:43:15,630
so that I don't have to press the button

951
00:43:15,630 --> 00:43:17,400
and I don't get called?

952
00:43:17,400 --> 00:43:20,613
And then, what you have
is a self-healing system.

953
00:43:21,570 --> 00:43:22,533
That's the dream.

954
00:43:23,700 --> 00:43:25,213
- [Parnab Basak] Yep, let's-
- [Tom Romano] You want-

955
00:43:25,213 --> 00:43:26,046
- [Parnab Basak] Yeah-

956
00:43:26,046 --> 00:43:26,879
- [Tom Romano] You don't wanna get paid.

957
00:43:26,879 --> 00:43:27,712
- [Parnab Basak] Why
don't we get to the dream?

958
00:43:27,712 --> 00:43:30,570
- [Tom Romano] Yes, so,
the first thing I need,

959
00:43:30,570 --> 00:43:32,670
is I need a circuit breaker.

960
00:43:32,670 --> 00:43:35,400
And I've implemented a
circuit breaker for us just

961
00:43:35,400 --> 00:43:37,500
in the name of expediency

962
00:43:37,500 --> 00:43:39,360
and it's a controlled database

963
00:43:39,360 --> 00:43:40,923
and I've got four methods here.

964
00:43:42,000 --> 00:43:42,937
I've got a method that says,

965
00:43:42,937 --> 00:43:45,360
"Is the circuit open, true or false?

966
00:43:45,360 --> 00:43:46,890
Is the circuit closed, true or false,"

967
00:43:46,890 --> 00:43:48,063
which is the opposite.

968
00:43:49,530 --> 00:43:52,320
And then I have a method that
will open the circuit breaker,

969
00:43:52,320 --> 00:43:54,780
which means something went wrong.

970
00:43:54,780 --> 00:43:55,726
And then,

971
00:43:55,726 --> 00:43:56,970
I have a method that will
close the circuit breaker,

972
00:43:56,970 --> 00:43:58,593
which means everything is good.

973
00:44:00,000 --> 00:44:03,180
Behind the scenes, it's
just a DynamoDB table,

974
00:44:03,180 --> 00:44:06,120
it's actually just an
item in a DynamoDB table.

975
00:44:06,120 --> 00:44:07,350
DynamoDB is really good for this.

976
00:44:07,350 --> 00:44:10,200
It's a quick key value lookup-

977
00:44:10,200 --> 00:44:11,033
- [Parnab Basak] Yep.

978
00:44:11,033 --> 00:44:12,150
- [Tom Romano] That you
can put cache in front of.

979
00:44:12,150 --> 00:44:14,460
So, it's really good
for this kind of stuff.

980
00:44:14,460 --> 00:44:19,140
So, I've got a circuit_breaker_payment
item in my database

981
00:44:19,140 --> 00:44:21,033
and the circuit's currently closed.

982
00:44:22,050 --> 00:44:24,033
So, to add the circuit breaker,

983
00:44:27,349 --> 00:44:30,007
I do need to add a little
bit more architecture.

984
00:44:32,610 --> 00:44:34,170
I don't have any more moving pieces,

985
00:44:34,170 --> 00:44:36,150
but I have a bit more logic.

986
00:44:36,150 --> 00:44:37,200
In my consumer,

987
00:44:37,200 --> 00:44:41,103
what I wanna do is see if
the circuit's open first.

988
00:44:42,120 --> 00:44:45,630
If it is open, then I
don't want to process.

989
00:44:45,630 --> 00:44:47,760
I want to assume I'm just gonna fail.

990
00:44:47,760 --> 00:44:49,800
Because someone before me has determined

991
00:44:49,800 --> 00:44:51,900
that the payment system's not good

992
00:44:51,900 --> 00:44:54,093
and I just need to like fail fast.

993
00:44:56,400 --> 00:44:59,013
If I call the payment service in error,

994
00:45:00,030 --> 00:45:02,340
then I need to open the circuit

995
00:45:02,340 --> 00:45:05,670
and send it to the dead-letter
queue for a later processing.

996
00:45:05,670 --> 00:45:07,290
So, I need to do a little bit more work

997
00:45:07,290 --> 00:45:08,913
in my order-processing Lambda.

998
00:45:10,620 --> 00:45:13,200
The only thing that I need
to change in my redrive,

999
00:45:13,200 --> 00:45:15,960
is if I notice that the service is up,

1000
00:45:15,960 --> 00:45:18,090
I need to close the circuit breaker

1001
00:45:18,090 --> 00:45:19,803
and allow messages to flow again.

1002
00:45:21,360 --> 00:45:23,040
So, it's sort of the pairing of the two

1003
00:45:23,040 --> 00:45:24,780
that open and close the circuit.

1004
00:45:24,780 --> 00:45:27,390
I open the circuit in my consumer,

1005
00:45:27,390 --> 00:45:29,740
I close the circuit in my redrive.

1006
00:45:32,310 --> 00:45:33,813
Okay, let's implement this.

1007
00:45:37,200 --> 00:45:39,525
- [Parnab Basak] Let's do the video,

1008
00:45:39,525 --> 00:45:40,440
show the video directly.

1009
00:45:40,440 --> 00:45:41,393
- [Tom Romano] Okay.

1010
00:45:48,810 --> 00:45:50,010
We've had some great questions

1011
00:45:50,010 --> 00:45:51,030
and we're a little short on time.

1012
00:45:51,030 --> 00:45:52,680
So, I'm actually just
gonna do the video of it

1013
00:45:52,680 --> 00:45:53,513
if that's okay.

1014
00:45:55,260 --> 00:45:57,843
So, we're gonna look
in our order processor.

1015
00:45:59,220 --> 00:46:01,320
And when you come into
our order processor,

1016
00:46:01,320 --> 00:46:03,630
it just asks for the payment.

1017
00:46:03,630 --> 00:46:04,830
So, what we wanna do is see

1018
00:46:04,830 --> 00:46:09,830
if the circuit breaker
is currently closed.

1019
00:46:12,030 --> 00:46:14,973
If it's closed, go ahead
and try the payment.

1020
00:46:17,310 --> 00:46:19,980
Otherwise, it's open

1021
00:46:19,980 --> 00:46:20,820
and I'm just gonna go ahead

1022
00:46:20,820 --> 00:46:23,520
and raise my payment processing error.

1023
00:46:23,520 --> 00:46:24,993
I'll just raise an error.

1024
00:46:26,970 --> 00:46:27,803
So, you just need

1025
00:46:27,803 --> 00:46:30,123
to wrap your logic
around a circuit breaker.

1026
00:46:33,240 --> 00:46:36,090
If you get an error, you wanna
open your circuit breaker.

1027
00:46:40,530 --> 00:46:44,190
The next thing you wanna
do is send the message

1028
00:46:44,190 --> 00:46:47,250
to your dead-letter queue manually.

1029
00:46:47,250 --> 00:46:49,150
Because you weren't able to process it

1030
00:46:50,250 --> 00:46:53,150
and you need to catch it and
you need to send it yourself.

1031
00:46:54,630 --> 00:46:56,430
So, I'm gonna send this message over

1032
00:46:57,300 --> 00:46:59,500
and I'm just gonna send
my whole order over.

1033
00:47:01,800 --> 00:47:04,230
So, I'm just gonna dump the whole order

1034
00:47:04,230 --> 00:47:05,643
over into the message body.

1035
00:47:17,280 --> 00:47:19,170
The other thing that I want to do,

1036
00:47:19,170 --> 00:47:21,000
is rather than raise an error

1037
00:47:21,000 --> 00:47:22,470
and fail out of the whole Lambda,

1038
00:47:22,470 --> 00:47:24,660
I'm just gonna keep processing.

1039
00:47:24,660 --> 00:47:26,557
I'm gonna return a stub that says,

1040
00:47:26,557 --> 00:47:28,230
"Well, you can get your coffee,

1041
00:47:28,230 --> 00:47:30,360
but you haven't paid for it yet."

1042
00:47:30,360 --> 00:47:35,103
So, I'm going to fail
deprecated rather than fail.

1043
00:47:37,740 --> 00:47:41,130
And I've moved my message
to the dead-letter queue

1044
00:47:41,130 --> 00:47:43,170
and I'll process that payment later.

1045
00:47:43,170 --> 00:47:45,480
And that way, Parnab will
get his coffee right away.

1046
00:47:45,480 --> 00:47:46,613
- [Parnab Basak] Finally.

1047
00:47:48,300 --> 00:47:49,830
- [Tom Romano] So, that's the
only change you need to make

1048
00:47:49,830 --> 00:47:52,800
to the order processing.

1049
00:47:52,800 --> 00:47:55,440
Basically, check that
the circuit is closed

1050
00:47:55,440 --> 00:47:58,050
before you actually implement.

1051
00:47:58,050 --> 00:47:59,580
And if it fails,

1052
00:47:59,580 --> 00:48:02,283
open the circuit and send
it to the dead-letter queue.

1053
00:48:08,640 --> 00:48:12,333
For the redrive, the
change is very simple.

1054
00:48:13,950 --> 00:48:15,603
When I go to my redrive function,

1055
00:48:17,190 --> 00:48:22,190
if the canary succeeds, close
the circuit, that simple.

1056
00:48:22,800 --> 00:48:24,480
It's working, close the circuit,

1057
00:48:24,480 --> 00:48:26,853
allow processing to flow again.

1058
00:48:30,840 --> 00:48:32,700
And that is literally the
only change I need to make

1059
00:48:32,700 --> 00:48:33,990
to my redrive.

1060
00:48:33,990 --> 00:48:37,023
But we wanna automatically recover, right?

1061
00:48:37,920 --> 00:48:42,540
What we can do is we can
schedule our redrive function

1062
00:48:42,540 --> 00:48:44,163
to automatically run.

1063
00:48:45,690 --> 00:48:48,090
And it will check the
payment processing system.

1064
00:48:49,140 --> 00:48:50,490
So, what I'll do is I'll just schedule it

1065
00:48:50,490 --> 00:48:51,663
to run automatically.

1066
00:48:54,690 --> 00:48:56,820
I'm just gonna add an EventBridge schedule

1067
00:48:56,820 --> 00:48:58,020
to that Lambda function.

1068
00:48:59,070 --> 00:49:00,970
And I'll have it run every minute

1069
00:49:01,860 --> 00:49:03,990
and I'll call it PeriodicRedrive.

1070
00:49:03,990 --> 00:49:04,823
So, every minute,

1071
00:49:04,823 --> 00:49:06,390
it's gonna see "Is the
payment service up?"

1072
00:49:06,390 --> 00:49:08,040
Great, redrive.

1073
00:49:08,040 --> 00:49:09,210
It's not gonna redrive anything

1074
00:49:09,210 --> 00:49:11,220
if there's nothing to redrive.

1075
00:49:11,220 --> 00:49:14,313
And that will make my system
entirely self-healing.

1076
00:49:15,480 --> 00:49:16,560
Do you wanna do it every minute?

1077
00:49:16,560 --> 00:49:17,400
Probably not.

1078
00:49:17,400 --> 00:49:19,550
I'm just doing that
for demo purposes here.

1079
00:49:21,360 --> 00:49:24,090
But that's the only change
that you need to make.

1080
00:49:24,090 --> 00:49:25,710
- [Parnab Basak] So, coming
back to his question,

1081
00:49:25,710 --> 00:49:28,360
what should be a good redrive policy

1082
00:49:29,370 --> 00:49:31,950
to redrive your messages back,

1083
00:49:31,950 --> 00:49:34,147
or check the health of the scheduler?

1084
00:49:34,147 --> 00:49:36,960
"Depends on your system,"

1085
00:49:36,960 --> 00:49:39,390
like an SA would always,
always say, right?

1086
00:49:39,390 --> 00:49:42,540
And that depends on the criticality of it.

1087
00:49:42,540 --> 00:49:45,150
How soon do you think you need to process?

1088
00:49:45,150 --> 00:49:47,400
For example, financial transactions,

1089
00:49:47,400 --> 00:49:50,340
probably cannot handle
a per-minute redrive.

1090
00:49:50,340 --> 00:49:51,750
Coffee orders can.

1091
00:49:51,750 --> 00:49:55,620
Okay, for example, I can
survive more than a minute

1092
00:49:55,620 --> 00:49:56,910
without having coffee.

1093
00:49:56,910 --> 00:50:00,120
So, what's your schedule,

1094
00:50:00,120 --> 00:50:01,170
probably would depend

1095
00:50:01,170 --> 00:50:04,440
on the criticality of
the messages in there

1096
00:50:04,440 --> 00:50:08,610
and what do you think is your
RT or recovery time objective,

1097
00:50:08,610 --> 00:50:10,353
or recovery point objective there.

1098
00:50:11,490 --> 00:50:12,840
So, what is your defined time

1099
00:50:12,840 --> 00:50:16,533
in which you have to process messages?

1100
00:50:18,300 --> 00:50:19,800
- [Tom Romano] Yeah and we
can see that behavior here.

1101
00:50:19,800 --> 00:50:21,960
Just gonna order, I'm gonna
break the system again,

1102
00:50:21,960 --> 00:50:23,260
order a couple of coffees.

1103
00:50:27,900 --> 00:50:30,000
The first coffee's gonna trip the breaker.

1104
00:50:31,380 --> 00:50:32,730
So, I'll submit that order.

1105
00:50:34,440 --> 00:50:36,140
So, right now, the circuit's open.

1106
00:50:38,910 --> 00:50:40,890
The coffee will come through,

1107
00:50:40,890 --> 00:50:42,480
it'll go through the event queue,

1108
00:50:42,480 --> 00:50:43,380
the circuit will be closed,

1109
00:50:43,380 --> 00:50:45,000
it'll try the payment service,

1110
00:50:45,000 --> 00:50:48,213
it'll trip, open the circuit
and send it to the DLQ.

1111
00:50:57,870 --> 00:51:01,470
So, if I go and I look at my
coffee and see what happened

1112
00:51:01,470 --> 00:51:03,450
and look at my order history,

1113
00:51:03,450 --> 00:51:04,953
I did get the coffee,

1114
00:51:07,860 --> 00:51:11,163
but I got it with the payment
status of circuit open,

1115
00:51:12,030 --> 00:51:14,160
until I haven't actually
processed the payment.

1116
00:51:14,160 --> 00:51:17,060
It's sitting in the dead-letter
queue partially processed.

1117
00:51:17,974 --> 00:51:19,470
(Parnab Basak coughs)

1118
00:51:19,470 --> 00:51:20,303
Okay?

1119
00:51:20,303 --> 00:51:23,370
My subsequent coffees, the
circuit breaker's already open,

1120
00:51:23,370 --> 00:51:24,783
those are gonna fail fast.

1121
00:51:25,800 --> 00:51:27,240
I'll see those coffees immediately,

1122
00:51:27,240 --> 00:51:29,253
but again, without the order processing.

1123
00:51:31,350 --> 00:51:32,943
I see my coffees immediately.

1124
00:51:34,440 --> 00:51:37,190
But the circuit's open, I'm
not processing my payments.

1125
00:51:45,030 --> 00:51:46,230
Behind the scenes,

1126
00:51:46,230 --> 00:51:48,630
when I look at what's
going on with CloudWatch,

1127
00:51:48,630 --> 00:51:51,900
I can see my system stays
very much under control.

1128
00:51:51,900 --> 00:51:56,370
I get that initial push
where it's trying and fails.

1129
00:51:56,370 --> 00:51:59,670
But look at my Lambda processing duration.

1130
00:51:59,670 --> 00:52:01,560
I get that one hit at 30 seconds

1131
00:52:01,560 --> 00:52:03,660
and subsequent hits are very fast,

1132
00:52:03,660 --> 00:52:06,723
very efficient from a Lambda perspective.

1133
00:52:14,370 --> 00:52:15,810
Now, I can do my redrive.

1134
00:52:15,810 --> 00:52:18,360
So, when the service is
up, it'll close the circuit

1135
00:52:18,360 --> 00:52:20,220
and automatically redrive my coffees,

1136
00:52:20,220 --> 00:52:22,533
therefore, reprocessing
those payment systems.

1137
00:52:28,770 --> 00:52:32,163
Remember, that I've got the
payment status of circuit open.

1138
00:52:34,950 --> 00:52:37,383
So, let's go ahead and
fix our payment system.

1139
00:52:39,150 --> 00:52:41,520
And since I have the
automatic redrive happening,

1140
00:52:41,520 --> 00:52:43,590
I don't have to press the redrive button.

1141
00:52:43,590 --> 00:52:45,570
It's automatically going to detect

1142
00:52:45,570 --> 00:52:48,100
that the payment service
is now available again

1143
00:52:49,080 --> 00:52:51,460
and automatically redrive those coffees

1144
00:52:52,680 --> 00:52:54,213
and process the payments.

1145
00:52:55,830 --> 00:52:56,670
And so, I still see

1146
00:52:56,670 --> 00:52:59,010
that the coffees haven't been
quite processed quite yet.

1147
00:52:59,010 --> 00:53:02,370
'Cause remember, that I'm
moving one message a second.

1148
00:53:02,370 --> 00:53:04,830
So, it's gonna take a few seconds.

1149
00:53:04,830 --> 00:53:06,243
But if I refresh again,

1150
00:53:08,100 --> 00:53:11,070
I'll start to see that the
coffees are indeed processed.

1151
00:53:11,070 --> 00:53:14,280
And now, they're all fully processed.

1152
00:53:14,280 --> 00:53:16,830
My system is self-recovered
and self-healed,

1153
00:53:16,830 --> 00:53:18,680
once the payment system came back up.

1154
00:53:24,600 --> 00:53:27,480
- [Parnab Basak] Okay, so, Tom,
the TLD that get from this,

1155
00:53:27,480 --> 00:53:29,310
is design your systems

1156
00:53:29,310 --> 00:53:32,730
to be self-recordable and self-healing.

1157
00:53:32,730 --> 00:53:33,960
Design your systems

1158
00:53:33,960 --> 00:53:38,960
to be resilient across multiple
different types of errors.

1159
00:53:39,300 --> 00:53:40,680
It might be a messaging error,

1160
00:53:40,680 --> 00:53:43,050
configuration or other types of errors.

1161
00:53:43,050 --> 00:53:45,870
What else do you think
we should be looking at

1162
00:53:45,870 --> 00:53:47,970
as takeaways from this session?

1163
00:53:47,970 --> 00:53:49,770
- [Tom Romano] Well, if
you design for failure,

1164
00:53:49,770 --> 00:53:50,853
then nothing fails.

1165
00:53:52,320 --> 00:53:53,490
- [Parnab Basak] Right.

1166
00:53:53,490 --> 00:53:54,570
- [Tom Romano] Because
it's just the behavior

1167
00:53:54,570 --> 00:53:55,403
of your system.

1168
00:53:55,403 --> 00:53:56,910
Your system is able to accommodate it,

1169
00:53:56,910 --> 00:53:58,440
it's able to continue working

1170
00:53:58,440 --> 00:54:00,900
and continue servicing your customers,

1171
00:54:00,900 --> 00:54:04,050
even though there might be a degradation.

1172
00:54:04,050 --> 00:54:05,460
- [Parnab Basak] So,
again, thank you everyone

1173
00:54:05,460 --> 00:54:07,740
for attending this session.

1174
00:54:07,740 --> 00:54:11,440
Again, if you didn't know,
we have the session reviews

1175
00:54:12,930 --> 00:54:15,960
that you can go to in
the mobile app, okay,

1176
00:54:15,960 --> 00:54:18,750
which is super, super useful for us.

1177
00:54:18,750 --> 00:54:20,940
Again, as you can tell,
this is a brand-new talk

1178
00:54:20,940 --> 00:54:22,920
that we ended up doing this "re:Invent".

1179
00:54:22,920 --> 00:54:24,480
It's never been done before.

1180
00:54:24,480 --> 00:54:29,460
But if you like the
session, like the content

1181
00:54:29,460 --> 00:54:32,850
and found that this was useful,

1182
00:54:32,850 --> 00:54:37,850
please give us your honest feedback.

1183
00:54:38,280 --> 00:54:42,060
That is a big, big component for us

1184
00:54:42,060 --> 00:54:46,290
to learn from your direct feedback

1185
00:54:46,290 --> 00:54:48,330
and improve this going forward.

1186
00:54:48,330 --> 00:54:53,160
And again, we look forward
to meeting more of you,

1187
00:54:53,160 --> 00:54:55,530
or using these AWS services.

1188
00:54:55,530 --> 00:54:58,530
If you didn't know an
AWS solutions architect,

1189
00:54:58,530 --> 00:55:01,470
probably, you can reach out to us

1190
00:55:01,470 --> 00:55:04,710
and we will give you our numbers, contacts

1191
00:55:04,710 --> 00:55:08,130
to help you build on
AWS messaging services.

1192
00:55:08,130 --> 00:55:11,760
But if you have to take three
things back from this session,

1193
00:55:11,760 --> 00:55:14,010
probably these are the three things.

1194
00:55:14,010 --> 00:55:16,710
Idempotent messages is something

1195
00:55:16,710 --> 00:55:18,780
that you should really, really look at,

1196
00:55:18,780 --> 00:55:20,790
so that respective of,

1197
00:55:20,790 --> 00:55:24,840
you can retry, resend, republish
those messages any number

1198
00:55:24,840 --> 00:55:26,130
of times,

1199
00:55:26,130 --> 00:55:30,600
should look at redundancy in
terms of your infrastructure,

1200
00:55:30,600 --> 00:55:33,660
not only regional availability
zone-based redundancy,

1201
00:55:33,660 --> 00:55:35,910
but message handling redundancy too,

1202
00:55:35,910 --> 00:55:40,410
like we talked about regular
queues for pushing messages,

1203
00:55:40,410 --> 00:55:44,760
another queue for pushing a
different actionable messages,

1204
00:55:44,760 --> 00:55:45,870
et cetera.

1205
00:55:45,870 --> 00:55:48,210
And look at your operational excellence.

1206
00:55:48,210 --> 00:55:50,130
How are you stimulating those

1207
00:55:50,130 --> 00:55:54,060
in your DEV, UAT, pre-PROD environments

1208
00:55:54,060 --> 00:55:57,420
to be able to not incorporate these

1209
00:55:57,420 --> 00:55:58,560
in your production environments?

1210
00:55:58,560 --> 00:56:01,950
Again, these are just four of
the architectural patterns-

1211
00:56:01,950 --> 00:56:02,783
- [Tom Romano] Mm-hmm (affirmative).

1212
00:56:02,783 --> 00:56:04,320
- [Parnab Basak] That we
had time to talk about.

1213
00:56:04,320 --> 00:56:07,740
There are a few more that we have in mind,

1214
00:56:07,740 --> 00:56:12,540
which we've seen some
usages and applications of.

1215
00:56:12,540 --> 00:56:14,700
So, given what we have as
a one-hour presentation,

1216
00:56:14,700 --> 00:56:17,700
we could only probably show two

1217
00:56:17,700 --> 00:56:20,790
and talk about five,
talk about four of these.

1218
00:56:20,790 --> 00:56:24,180
So, hopefully, this was a good session.

1219
00:56:24,180 --> 00:56:25,710
And enjoy "re:Invent",

1220
00:56:25,710 --> 00:56:30,180
just pick up all the fun, all
the quirkiness of "re:Invent".

1221
00:56:30,180 --> 00:56:32,580
Probably, I find this super useful,

1222
00:56:32,580 --> 00:56:35,760
even from me being an
AWS solutions architect.

1223
00:56:35,760 --> 00:56:36,593
Thank you, everyone.

1224
00:56:36,593 --> 00:56:37,973
- [Tom Romano] Thank you very much.

