# AWS re:Invent 2025 会议总结：为 Amazon Aurora 编写 MCP 服务器

## 会议概述

本次技术会议由 Jim 和 Vlad 主讲,主题是如何为 Amazon Aurora 数据库构建模型上下文协议(MCP)服务器。这是一场代码实战(code talk)会议,演讲者现场编写代码,展示了从零开始构建一个完整的 MCP 服务器的全过程。

会议采用了互动式的结对编程方式,Jim 使用 Cursor IDE 和 AI 辅助工具来加速开发过程。他们构建了一个娱乐中心应用,该应用使用 Streamlit 作为前端,通过 MCP 服务器连接到 Aurora PostgreSQL 数据库,并利用 Amazon Bedrock 提供 LLM 能力。整个演示围绕 IMDb 数据集展开,创建了一个标准化的关系型数据模型,包含电影、演员和角色等信息。

会议的核心理念是"预定义查询模式"(canned query pattern),即将经过优化的 SQL 查询封装成 MCP 工具,而不是让 LLM 每次都动态生成查询。这种方法可以显著降低延迟、减少 token 消耗,并提高生产环境的可预测性。Jim 特别强调了数据库安全的重要性,详细演示了如何使用 PostgreSQL 的行级安全(Row-Level Security, RLS)来保护数据,确保不同用户只能访问其被授权的数据。

## 详细时间线

### 开场介绍 (00:00 - 05:00)
- **00:00** - Jim 和 Vlad 介绍自己,说明这是一场代码实战会议
- **01:30** - 强调会议的互动性质,鼓励观众发现错误时及时指出
- **02:15** - 介绍 MCP(模型上下文协议)是一个通用框架,用于向 LLM 暴露后端数据
- **03:00** - 说明 MCP 规范只有一年历史,最新版本刚在上周发布
- **03:45** - 提到将使用 AWS 的 Aurora PostgreSQL MCP 服务器

### 技术栈和数据模型介绍 (05:00 - 10:00)
- **05:30** - 介绍将使用 Aurora PostgreSQL、Amazon Bedrock 和 Streamlit
- **06:15** - 说明将构建一个娱乐中心应用,包含两个 MCP 工具:get_movie_characters 和 get_actor_roles
- **07:00** - 展示基于 IMDb 数据集的标准化关系型数据模型
- **08:00** - 强调数据模型包含外键、索引等传统 OLTP 数据库特征
- **08:45** - 讨论数据安全的重要性,特别是向 LLM 开放数据库访问时

### 应用演示 (10:00 - 15:00)
- **10:30** - 展示基本的 Streamlit 应用界面,包含登录页面和电影列表
- **11:00** - 演示已配置的时间 MCP 服务器,询问"现在几点?"
- **11:45** - 展示数据库表结构,重点介绍 titles 表
- **12:30** - 强调在 PostgreSQL 中使用 COMMENT 命令为表和列添加描述的重要性
- **13:15** - 说明这些描述可以帮助 LLM 理解数据结构和使用方法
- **14:00** - 展示全文搜索向量(tsvector)列的描述示例

### 使用 Cursor 开始编码 (15:00 - 25:00)
- **15:30** - 开始使用 Cursor IDE,展示已配置的 PostgreSQL 和天气 MCP 服务器
- **16:00** - 测试天气 MCP 服务器,查询拉斯维加斯的天气
- **16:45** - 询问可以查询哪些表,Cursor 通过 MCP 服务器查询 information_schema
- **17:30** - 开始编写第一个查询:返回给定电影的所有角色和演员
- **18:15** - Cursor 请求权限获取表结构定义
- **19:00** - 观众提问:Cursor 是否真的在调用 MCP 服务器?Jim 确认是的
- **20:00** - 解释 Cursor 使用预配置的 Aurora PostgreSQL MCP 服务器连接到开发数据库

### 查询优化过程 (25:00 - 35:00)
- **25:30** - Cursor 生成了一个四表连接查询,使用全文搜索
- **26:00** - 测试查询,注意到有一定延迟
- **27:00** - 讨论《教父》系列会返回多个结果的问题
- **28:00** - 要求修改查询,只返回最受欢迎的标题
- **29:00** - Cursor 添加了 ratings 表作为子查询
- **30:00** - Jim 不满意全文搜索被使用两次,要求只使用一次
- **31:00** - Cursor 将查询重构为使用 CTE(公共表表达式)
- **32:00** - 将查询保存到文件 query1.sql 以保留上下文

### 编写第二个查询 (35:00 - 40:00)
- **35:30** - 开始编写第二个查询:返回给定演员的所有角色和电影标题
- **36:00** - 由于已有上下文,Cursor 生成查询更快
- **37:00** - 测试查询确保正常工作
- **38:00** - 观众提问 MCP 服务器的托管位置,Jim 说明是本地子目录
- **39:00** - 讨论 MCP 服务器本身不调用 LLM,是 Cursor 在调用

### 创建 MCP 服务器 (40:00 - 50:00)
- **40:30** - 开始编写创建 MCP 服务器的提示词
- **41:00** - 指定要创建两个工具,使用天气 MCP 服务器作为模板
- **42:00** - 要求使用 psycopg3 连接数据库,从 .env 文件加载配置
- **43:00** - Cursor 开始生成 Python 代码,创建 movie_server
- **44:00** - 检查生成的代码,包含数据库连接和两个查询
- **45:00** - 要求修改 get_db_connection 函数,使用独立的用户名和密码参数
- **46:00** - 保存 MCP 服务器代码
- **47:00** - 复制 .env 配置文件

### 测试和调试 MCP 服务器 (50:00 - 60:00)
- **50:30** - 尝试测试 MCP 服务器,Jim 预期会有错误
- **51:00** - 讨论非确定性行为对数据库人员的挑战
- **52:00** - 测试查询《星球大战》的角色
- **53:00** - Vlad 解释 LLM 可能直接从训练数据回答,而不调用工具
- **54:00** - 讨论非确定性:LLM 自行决定是否使用工具
- **55:00** - 需要配置用户应用以使用新的 MCP 服务器
- **56:00** - 返回 Cursor 修改配置
- **57:00** - 添加 movie MCP 服务器到配置中

### 创建自定义数据测试 (60:00 - 70:00)
- **60:30** - 重新启动应用测试
- **61:00** - 成功找到并调用 get_movie_characters 工具
- **62:00** - 讨论需要测试不在互联网上的数据
- **63:00** - 展示管理界面,可以添加新电影和演员
- **64:00** - 创建新电影"429 Coding an MCP Server"
- **65:00** - 添加 Jim 和 Vlad 作为演员
- **66:00** - 为演员分配角色:"Jimbo"和"Mr. Vlad"
- **67:00** - 测试查询新创建的电影
- **68:00** - 成功从数据库检索到自定义数据,证明不依赖训练数据

### 实现行级安全 (70:00 - 85:00)
- **70:30** - 开始讨论如何保护数据库安全
- **71:00** - 展示 titles 表有 1100 万条记录
- **72:00** - 说明需要根据 title_type 限制不同用户的访问
- **73:00** - Jim 只能看 type 1(电影),Vlad 可以看所有,test2 可以看 type 1 和 5
- **74:00** - 展示使用 WHERE 子句的基本过滤查询
- **75:00** - 强调不能信任 LLM 添加正确的 WHERE 子句
- **76:00** - 介绍使用 PostgreSQL 行级安全(RLS)的方案
- **77:00** - 使用 set_config 函数设置环境变量
- **78:00** - 演示使用 current_setting 函数读取配置
- **79:00** - 创建 RLS 策略,使用环境变量作为过滤条件
- **80:00** - 在 titles 表上启用行级安全
- **81:00** - 切换到 MCP 用户测试(表所有者不受 RLS 限制)
- **82:00** - 未设置配置时查询返回空结果,验证默认拒绝策略
- **83:00** - 设置配置后成功返回过滤后的数据
- **84:00** - 解释 RLS 自动添加 WHERE 子句,确保数据安全

### 集成 RLS 到 MCP 服务器 (85:00 - 95:00)
- **85:30** - 返回 Cursor 修改 movie_server
- **86:00** - 要求添加命令行参数接收 title_types
- **87:00** - 指定使用特定库处理参数
- **88:00** - 要求在数据库连接后调用 set_config
- **89:00** - 提供 SQL 模板作为参考
- **90:00** - Cursor 添加导入和参数解析
- **91:00** - 在连接后添加 set_config 调用
- **92:00** - 修改用户登录逻辑,从 users 表加载 title_types
- **93:00** - 遇到 PostgreSQL 数组类型问题
- **94:00** - 要求将 title_types 转换为文本类型以便传递

### 处理变量作用域问题 (95:00 - 结束)
- **95:30** - 发现 title_types 在不同内存上下文中不可访问
- **96:00** - 要求将 title_types 作为局部变量传递给函数
- **97:00** - Jim 承认这是新尝试的提示词
- **98:00** - Cursor 成功重构代码,将变量正确传递
- **99:00** - 准备测试完整的安全实现
- **100:00** - 会议接近尾声,代码基本完成

### 关键技术讨论点
- **预定义查询模式 vs 动态查询**:Vlad 详细解释了为什么在生产环境中使用预定义查询更好(降低延迟、减少成本、提高可预测性)
- **MCP 服务器架构**:MCP 服务器本地运行,通过标准 I/O 与客户端通信,不直接调用 LLM
- **安全最佳实践**:使用数据库原生的行级安全功能,而不是依赖应用层或 LLM 的过滤
- **AI 辅助开发**:展示了如何像与同事结对编程一样与 AI 工具交互,逐步构建解决方案