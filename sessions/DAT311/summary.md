# AWS re:Invent 2025 DynamoDB 数据建模会议总结

## 会议概述

本次会议由 AWS 首席解决方案架构师 Jason Hunter 主讲,专注于 DynamoDB 的数据建模技术。这是一场 300 级别的技术会议,面向对 DynamoDB 有一定了解但希望深入学习的开发者。

Jason 首先通过"图书馆中的电话簿"这一生动类比来解释 DynamoDB 的核心概念。他将分区键比作城市名称,排序键比作姓名排序,帮助听众理解 DynamoDB 的索引机制。基础表类似白页电话簿,本地二级索引(LSI)类似黄页,而全局二级索引(GSI)则像是按邮编组织的独立电话簿。这种类比清晰地展示了 DynamoDB 如何通过哈希分区键来均匀分布数据,以及如何通过分区分裂来实现扩展。

会议的核心部分聚焦于实际应用场景——设计一个聊天机器人历史记录系统。Jason 详细演示了如何根据访问模式设计表结构,包括使用用户 ID 作为分区键,时间戳作为排序键,以及如何通过稀疏 GSI 优化元数据查询。他还深入讨论了成本优化策略,如数据压缩、属性合并等技术,以及如何通过分片技术突破单分区的吞吐量限制,实现大规模应用的性能需求。

## 详细时间线

### 开场与基础概念 (00:00 - 15:00)

00:00 - 会议开始
- Jason Hunter 自我介绍,担任 DynamoDB 专业解决方案架构师
- 说明这是 300 级别会议,假设听众对 DynamoDB 有基本了解

02:30 - 电话簿类比引入
- 开始使用"图书馆中的电话簿"类比解释 DynamoDB
- 分区键(PK)类似城市名称,排序键(SK)类似姓名排序
- 基础表就像按城市组织的电话簿

05:00 - 索引类型说明
- 本地二级索引(LSI):同一城市但不同排序方式,如黄页按业务类型排序
- 全局二级索引(GSI):不同的分区键,如按邮编组织的电话簿
- LSI 强一致性,GSI 最终一致性

08:00 - 数据更新机制
- 更新基础表,索引自动传播
- LSI 强一致性更新,GSI 最终一致性(通常毫秒级)

10:00 - 高可用架构
- DynamoDB 在三个可用区保存三份数据副本
- 自动选举 leader 节点处理更新
- 强一致性读取访问 leader,最终一致性读取可访问任意副本(成本减半)

### 分区机制深入 (15:00 - 30:00)

15:00 - 分区工作原理
- 默认按需表创建 4 个分区
- 使用哈希而非字母顺序分配数据,确保均匀分布
- 避免数据倾斜问题

18:00 - 分区分裂机制
- 当分区达到约 10GB 时自动分裂
- 按哈希范围中点分裂
- 热点分区也会触发分裂以提高吞吐量

22:00 - 项目集合分裂
- 可以按排序键分裂大型项目集合
- 类似纽约电话簿分成多卷
- 注意:有 LSI 的表无法分裂项目集合,限制为 10GB

25:00 - 分区性能限制
- 每个分区硬限制:3000 读取容量单位,1000 写入容量单位
- 热点数据会触发"热分裂"
- 单个项目最高可支持 1000 次/秒写入,6000 次/秒最终一致性读取

28:00 - 预配置吞吐量
- 介绍 Warm Throughput 功能
- 可在创建时提示表规模,避免初始流量过载
- 通过 CloudFormation 配置大规模启动

### 实战数据建模 (30:00 - 50:00)

30:00 - 键设计最佳实践
- 推荐使用字符串类型的 PK 和 SK
- 使用描述性前缀,如 "CUST#123"
- 通用命名:PK 和 SK,提供最大灵活性

33:00 - 分区键模式
- 描述性键:zip#89109
- 分片键:添加后缀 #0、#1 等支持高吞吐量
- 多值键:组合多个属性

35:00 - 新功能发布
- 宣布 GSI 支持多属性分区键和排序键(约一周前发布)
- 无需在基础表中手动连接属性
- 减少存储和写入成本

38:00 - 排序键模式
- 类型前缀:name#hunter
- 时间戳:用于时序数据
- 层级结构:country#state#city,支持前缀查询

40:00 - 聊天机器人案例引入
- 需求:存储数百万用户的对话历史
- 访问模式:按用户查询所有线程、查询特定线程、查询最近线程

43:00 - 基础表设计
- PK:用户 ID
- SK:时间戳 + 线程 ID
- 元数据项使用特殊 SK 值 "meta"
- 单表设计:不同实体类型共存

47:00 - NoSQL Workbench 演示
- 展示可视化工具中的数据结构
- 同一分区键下混合元数据和消息项
- 不同项可有不同属性(无模式灵活性)

### 高级优化技术 (50:00 - 70:00)

50:00 - 新需求:仅查询元数据
- 问题:当前模型需要扫描所有消息
- 解决方案:创建稀疏 GSI

52:00 - 稀疏 GSI 实现
- 仅在元数据项上设置 GSI 排序键属性
- 只有元数据项进入 GSI
- 成本优化:更少存储和写入

55:00 - 一致性权衡
- GSI 最终一致性(通常 1-10 毫秒)
- 选项:接受最终一致性、使用 LSI、双写、事务写入
- 事务成本是普通写入的两倍

58:00 - 成本优化策略
- 压缩大文本字段(gzip 或 LZ4)
- LZ4 在测试中表现更优
- 权衡:节省空间 vs 无法在数据库中过滤

62:00 - 属性优化
- 将多个小属性合并为 JSON map 并压缩
- 使用字符串而非多个属性减少序列化开销
- 仅在需要索引或过滤时才保持属性独立

65:00 - 更新成本说明
- 更新成本与项目大小成正比
- 删除成本也基于项目大小
- 建议:保持项目精简以降低操作成本

### 大规模扩展技术 (70:00 - 结束)

70:00 - 分片策略
- 单分区限制:1000 写入单位/秒
- 通过在分区键添加后缀实现分片
- 示例:user#123#0, user#123#1, user#123#2

73:00 - 写入分片实现
- 随机或轮询选择分片后缀
- 可突破单分区吞吐量限制
- 需要应用层逻辑管理分片

75:00 - 读取聚合
- 需要从所有分片读取并合并结果
- 可使用并行查询提高性能
- 在应用层进行排序和分页

78:00 - 分片数量选择
- 根据预期吞吐量计算
- 考虑未来增长空间
- 平衡复杂性和性能需求

80:00 - 总结与问答
- 回顾关键概念:分区机制、索引策略、成本优化
- 强调根据访问模式设计的重要性
- 开放问答环节