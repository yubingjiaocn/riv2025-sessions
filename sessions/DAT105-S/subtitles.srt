1
00:00:01,298 --> 00:00:02,640
All right, how's everybody doing?

2
00:00:03,559 --> 00:00:05,679
Great, give me a sign. I'm not as cool

3
00:00:05,679 --> 00:00:07,948
as the robot next next to us, but

4
00:00:08,000 --> 00:00:09,460
we'll try to do our best to like

5
00:00:09,880 --> 00:00:12,179
go through this, all right? um,

6
00:00:12,679 --> 00:00:14,000
everybody doing good?

7
00:00:14,989 --> 00:00:17,190
Great. All right, so my name is David

8
00:00:17,190 --> 00:00:19,469
Joy. I'm a senior manager at Cockroach

9
00:00:19,469 --> 00:00:20,539
Labs, um,

10
00:00:20,870 --> 00:00:22,908
and, uh, you know, I work with AWS. Been

11
00:00:22,908 --> 00:00:24,908
working with AWS as partners for about

12
00:00:24,908 --> 00:00:25,978
3.5, 4 years.

13
00:00:26,269 --> 00:00:28,469
Uh, so here we're gonna talk about, you know, building

14
00:00:28,469 --> 00:00:29,129
resilient

15
00:00:29,589 --> 00:00:31,949
G AI and agentic applications with intelligent

16
00:00:31,949 --> 00:00:33,950
memory. That's the name of our talk, uh, with

17
00:00:33,950 --> 00:00:35,609
me. I have, uh, Vira to party.

18
00:00:36,079 --> 00:00:38,270
Uh, Vira had way too much fun yesterday and lost

19
00:00:38,270 --> 00:00:38,950
his voice,

20
00:00:39,348 --> 00:00:40,668
so I'm gonna do a lot.

21
00:00:41,109 --> 00:00:42,408
Anyone here who had a lot of fun?

22
00:00:42,978 --> 00:00:45,090
Oh. Anyone gamble won some

23
00:00:45,090 --> 00:00:47,209
money? OK, good, good job. Yeah,

24
00:00:47,368 --> 00:00:49,569
so, so he's so lost of voice, but

25
00:00:49,569 --> 00:00:51,689
you know we're gonna work together, figure it out, and demo

26
00:00:51,689 --> 00:00:52,319
it out. So,

27
00:00:52,649 --> 00:00:54,929
so one of the things we wanted to do today was, you know.

28
00:00:55,529 --> 00:00:57,889
Talk about what we are actually seeing

29
00:00:57,889 --> 00:00:59,929
in our conversations with enterprises that we

30
00:00:59,929 --> 00:01:01,969
work with. So we're going to cover trends and challenges that

31
00:01:01,969 --> 00:01:04,269
we're hearing. We're going to talk about scaling and

32
00:01:04,528 --> 00:01:06,528
being resilient with Cockroach DB, and we're

33
00:01:06,528 --> 00:01:08,409
going to talk about Gen AI with Cockroach DB,

34
00:01:08,689 --> 00:01:10,730
agentic and memory with cockroach, like a bunch

35
00:01:10,730 --> 00:01:11,510
of topics.

36
00:01:12,129 --> 00:01:14,168
How many here are like just for me to

37
00:01:14,168 --> 00:01:16,168
understand the crowd here and the audience,

38
00:01:16,250 --> 00:01:18,409
how many of you are familiar with CockroachB? Can you just

39
00:01:18,409 --> 00:01:19,430
raise your hands?

40
00:01:20,079 --> 00:01:22,430
Not too much. OK. How many of you are, uh,

41
00:01:22,439 --> 00:01:24,638
database people like, like databases,

42
00:01:24,719 --> 00:01:25,870
use databases?

43
00:01:26,480 --> 00:01:28,558
OK, application developers,

44
00:01:28,719 --> 00:01:29,659
architects.

45
00:01:30,558 --> 00:01:32,680
Got it. Our cloud architects. OK, so we got a

46
00:01:32,680 --> 00:01:34,680
mix of, OK, great. How many

47
00:01:34,680 --> 00:01:36,760
of you are wanting to like learn something from here to

48
00:01:36,760 --> 00:01:38,918
go invest some money in like

49
00:01:38,918 --> 00:01:40,099
some good stocks?

50
00:01:40,879 --> 00:01:43,319
Uh, this is not sacrifice, but what I've seen

51
00:01:43,319 --> 00:01:44,650
sometimes after my sessions is

52
00:01:44,930 --> 00:01:47,010
people kind of think, oh, this kind of helps me

53
00:01:47,010 --> 00:01:49,010
understand where the G AI market is in

54
00:01:49,010 --> 00:01:51,058
a very realistic way. So I hope

55
00:01:51,290 --> 00:01:53,359
it kind of gives you some perspective on that as well,

56
00:01:53,609 --> 00:01:55,888
right? So what I wanted to do really

57
00:01:55,888 --> 00:01:57,969
was in this session give you an

58
00:01:57,969 --> 00:02:00,019
opportunity. To take something back, so there are

59
00:02:00,019 --> 00:02:02,180
a lot of different ideas that we have experienced

60
00:02:02,180 --> 00:02:04,219
as a company, as a team, that we are going to

61
00:02:04,219 --> 00:02:06,329
break it down for you, that you will get to learn and

62
00:02:06,329 --> 00:02:08,460
apply. And so we're going to cover a bunch of different

63
00:02:08,460 --> 00:02:10,460
things. So there will be a lot of intros and a lot of

64
00:02:10,460 --> 00:02:12,460
detail as well, and I'm going to pause at

65
00:02:12,460 --> 00:02:13,399
different slides

66
00:02:13,659 --> 00:02:15,899
where you can take screenshots if you want, and

67
00:02:15,899 --> 00:02:17,979
we'll also provide the deck later, but these are

68
00:02:17,979 --> 00:02:20,258
things that you can actually apply in any

69
00:02:20,258 --> 00:02:22,379
project that you are kind of working on, personal

70
00:02:22,379 --> 00:02:24,500
or you know at the company or any new project

71
00:02:24,500 --> 00:02:25,719
or POC that you're going to do.

72
00:02:26,278 --> 00:02:27,379
All right, so with that,

73
00:02:27,710 --> 00:02:28,758
let's just kick it off.

74
00:02:29,528 --> 00:02:31,778
You know, Gen AI has changed user

75
00:02:31,778 --> 00:02:32,770
behavior. Do we agree?

76
00:02:33,659 --> 00:02:34,889
How many of us agree? Let's,

77
00:02:35,219 --> 00:02:37,258
let's have some interaction, right? Everyone

78
00:02:37,258 --> 00:02:39,038
agrees. We were used to

79
00:02:39,330 --> 00:02:40,219
the left side,

80
00:02:40,538 --> 00:02:42,939
you know, we would go and ask for a particular set of

81
00:02:42,939 --> 00:02:45,258
information. That information would come down as

82
00:02:45,258 --> 00:02:46,360
blue check links,

83
00:02:46,699 --> 00:02:49,020
and you know, we would use those links to go to

84
00:02:49,020 --> 00:02:50,580
find the information that we wanted,

85
00:02:50,860 --> 00:02:52,960
so the information would come, come out.

86
00:02:53,319 --> 00:02:55,830
And then we would basically try to infer the

87
00:02:55,830 --> 00:02:57,588
information, but that behavior has changed today.

88
00:02:58,069 --> 00:03:00,860
Today we have answer engines, we have co-pilots,

89
00:03:00,909 --> 00:03:03,110
we have assistive agents, we have autonomous

90
00:03:03,110 --> 00:03:05,210
agents and more that we are building,

91
00:03:05,569 --> 00:03:07,710
right? And what we are trying to do is

92
00:03:07,710 --> 00:03:09,830
go from being a search engine to an answer

93
00:03:09,830 --> 00:03:12,110
engine where we ask a question and we get

94
00:03:12,110 --> 00:03:14,229
exactly the kind of information we want. And

95
00:03:14,229 --> 00:03:16,288
these systems they look familiar

96
00:03:16,288 --> 00:03:18,304
and Work in the same platforms and

97
00:03:18,304 --> 00:03:20,213
maybe on the same environments on the cloud,

98
00:03:20,493 --> 00:03:22,854
they actually behave differently or have a different

99
00:03:22,854 --> 00:03:25,133
requirement to be able to work and obviously

100
00:03:25,133 --> 00:03:27,395
large language models is something that we have gotten familiar

101
00:03:27,395 --> 00:03:29,413
with over the last 2 or 3 years, especially with

102
00:03:29,413 --> 00:03:30,754
Chad GPT 3.5,

103
00:03:31,054 --> 00:03:33,213
but one of the biggest things that has changed is

104
00:03:33,213 --> 00:03:35,213
that it's become more than just a large language

105
00:03:35,213 --> 00:03:37,235
model. It's an ecosystem that works together

106
00:03:37,235 --> 00:03:39,493
with data to make sure that it all comes

107
00:03:39,493 --> 00:03:41,588
together. So when we talk to enterprises

108
00:03:41,588 --> 00:03:43,300
as a company, as Cockroach Labs,

109
00:03:43,819 --> 00:03:46,179
these are some of the things that we have been hearing, right? And

110
00:03:46,179 --> 00:03:47,599
these are stats that you could kind of

111
00:03:47,860 --> 00:03:49,399
go in and look at yourself.

112
00:03:50,179 --> 00:03:52,379
Most of the companies today, about 70%

113
00:03:52,379 --> 00:03:53,240
of the companies

114
00:03:53,580 --> 00:03:56,000
are basically running legacy infrastructure,

115
00:03:56,508 --> 00:03:58,580
and because of that, about 50% of the

116
00:03:58,580 --> 00:04:00,778
initiatives are actually not Gen AI

117
00:04:00,778 --> 00:04:01,319
ready

118
00:04:01,699 --> 00:04:04,179
or are struggling because they need to make this infrastructure

119
00:04:04,179 --> 00:04:04,979
ready for Gen AI.

120
00:04:05,460 --> 00:04:07,750
We're also seeing, and this came out in the news as well, about

121
00:04:07,750 --> 00:04:09,969
95% of the projects

122
00:04:10,189 --> 00:04:12,389
are actually stuck in POCs and not getting into

123
00:04:12,389 --> 00:04:14,429
production, and there are multiple reasons for that.

124
00:04:14,500 --> 00:04:16,750
Obviously there can be infrastructure. There's also

125
00:04:16,750 --> 00:04:18,869
this whole uncertainty

126
00:04:18,869 --> 00:04:20,730
around basically the cost of

127
00:04:21,019 --> 00:04:23,040
running these services and

128
00:04:23,040 --> 00:04:24,209
then the ROI on it.

129
00:04:25,040 --> 00:04:27,139
Like my friend here, like what banking app do you

130
00:04:27,139 --> 00:04:29,170
use? Like just like Chase.

131
00:04:29,428 --> 00:04:31,500
Just because Chase added an assistant,

132
00:04:31,709 --> 00:04:33,309
would you pay Chase extra money?

133
00:04:34,608 --> 00:04:35,410
Maybe not, right?

134
00:04:35,699 --> 00:04:37,759
So like you're adding these features. Companies are

135
00:04:37,759 --> 00:04:39,769
adding these features, but they're like they're not

136
00:04:39,769 --> 00:04:42,129
sure what the ROI on that is. It's a feature that

137
00:04:42,129 --> 00:04:42,959
is getting added.

138
00:04:43,290 --> 00:04:44,209
And on top of that,

139
00:04:44,608 --> 00:04:46,709
you don't have to build these use cases

140
00:04:47,129 --> 00:04:49,319
just for 1000 people or 10,000

141
00:04:49,319 --> 00:04:51,608
people. You have to build on top of your

142
00:04:51,608 --> 00:04:53,730
existing client base, and these are, these

143
00:04:53,730 --> 00:04:55,000
are millions of users,

144
00:04:55,329 --> 00:04:57,809
so you cannot build something that cannot scale.

145
00:04:58,250 --> 00:05:00,329
And that's the paradigm, and

146
00:05:00,329 --> 00:05:02,528
you cannot build something with Gen AI that

147
00:05:02,528 --> 00:05:04,410
keeps going down. Say a region goes down,

148
00:05:04,879 --> 00:05:06,970
your app goes unavailable. We cannot build these

149
00:05:06,970 --> 00:05:09,088
kinds of experiences. So enterprises today have

150
00:05:09,088 --> 00:05:11,588
to build on top of the current expectations

151
00:05:11,588 --> 00:05:12,290
of the market.

152
00:05:12,548 --> 00:05:13,548
And on top of that,

153
00:05:13,910 --> 00:05:16,069
they have really high requirements to make

154
00:05:16,069 --> 00:05:18,108
sure the kind of responses they provide as a

155
00:05:18,108 --> 00:05:18,949
result of their

156
00:05:19,750 --> 00:05:21,689
use case to provide the right information.

157
00:05:21,988 --> 00:05:24,798
So we've been hearing this term called model hallucinations,

158
00:05:25,028 --> 00:05:27,470
right? Everyone familiar with model hallucinations?

159
00:05:27,689 --> 00:05:29,730
Yes. So we don't want model hallucinations. So

160
00:05:29,730 --> 00:05:31,910
we want to build accurate systems that produce

161
00:05:31,910 --> 00:05:33,629
great data, correct data,

162
00:05:33,988 --> 00:05:34,869
close this information.

163
00:05:35,699 --> 00:05:37,699
So in short, what

164
00:05:37,699 --> 00:05:40,259
we are coming to realize is it's not just

165
00:05:40,259 --> 00:05:42,259
about the large language model, it's about how it gets

166
00:05:42,259 --> 00:05:42,889
applied,

167
00:05:43,178 --> 00:05:44,600
right? So to build scalable,

168
00:05:45,048 --> 00:05:47,379
accurate G AI systems, you need

169
00:05:47,379 --> 00:05:48,290
access to knowledge,

170
00:05:48,699 --> 00:05:50,798
not just the knowledge that the large language model

171
00:05:50,798 --> 00:05:52,850
has. It has to become contextual, right,

172
00:05:53,178 --> 00:05:55,319
because that data is probably going to power

173
00:05:55,579 --> 00:05:57,678
the accuracy. So you need factual data

174
00:05:57,858 --> 00:05:59,519
with this available real time

175
00:05:59,899 --> 00:06:01,980
at the same time. You also want to make

176
00:06:01,980 --> 00:06:04,019
sure you can make decisions and take

177
00:06:04,019 --> 00:06:05,410
actions on top of this data,

178
00:06:05,928 --> 00:06:07,970
so they need to be making these

179
00:06:07,970 --> 00:06:10,100
decisions autonomously. Maybe they need to have

180
00:06:10,100 --> 00:06:12,420
access to different sets of tools. So that's going

181
00:06:12,420 --> 00:06:14,420
beyond just a large language model that is allowing

182
00:06:14,420 --> 00:06:15,600
these models

183
00:06:16,019 --> 00:06:18,139
or these systems to have access to

184
00:06:18,149 --> 00:06:18,939
tools, right?

185
00:06:19,338 --> 00:06:21,500
And then we also want to make sure that

186
00:06:21,500 --> 00:06:22,139
we are learning.

187
00:06:23,119 --> 00:06:24,660
Right, so you see something happen,

188
00:06:25,000 --> 00:06:27,000
a user did something, your user took

189
00:06:27,000 --> 00:06:29,170
a particular path in this conversation.

190
00:06:29,439 --> 00:06:31,439
You want to learn over time and then you

191
00:06:31,439 --> 00:06:33,480
want to basically build on top of the

192
00:06:33,480 --> 00:06:35,759
user's preferences, user's context, and

193
00:06:35,759 --> 00:06:36,939
then use all of that

194
00:06:37,319 --> 00:06:39,399
to provide him the next response. So it's

195
00:06:39,399 --> 00:06:41,689
building on top of that and that's what

196
00:06:41,920 --> 00:06:43,048
we are seeing actually.

197
00:06:43,639 --> 00:06:45,100
So these three things

198
00:06:45,869 --> 00:06:47,879
sometimes get confusing and that's why I broke it down

199
00:06:47,879 --> 00:06:49,660
for everyone. This essentially

200
00:06:50,119 --> 00:06:50,928
needs to be.

201
00:06:51,449 --> 00:06:53,350
And what we see is these three things.

202
00:06:54,129 --> 00:06:56,170
I'm sure everybody has seen these terms somehow,

203
00:06:56,488 --> 00:06:58,608
but I wanted to break it down as what these

204
00:06:58,608 --> 00:07:00,649
use cases are. So these are 3 different use

205
00:07:00,649 --> 00:07:02,730
cases where large language models and

206
00:07:02,730 --> 00:07:05,000
data are coming together. So the first one,

207
00:07:05,209 --> 00:07:07,290
where you access knowledge is basically rag,

208
00:07:07,410 --> 00:07:09,649
right? We have been hearing about that for the last

209
00:07:09,649 --> 00:07:10,670
2 or 3 years now.

210
00:07:10,928 --> 00:07:12,290
And then we are talking about agentic.

211
00:07:12,559 --> 00:07:14,720
Now agentic is where we take actions with tools,

212
00:07:14,959 --> 00:07:17,149
and then memory is where you learn

213
00:07:17,369 --> 00:07:18,869
and use all of this together,

214
00:07:19,209 --> 00:07:21,358
right? All good. We're all together.

215
00:07:21,509 --> 00:07:22,838
We're we're good. OK, great.

216
00:07:23,238 --> 00:07:25,309
Now is the most important thing. You

217
00:07:25,309 --> 00:07:27,139
can actually build great POCs.

218
00:07:27,399 --> 00:07:28,660
You have great tools. You have

219
00:07:28,920 --> 00:07:29,678
lots of, you know,

220
00:07:29,959 --> 00:07:32,119
assistive code to build lots of POCs

221
00:07:32,119 --> 00:07:33,750
together, but it's not about that.

222
00:07:34,040 --> 00:07:36,199
You can always have a fun project, but it's about

223
00:07:36,199 --> 00:07:37,509
how to take it into production,

224
00:07:37,798 --> 00:07:40,069
make it available for hundreds of millions of users,

225
00:07:40,358 --> 00:07:42,480
right? So it's becoming very important to start

226
00:07:42,480 --> 00:07:43,338
thinking about

227
00:07:43,678 --> 00:07:45,678
how to build these experiences into

228
00:07:45,678 --> 00:07:46,199
your, you know,

229
00:07:46,480 --> 00:07:48,600
into these systems that are scalable.

230
00:07:49,199 --> 00:07:50,019
Resilient,

231
00:07:50,509 --> 00:07:51,278
consistent,

232
00:07:51,678 --> 00:07:53,399
cost optimized for millions of users.

233
00:07:53,678 --> 00:07:54,588
Do we agree with that?

234
00:07:54,959 --> 00:07:56,079
Like that's what we want to build,

235
00:07:56,399 --> 00:07:58,399
and so that's what we wanted to talk about. And

236
00:07:58,399 --> 00:08:00,519
so at Cockroach we're thinking about this because

237
00:08:00,519 --> 00:08:02,920
for us we solve the problems of millions,

238
00:08:03,079 --> 00:08:05,119
right? We build systems that don't go down.

239
00:08:05,480 --> 00:08:07,639
So because you're not familiar with maybe Cockroach

240
00:08:07,639 --> 00:08:09,939
a little bit, we'll give you a quick intro to that and

241
00:08:09,939 --> 00:08:11,920
then we'll go into the G AI piece of it,

242
00:08:12,278 --> 00:08:13,199
right? So

243
00:08:13,600 --> 00:08:14,358
as you can see.

244
00:08:15,088 --> 00:08:17,149
To build these, these are the components, right?

245
00:08:17,290 --> 00:08:19,519
So you need some sort of an orchestration

246
00:08:19,519 --> 00:08:20,059
system,

247
00:08:20,369 --> 00:08:22,399
then you need large language model, you need tools,

248
00:08:22,449 --> 00:08:23,869
and then you need contextual data,

249
00:08:24,329 --> 00:08:26,410
right? So, so we'll, we'll, we'll show all

250
00:08:26,410 --> 00:08:28,410
of these things. We'll actually show you an

251
00:08:28,410 --> 00:08:29,309
actual demo,

252
00:08:29,730 --> 00:08:31,809
uh, with the demo gods being with us. We'll

253
00:08:31,809 --> 00:08:33,928
see how it works together on each of

254
00:08:33,928 --> 00:08:36,009
these components, and you can actually take screenshots

255
00:08:36,009 --> 00:08:38,009
and learn from it and apply that on all these

256
00:08:38,009 --> 00:08:39,090
different projects that you'll do.

257
00:08:39,489 --> 00:08:41,428
So where does cockroach fit in, right?

258
00:08:41,928 --> 00:08:43,428
We're basically a database company,

259
00:08:43,889 --> 00:08:44,450
right? And.

260
00:08:45,229 --> 00:08:47,509
Unlike traditional databases, a traditional

261
00:08:47,509 --> 00:08:49,570
database is basically a single instance

262
00:08:49,570 --> 00:08:51,349
or a compute engine compute system

263
00:08:51,668 --> 00:08:53,788
where you have a bunch of users who can come access it,

264
00:08:53,908 --> 00:08:55,989
right? So you can run SQL queries, you

265
00:08:55,989 --> 00:08:58,428
can get access to this data. I make a joke that

266
00:08:58,779 --> 00:09:01,190
a database is like a closet, right?

267
00:09:01,469 --> 00:09:03,590
You put your clothes in, you go take it out, you

268
00:09:03,590 --> 00:09:04,399
put them back in.

269
00:09:05,109 --> 00:09:07,210
You take data in and out. That's what basically

270
00:09:07,210 --> 00:09:09,308
the responsibility of a database is. It stores your

271
00:09:09,308 --> 00:09:11,440
data. However, traditional databases can

272
00:09:11,440 --> 00:09:13,210
basically just work in a single instance,

273
00:09:13,489 --> 00:09:15,570
and in today's paradigm with a lot of things that

274
00:09:15,570 --> 00:09:17,798
people are doing with respect to scale and resilience,

275
00:09:18,090 --> 00:09:20,330
it cannot work the way we want it to.

276
00:09:20,649 --> 00:09:22,739
So what we do today is basically

277
00:09:22,739 --> 00:09:24,808
we allow folks to use Cockroach DB,

278
00:09:25,000 --> 00:09:27,009
which is basically not a single instance,

279
00:09:27,210 --> 00:09:29,379
it's a bunch of different instances working together.

280
00:09:29,700 --> 00:09:31,700
And what is a bunch of different instances

281
00:09:31,700 --> 00:09:33,979
coming together is basically a distributed

282
00:09:33,979 --> 00:09:36,219
system that works together as a single

283
00:09:36,219 --> 00:09:38,779
logical database. So Cockroach actually

284
00:09:38,779 --> 00:09:41,099
is a SQL database that is distributed.

285
00:09:41,639 --> 00:09:43,830
And now it also has vector capabilities,

286
00:09:44,119 --> 00:09:46,250
so we're going to go into the vector piece in a bit, but

287
00:09:46,250 --> 00:09:48,529
let me just walk you through just what makes

288
00:09:48,529 --> 00:09:50,690
a cockroach different just as a database, because

289
00:09:50,690 --> 00:09:52,769
there are so many use cases that cockroach

290
00:09:52,769 --> 00:09:54,830
is actually used for that doesn't

291
00:09:54,830 --> 00:09:57,009
entail maybe vector, but this will give you the

292
00:09:57,009 --> 00:09:59,048
basis of what makes cockroach great

293
00:09:59,048 --> 00:09:59,950
for vector as well.

294
00:10:00,798 --> 00:10:01,558
So as you can see,

295
00:10:01,879 --> 00:10:04,080
instead of running as a single instance, cockroach actually

296
00:10:04,080 --> 00:10:06,330
can work as a distributed system. So as

297
00:10:06,330 --> 00:10:08,450
more and more users come, you can actually continue

298
00:10:08,450 --> 00:10:10,808
to keep adding nodes to your cluster.

299
00:10:10,889 --> 00:10:13,259
So it will work together as a single logical cluster,

300
00:10:13,489 --> 00:10:15,489
and the biggest difference is it's a

301
00:10:15,489 --> 00:10:16,450
SQL database.

302
00:10:16,769 --> 00:10:18,849
Anything that you can do with a relational database, you

303
00:10:18,849 --> 00:10:19,928
can do that with cockroach,

304
00:10:20,200 --> 00:10:22,408
and you can do it at horizontal scale. So

305
00:10:22,408 --> 00:10:24,450
you say you go from 10,000 transactions per

306
00:10:24,450 --> 00:10:26,489
second to 100,000 transactions per

307
00:10:26,489 --> 00:10:28,729
second, all you have to do is keep adding more

308
00:10:28,729 --> 00:10:30,330
nodes, and it will keep working.

309
00:10:31,109 --> 00:10:32,658
But what we really do is

310
00:10:32,960 --> 00:10:34,678
if you're writing data to the database,

311
00:10:34,989 --> 00:10:37,029
if you're writing tape like you know we write data

312
00:10:37,029 --> 00:10:37,599
in a table,

313
00:10:37,960 --> 00:10:40,038
right, we take this data, kind of break

314
00:10:40,038 --> 00:10:41,479
it up into small ranges.

315
00:10:41,798 --> 00:10:43,840
We call it a lot of people call it partitions, some people call

316
00:10:43,840 --> 00:10:45,960
it shards, we like to call it ranges, all right, so

317
00:10:45,960 --> 00:10:48,119
we take these ranges, I'm showing

318
00:10:48,119 --> 00:10:49,109
that as different colors.

319
00:10:49,389 --> 00:10:51,840
We then take these ranges and we start replicating

320
00:10:51,840 --> 00:10:53,519
that across multiple instances.

321
00:10:54,075 --> 00:10:55,293
So at a time,

322
00:10:55,594 --> 00:10:57,634
the default is generally 3, right?

323
00:10:57,913 --> 00:10:59,994
And then we actually keep, keep replicating

324
00:10:59,994 --> 00:11:02,033
more new new data, that means we have

325
00:11:02,033 --> 00:11:03,724
more copies of the data available.

326
00:11:04,075 --> 00:11:05,134
Now what happens is

327
00:11:05,394 --> 00:11:07,614
if one node is not available

328
00:11:07,913 --> 00:11:09,315
in this distributed system,

329
00:11:09,715 --> 00:11:11,715
the data in the copy is always available

330
00:11:11,715 --> 00:11:14,094
on the cluster, so it will always be able to serve

331
00:11:14,094 --> 00:11:15,433
the user's use case.

332
00:11:16,190 --> 00:11:18,349
So that's one of the biggest differences, and that

333
00:11:18,349 --> 00:11:19,690
can happen in a single

334
00:11:19,950 --> 00:11:21,450
cluster in a single region.

335
00:11:21,719 --> 00:11:22,229
However,

336
00:11:22,509 --> 00:11:24,548
we take resiliency very seriously, so we

337
00:11:24,548 --> 00:11:26,070
go and take it to the next level.

338
00:11:26,629 --> 00:11:28,969
We basically can also run cockroach

339
00:11:29,149 --> 00:11:31,450
as a single logical cluster

340
00:11:31,908 --> 00:11:33,729
across multiple regions.

341
00:11:34,190 --> 00:11:36,320
That means you can run it on region

342
00:11:36,320 --> 00:11:37,149
US East 1,

343
00:11:37,639 --> 00:11:38,349
US East 2.

344
00:11:39,000 --> 00:11:40,548
You can run it with EU.

345
00:11:40,928 --> 00:11:42,119
You can run it in APAC,

346
00:11:42,440 --> 00:11:44,440
but one single logical cluster to

347
00:11:44,440 --> 00:11:46,099
serve your global use cases,

348
00:11:46,519 --> 00:11:48,639
and you can also run Cockroach across multiple

349
00:11:48,639 --> 00:11:50,469
clouds. We have customers who say,

350
00:11:50,779 --> 00:11:53,029
Hey, we want to make sure we cover for cloud

351
00:11:53,029 --> 00:11:53,609
outage.

352
00:11:53,960 --> 00:11:55,668
The entire cloud is something happens,

353
00:11:55,950 --> 00:11:56,879
we want to cover for that.

354
00:11:57,239 --> 00:11:59,250
So they also we have customers who run across

355
00:11:59,250 --> 00:12:00,428
multiple cloud providers,

356
00:12:00,729 --> 00:12:02,769
but we also have customers who run it in

357
00:12:02,769 --> 00:12:04,808
a hybrid hybrid way. You have your own

358
00:12:04,808 --> 00:12:05,450
data center.

359
00:12:05,729 --> 00:12:07,849
You can also run it along with your data center

360
00:12:07,849 --> 00:12:09,969
on the cloud. One of the easiest

361
00:12:09,969 --> 00:12:12,090
ways to migrate Cockroach is actually

362
00:12:12,090 --> 00:12:14,210
start using Cockroach in a single in

363
00:12:14,210 --> 00:12:15,029
your database.

364
00:12:15,514 --> 00:12:17,455
Your data center and then also

365
00:12:17,715 --> 00:12:19,875
start adding new nodes on your cloud

366
00:12:19,875 --> 00:12:21,984
AWS and then basically close

367
00:12:21,984 --> 00:12:24,303
your data center and then basically move

368
00:12:24,303 --> 00:12:26,375
everything to the cloud so it basically replicates data

369
00:12:26,375 --> 00:12:28,474
so it's so easy to migrate data without

370
00:12:28,474 --> 00:12:30,663
actually going through the pain of moving data

371
00:12:30,663 --> 00:12:32,994
actually so it will all get streamed

372
00:12:32,994 --> 00:12:33,793
without any problem.

373
00:12:34,178 --> 00:12:36,178
However, the benefit now is because you can

374
00:12:36,178 --> 00:12:38,538
run multi-region, multi-cloud, you can do hybrid,

375
00:12:38,700 --> 00:12:41,178
you can cover for really, really strong disaster

376
00:12:41,178 --> 00:12:43,210
situations. For example, you can actually have

377
00:12:43,210 --> 00:12:44,889
a situation where a region goes down,

378
00:12:45,178 --> 00:12:47,440
which has happened multiple times this year,

379
00:12:47,788 --> 00:12:50,119
right, and across all cloud providers. So when that

380
00:12:50,119 --> 00:12:52,440
kind of happens, you can actually continue to work

381
00:12:52,658 --> 00:12:54,859
because the data is always available and new

382
00:12:54,859 --> 00:12:57,308
copies will be created and it will all keep working.

383
00:12:57,500 --> 00:12:58,320
And similarly,

384
00:12:58,580 --> 00:13:00,779
You can also start to pin data down. So

385
00:13:00,779 --> 00:13:03,369
one of the unique capabilities of cockroach that

386
00:13:03,369 --> 00:13:05,519
makes that makes it really useful for

387
00:13:05,609 --> 00:13:07,649
for GDPR or a compliance perspective is

388
00:13:07,649 --> 00:13:09,820
that you can actually pin data down at a table

389
00:13:09,820 --> 00:13:11,379
level to a specific region.

390
00:13:11,859 --> 00:13:13,950
So what happens is you can actually say, hey, keep

391
00:13:13,950 --> 00:13:16,349
all my Region 1 data within Region 1, all

392
00:13:16,349 --> 00:13:17,580
the data within Region 2,

393
00:13:17,908 --> 00:13:19,950
Region 3, like that, and that's why some of the betting

394
00:13:19,950 --> 00:13:21,979
and gaming use cases that we have here in the

395
00:13:21,979 --> 00:13:24,190
US choose to run Cockroach DB. And

396
00:13:24,190 --> 00:13:26,418
in fact they sometimes these betting and gaming use

397
00:13:26,418 --> 00:13:28,619
cases don't even have certain regions where

398
00:13:28,619 --> 00:13:30,879
you know AWS is available. So they

399
00:13:30,918 --> 00:13:33,119
they use something called AWS Outpost. You

400
00:13:33,119 --> 00:13:34,399
can bring AWS outpost,

401
00:13:34,710 --> 00:13:37,038
run Cockroach TV in a way that it's

402
00:13:37,038 --> 00:13:39,229
extending the cloud, and it works together.

403
00:13:39,519 --> 00:13:41,719
So that's what you can do. But there's another benefit

404
00:13:41,719 --> 00:13:43,798
to this. When you run a global system, when

405
00:13:43,798 --> 00:13:45,869
you run users that are across

406
00:13:45,869 --> 00:13:48,038
multiple regions, you can also keep data

407
00:13:48,038 --> 00:13:48,798
close to them,

408
00:13:49,239 --> 00:13:51,259
thereby reducing the overall latency,

409
00:13:51,798 --> 00:13:54,080
right? So there's no hops happening. You can keep

410
00:13:54,080 --> 00:13:54,779
everything closer.

411
00:13:55,080 --> 00:13:56,308
And that way, you know,

412
00:13:56,649 --> 00:13:58,788
consistency and the performance is always

413
00:13:58,788 --> 00:14:01,080
great. So this is another benefit of allowing data

414
00:14:01,080 --> 00:14:03,129
pinning with Cockroach. So

415
00:14:03,129 --> 00:14:05,200
at a base level, as I was saying, Cockroach is a

416
00:14:05,200 --> 00:14:07,399
distributed system that is highly scalable.

417
00:14:07,649 --> 00:14:09,690
It's SQL compatible or SQL

418
00:14:09,928 --> 00:14:12,048
basically. It has vector capabilities and it's highly

419
00:14:12,048 --> 00:14:14,830
resilient because of this. So what we're going to

420
00:14:14,830 --> 00:14:16,899
do in today as we go and as we show the demo

421
00:14:16,899 --> 00:14:19,009
and everything else to you is actually we're going to kill

422
00:14:19,009 --> 00:14:20,029
a region live

423
00:14:20,580 --> 00:14:23,029
and we're going to see what really happens when you're running a workload.

424
00:14:23,580 --> 00:14:26,109
Which is something that you, you all will be, you know, something

425
00:14:26,298 --> 00:14:28,389
you all have read in the news or something, and let's see how

426
00:14:28,389 --> 00:14:29,349
it reacts, right?

427
00:14:29,830 --> 00:14:30,808
All right, so now

428
00:14:31,609 --> 00:14:33,668
another thing that I was saying, Cockroach also not just

429
00:14:33,668 --> 00:14:35,029
supports transactionals or

430
00:14:35,288 --> 00:14:37,739
SQL transactions, it also supports documents.

431
00:14:37,788 --> 00:14:39,908
It also supports spatial because it's built on

432
00:14:39,908 --> 00:14:42,070
posters wire compatibility. So if you have

433
00:14:42,070 --> 00:14:43,298
requirements to store JSON,

434
00:14:43,750 --> 00:14:46,090
you could do that as well. If you have requirements

435
00:14:46,090 --> 00:14:47,849
around fraud detection where you want to maybe say

436
00:14:48,269 --> 00:14:50,460
store geospatial data, you could do that as well. And

437
00:14:50,460 --> 00:14:53,029
then recently we also added the vector data capability.

438
00:14:54,109 --> 00:14:56,058
All right, so how's everybody doing? We're good?

439
00:14:56,469 --> 00:14:57,239
Good info?

440
00:14:57,869 --> 00:14:59,379
OK, hopefully we can keep up, right?

441
00:14:59,710 --> 00:15:01,950
Um, so now let's talk about the ve vector

442
00:15:01,950 --> 00:15:03,950
piece because the vector piece or the vector

443
00:15:03,950 --> 00:15:05,808
capabilities that we are using with Gen AI

444
00:15:06,590 --> 00:15:08,668
is not just about vector, it's also about the

445
00:15:08,668 --> 00:15:10,869
actual data stored on the database.

446
00:15:11,109 --> 00:15:13,149
You can have like different agents who might be

447
00:15:13,149 --> 00:15:14,379
queryringing for orders,

448
00:15:14,750 --> 00:15:16,788
you know, or actual transactions that have happened

449
00:15:16,788 --> 00:15:18,908
to specifically get information, so it doesn't

450
00:15:18,908 --> 00:15:21,308
have to be just vector data. It can be just

451
00:15:21,308 --> 00:15:22,969
depending on the use case can change a lot.

452
00:15:23,500 --> 00:15:24,950
So let's talk about the vector piece,

453
00:15:25,239 --> 00:15:27,269
right? So with cockroach we're going

454
00:15:27,269 --> 00:15:29,899
to now talk about how we can do rag agents

455
00:15:29,899 --> 00:15:32,158
memory with cockroach. So we're, I'm going to break it down

456
00:15:32,158 --> 00:15:33,889
into 3, into one

457
00:15:34,308 --> 00:15:35,308
actual use case.

458
00:15:35,629 --> 00:15:37,788
We'll show one answer engine, but we will

459
00:15:37,788 --> 00:15:39,889
show all 3 of these use cases and each

460
00:15:39,889 --> 00:15:41,529
of these specific architectures. So

461
00:15:42,029 --> 00:15:44,308
please feel free to take photographs

462
00:15:44,308 --> 00:15:45,418
of those architectures.

463
00:15:45,940 --> 00:15:48,099
So one of the first things I'm going to show you is rag

464
00:15:48,099 --> 00:15:48,950
with cockroach DB.

465
00:15:49,700 --> 00:15:51,700
Right, um, and so basically what I'm

466
00:15:51,700 --> 00:15:53,700
going to show you is I'm going to show you, uh, an

467
00:15:53,700 --> 00:15:55,830
answer engine that we have built, an assistant

468
00:15:56,340 --> 00:15:58,379
that actually uses the rack capabilities

469
00:15:58,379 --> 00:15:59,500
and works with cockroach TV.

470
00:15:59,969 --> 00:16:01,969
All right, so we will come back to this in a bit,

471
00:16:02,168 --> 00:16:03,879
but let's, let's take Vira's help here

472
00:16:04,178 --> 00:16:06,340
in actually switching over and getting familiar with the

473
00:16:06,340 --> 00:16:08,359
environment. So what you're seeing right now

474
00:16:08,500 --> 00:16:09,759
is cockroach console,

475
00:16:10,019 --> 00:16:12,178
and we, we have built monitoring into

476
00:16:12,178 --> 00:16:12,759
the product.

477
00:16:13,019 --> 00:16:15,178
So what you see here. We have a 5 node cockroach

478
00:16:15,178 --> 00:16:15,869
GB cluster.

479
00:16:16,288 --> 00:16:18,500
Two of them are running in US East 11

480
00:16:18,500 --> 00:16:20,769
is running in Central. Another one is in

481
00:16:20,769 --> 00:16:21,629
US West 2,

482
00:16:21,979 --> 00:16:23,428
OK, so 5 node cluster,

483
00:16:23,739 --> 00:16:25,859
right? And it's basically running as a distributed

484
00:16:25,859 --> 00:16:28,019
system. What we've also done to that is

485
00:16:28,019 --> 00:16:29,918
we have created a chaos environment, right?

486
00:16:30,178 --> 00:16:31,320
So what you will see is.

487
00:16:31,849 --> 00:16:33,859
This is what we will come back to towards

488
00:16:33,859 --> 00:16:36,690
the end when we start to run data. We'll actually

489
00:16:36,700 --> 00:16:38,109
actually kill kill nodes,

490
00:16:38,690 --> 00:16:40,729
create some latencies, and see what we can with

491
00:16:40,729 --> 00:16:42,849
the time we have and see

492
00:16:42,849 --> 00:16:45,109
how that experience kind of looks like in real time,

493
00:16:45,529 --> 00:16:47,590
right? And what we have also done is

494
00:16:47,590 --> 00:16:48,739
if Vira can continue.

495
00:16:49,450 --> 00:16:51,119
Uh, we, we're going to show you

496
00:16:51,379 --> 00:16:53,739
the tables actually that we have, right?

497
00:16:53,979 --> 00:16:56,298
So we have different tables. We have this expense

498
00:16:56,298 --> 00:16:57,349
table that we have created.

499
00:16:57,779 --> 00:16:59,979
The the app that we have built is basically a

500
00:16:59,979 --> 00:17:01,979
budgeting system or like a, it's like a

501
00:17:01,979 --> 00:17:04,140
banking app, and the banking app has a

502
00:17:04,140 --> 00:17:05,019
banking assistant.

503
00:17:05,529 --> 00:17:07,549
Any user can use it in different ways,

504
00:17:07,739 --> 00:17:09,858
and one of the, one of the tables related to banking is

505
00:17:09,858 --> 00:17:10,789
just expenses, right?

506
00:17:11,130 --> 00:17:13,019
So you can see that we have different expenses.

507
00:17:13,434 --> 00:17:15,443
And we have also created a vector index

508
00:17:15,584 --> 00:17:17,824
and a bunch of different things and you can also

509
00:17:17,824 --> 00:17:20,344
see, as I was saying, that you can create

510
00:17:20,344 --> 00:17:22,424
tables that are regional by you

511
00:17:22,424 --> 00:17:24,904
know location and

512
00:17:24,904 --> 00:17:27,164
so we have that local region by table primary.

513
00:17:27,384 --> 00:17:29,634
So basically you can pin data down specifically

514
00:17:29,634 --> 00:17:31,943
as well with cockroach. So this is just a table.

515
00:17:32,184 --> 00:17:34,184
Let's show the actual database with some

516
00:17:34,184 --> 00:17:34,844
data now.

517
00:17:37,199 --> 00:17:39,088
So if you can see we are going into the database,

518
00:17:39,568 --> 00:17:41,469
we're actually going to go into the expenses table.

519
00:17:42,358 --> 00:17:44,439
And you can see we have the expense ID, but all

520
00:17:44,439 --> 00:17:45,140
the way to the right

521
00:17:45,719 --> 00:17:46,930
we have the embeddings.

522
00:17:47,479 --> 00:17:49,719
So what they are storing is actual transactions,

523
00:17:49,838 --> 00:17:52,000
actual descriptions of what

524
00:17:52,000 --> 00:17:54,029
the person used or anyone is using to

525
00:17:54,029 --> 00:17:56,118
transact, and converting that description,

526
00:17:56,160 --> 00:17:58,559
the textual description, into actual embeddings

527
00:17:58,559 --> 00:18:00,759
so that we can make searches on that, a

528
00:18:00,759 --> 00:18:02,759
standard vector search. That's what we are doing.

529
00:18:03,000 --> 00:18:05,000
But the unique thing. About it is we

530
00:18:05,000 --> 00:18:07,309
have a lot of different information. We have

531
00:18:07,318 --> 00:18:09,598
information related to merchant. We have information related

532
00:18:09,598 --> 00:18:11,680
to the payment method used, a lot of different

533
00:18:11,680 --> 00:18:13,160
things than actual spend, right?

534
00:18:13,479 --> 00:18:15,559
And, if you can go all the way to the left of this,

535
00:18:15,640 --> 00:18:16,328
we'll see different.

536
00:18:16,709 --> 00:18:18,920
There are also different IDs, like different

537
00:18:18,920 --> 00:18:20,318
IDs for each transaction.

538
00:18:20,670 --> 00:18:23,189
So as I was saying, you can store OLTP

539
00:18:23,189 --> 00:18:25,608
or transaction data. Now you can also store

540
00:18:25,608 --> 00:18:27,650
vector data along with the OLTP data

541
00:18:27,650 --> 00:18:29,049
so you can actually read it back

542
00:18:29,309 --> 00:18:31,509
because none of us can read vector data. It's a computer

543
00:18:31,509 --> 00:18:33,588
language. It takes an array and

544
00:18:33,588 --> 00:18:35,588
converts it into a high dimensional array. So

545
00:18:35,588 --> 00:18:37,588
if somebody is trying to understand. What is

546
00:18:37,588 --> 00:18:38,348
this vector?

547
00:18:38,699 --> 00:18:40,949
It's very difficult to translate that unless unless

548
00:18:40,949 --> 00:18:41,750
you do

549
00:18:42,140 --> 00:18:44,269
go back and put it back to

550
00:18:44,269 --> 00:18:46,309
the actual text, but this way you have

551
00:18:46,309 --> 00:18:48,630
the benefit of seeing the actual transaction

552
00:18:48,630 --> 00:18:50,209
and the associated embedding

553
00:18:50,469 --> 00:18:52,549
with it. So that's something that you can think about

554
00:18:52,549 --> 00:18:54,019
if that use case requires that.

555
00:18:54,348 --> 00:18:56,549
And now we're going to show you the banking app

556
00:18:56,549 --> 00:18:58,750
itself. So this is a banking

557
00:18:58,750 --> 00:19:00,910
app as you can see, typical banking app that

558
00:19:00,910 --> 00:19:03,029
we have and we have built an assistant here.

559
00:19:03,269 --> 00:19:04,088
So let's run

560
00:19:04,509 --> 00:19:06,088
this Rag application right now.

561
00:19:06,670 --> 00:19:08,868
So Virag is gonna run a, a few

562
00:19:08,868 --> 00:19:09,568
statements.

563
00:19:09,989 --> 00:19:12,289
So what did I spend on.

564
00:19:13,019 --> 00:19:13,598
Coffee

565
00:19:14,318 --> 00:19:16,318
Which is a lot over the last 6 or 7 days as

566
00:19:16,318 --> 00:19:17,029
you can see.

567
00:19:18,170 --> 00:19:19,039
So we'll run this.

568
00:19:19,368 --> 00:19:21,848
What you will see is we have enabled database ops.

569
00:19:22,009 --> 00:19:24,239
So you can see we ran the query, we did the embedding,

570
00:19:24,410 --> 00:19:26,709
we did the vector search, we're doing the analysis.

571
00:19:26,969 --> 00:19:29,130
We're actually doing an AI processing. It's actually looking

572
00:19:29,130 --> 00:19:30,750
for the cash, as you can see,

573
00:19:32,108 --> 00:19:34,489
we have spent some money and then it has been able to do vector

574
00:19:34,489 --> 00:19:36,529
search on related to coffee and

575
00:19:36,529 --> 00:19:38,769
it's been able to bring this data back.

576
00:19:39,250 --> 00:19:40,430
So that's what's really happened.

577
00:19:40,910 --> 00:19:43,049
So let's break it down now. Let's go back

578
00:19:43,049 --> 00:19:44,670
to the architecture of Virag if we can.

579
00:19:45,608 --> 00:19:47,618
So let's, let's, let's help you understand what really

580
00:19:47,618 --> 00:19:48,519
happened here.

581
00:19:49,209 --> 00:19:51,380
We saw the it's an app that's a Flash app. The

582
00:19:51,380 --> 00:19:52,559
Flash app actually,

583
00:19:53,219 --> 00:19:55,259
when you run the query, basically hits the

584
00:19:55,259 --> 00:19:57,078
cache manager. It looks as if,

585
00:19:57,420 --> 00:19:59,699
hey, have I asked this question recently? Is

586
00:19:59,699 --> 00:20:01,489
this something the user is actually looking for?

587
00:20:01,858 --> 00:20:03,939
Because you don't want to always hit the large language

588
00:20:03,939 --> 00:20:05,979
model because it's going to require tokens and it's going

589
00:20:05,979 --> 00:20:08,289
to add cost. But if the user asks similar

590
00:20:08,289 --> 00:20:10,338
questions all the time, then you can actually cache it

591
00:20:10,338 --> 00:20:12,459
and reuse that data sometimes. So

592
00:20:12,459 --> 00:20:13,459
it looks for the cache.

593
00:20:13,750 --> 00:20:15,868
And then it actually converts the query

594
00:20:15,868 --> 00:20:18,180
that Virag added, the natural language, which

595
00:20:18,180 --> 00:20:20,259
was basically how much money did I spend on coffee.

596
00:20:20,469 --> 00:20:22,630
It ran it through a sentence transformer and

597
00:20:22,630 --> 00:20:24,660
converted that into embeddings, and then

598
00:20:24,660 --> 00:20:26,868
it did a vector search on the expenses

599
00:20:26,868 --> 00:20:28,739
table. You with me?

600
00:20:29,029 --> 00:20:30,009
Everyone with me? Great.

601
00:20:30,269 --> 00:20:32,299
So it then gets all the data,

602
00:20:32,549 --> 00:20:33,729
transaction data,

603
00:20:34,420 --> 00:20:35,410
anything related to the coffee,

604
00:20:35,868 --> 00:20:37,949
and then it basically formats that with

605
00:20:37,949 --> 00:20:40,108
the help of AWS Bedrock, and

606
00:20:40,108 --> 00:20:42,130
we're using the cloud model,

607
00:20:42,390 --> 00:20:44,588
and we use cloud with Bedrock and we

608
00:20:44,588 --> 00:20:46,588
get everything together and respond back to

609
00:20:46,588 --> 00:20:47,170
the user.

610
00:20:47,430 --> 00:20:49,088
So that's like the one flow.

611
00:20:49,559 --> 00:20:50,969
All right. However,

612
00:20:51,269 --> 00:20:53,269
if you keep doing this, if you have

613
00:20:53,269 --> 00:20:54,809
to do this for a million users.

614
00:20:55,299 --> 00:20:57,410
You have to start thinking about the tokens used

615
00:20:57,410 --> 00:20:59,180
and the costs associated with that

616
00:20:59,469 --> 00:21:01,519
right now you don't have to consider

617
00:21:01,519 --> 00:21:03,608
just the cloud bill. You have to start considering

618
00:21:03,828 --> 00:21:05,509
the bill of the AI provider,

619
00:21:05,828 --> 00:21:07,949
right? So we have to now start thinking what

620
00:21:07,949 --> 00:21:09,489
can we do to make this intelligent,

621
00:21:09,989 --> 00:21:12,229
what can we do to make the system optimized, and

622
00:21:12,229 --> 00:21:13,479
that's where we added the cash.

623
00:21:13,949 --> 00:21:16,309
So as you can see now, Vidra basically is going to

624
00:21:16,309 --> 00:21:18,309
turn DB ops on again and ask

625
00:21:18,309 --> 00:21:19,150
the same query.

626
00:21:20,578 --> 00:21:22,078
Uh, yeah,

627
00:21:22,618 --> 00:21:24,759
sorry. Oh, it came back, yeah,

628
00:21:25,259 --> 00:21:27,400
so the reason why it came back so quickly was

629
00:21:27,400 --> 00:21:28,559
because it did not hit

630
00:21:28,969 --> 00:21:31,180
the whole process. It's, it's so fast because it's

631
00:21:31,180 --> 00:21:31,759
already cash,

632
00:21:32,059 --> 00:21:34,059
right? So certain queries like that that

633
00:21:34,059 --> 00:21:36,180
a user is actually using, you can enable

634
00:21:36,180 --> 00:21:38,420
cash on top of that and make sure that this

635
00:21:38,660 --> 00:21:40,818
actual request kind of gets handled very quickly

636
00:21:40,818 --> 00:21:43,098
because of that. So that's one way to start doing.

637
00:21:43,410 --> 00:21:45,739
And so now let's show you what's happening

638
00:21:45,739 --> 00:21:46,318
behind the stage.

639
00:21:46,858 --> 00:21:49,098
So what you see is the same thing that I said.

640
00:21:49,299 --> 00:21:51,910
It actually did a cache mess first time

641
00:21:51,910 --> 00:21:54,299
and it went to Bedrock. It looked at the query.

642
00:21:54,539 --> 00:21:57,088
It actually took that query, converted that into embeddings.

643
00:21:57,259 --> 00:21:58,059
It did a cache hit.

644
00:21:58,519 --> 00:22:00,680
It found that this query was asked before.

645
00:22:00,959 --> 00:22:03,380
And then basically got that response, got

646
00:22:03,380 --> 00:22:05,618
the insights, and actually provided that the front

647
00:22:05,618 --> 00:22:07,779
end. So basically what it's doing is basically

648
00:22:07,779 --> 00:22:09,818
doing the same embedding, then searching in the

649
00:22:09,818 --> 00:22:11,939
cache if we have actually asked this kind of

650
00:22:11,939 --> 00:22:13,920
question. So this is one way to optimize,

651
00:22:14,500 --> 00:22:16,818
you know, the use cases that you may have with rag

652
00:22:16,818 --> 00:22:18,019
with cockroach JB.

653
00:22:18,779 --> 00:22:20,858
So that's, that's one thing. All right. So now let's

654
00:22:20,858 --> 00:22:22,358
go back, uh, to the,

655
00:22:22,828 --> 00:22:24,199
to the, to the architecture

656
00:22:24,618 --> 00:22:26,650
again. So that was the first one. If you want, you can take

657
00:22:26,650 --> 00:22:28,459
another photograph if, if you've not taken it.

658
00:22:28,818 --> 00:22:30,259
Now that's just one use case, right?

659
00:22:30,779 --> 00:22:32,949
You don't want the assistant just to do one thing.

660
00:22:33,299 --> 00:22:35,420
You may want to do multiple things. So maybe

661
00:22:35,420 --> 00:22:37,420
you're a user, you're like, Hey, listen, I want

662
00:22:37,420 --> 00:22:39,539
to check. I want to upload a receipt and

663
00:22:39,539 --> 00:22:41,539
I want, I want to budget. I want to check

664
00:22:41,539 --> 00:22:43,219
if there's a duplicate transaction,

665
00:22:43,500 --> 00:22:45,500
right? And that means you have to now

666
00:22:45,500 --> 00:22:47,539
start doing different things. Now you're bringing in

667
00:22:47,539 --> 00:22:48,719
different modalities,

668
00:22:49,140 --> 00:22:51,199
right? You're basically a receipt is an image,

669
00:22:51,660 --> 00:22:53,769
and so you have to figure out what to do. So for

670
00:22:53,769 --> 00:22:55,930
everything you'll have to start thinking like, hey, what tools

671
00:22:55,930 --> 00:22:57,500
can I use to make this happen.

672
00:22:57,930 --> 00:23:00,130
So in the next slide we're going to

673
00:23:00,130 --> 00:23:02,449
show you how you can do multiple agents

674
00:23:02,449 --> 00:23:03,608
in the same use case.

675
00:23:03,900 --> 00:23:05,469
So if you can go to the next slide where

676
00:23:07,059 --> 00:23:09,068
Oh sorry, sorry, I forgot. I have the clicker.

677
00:23:09,348 --> 00:23:11,029
So you can see what we have is

678
00:23:11,309 --> 00:23:13,509
we have a workflow orchestration system

679
00:23:13,509 --> 00:23:14,368
that we have built

680
00:23:14,789 --> 00:23:16,910
where we're going to use 3 agents. It's a

681
00:23:16,910 --> 00:23:18,529
crew of agents that kind of work together.

682
00:23:19,150 --> 00:23:20,709
So we're going to process a receipt,

683
00:23:21,209 --> 00:23:23,309
a, a normal transaction that we have done, maybe like

684
00:23:23,309 --> 00:23:25,449
think like Expensify, you upload a

685
00:23:25,549 --> 00:23:26,130
receipt.

686
00:23:26,400 --> 00:23:27,289
And that receipt,

687
00:23:27,559 --> 00:23:29,838
when you upload a receipt processing, the agent

688
00:23:29,838 --> 00:23:31,959
gets triggered, right, and that agent

689
00:23:31,959 --> 00:23:34,219
basically will start doing

690
00:23:34,219 --> 00:23:36,439
the processing. So it will go to OCR, it

691
00:23:36,439 --> 00:23:38,519
will take the data out, it will store that

692
00:23:38,519 --> 00:23:39,459
into the database.

693
00:23:39,799 --> 00:23:42,078
But then while that is happening, we are also

694
00:23:42,078 --> 00:23:42,618
going to check

695
00:23:42,880 --> 00:23:44,920
if this transaction is fraudulent or not. So

696
00:23:44,920 --> 00:23:46,920
we'll have a fraudulent checker agent.

697
00:23:47,318 --> 00:23:49,328
That basically is not just accessing the

698
00:23:49,328 --> 00:23:51,650
data, but it is also accessing the memories.

699
00:23:51,809 --> 00:23:54,189
And when we say memories, it's looking for different transactions.

700
00:23:54,328 --> 00:23:56,348
It's trying to see if the user has done something like

701
00:23:56,348 --> 00:23:57,130
this before or not.

702
00:23:57,529 --> 00:23:59,539
And then we are also in parallel going

703
00:23:59,539 --> 00:24:01,578
to do a budgeting agent, and the budgeting agent

704
00:24:01,578 --> 00:24:02,239
might be looking at,

705
00:24:02,500 --> 00:24:04,660
hey, is this transaction way out of budget

706
00:24:04,660 --> 00:24:05,380
or not, right?

707
00:24:05,680 --> 00:24:07,818
So you can do different cool things related to that, but

708
00:24:07,818 --> 00:24:09,818
we just wanted to bring these things together. But

709
00:24:09,818 --> 00:24:12,118
the key thing here for us to understand is

710
00:24:12,259 --> 00:24:13,420
that when you run an agent,

711
00:24:13,699 --> 00:24:15,858
these agents kind of work together, can work together

712
00:24:15,858 --> 00:24:17,858
and have access to tools, and

713
00:24:17,858 --> 00:24:19,900
these tools have access to

714
00:24:19,900 --> 00:24:21,019
different action points.

715
00:24:21,358 --> 00:24:23,250
So that's that's another thing that we can do.

716
00:24:23,608 --> 00:24:25,769
So now let's let's go back and actually

717
00:24:25,769 --> 00:24:27,479
see this happen in real time.

718
00:24:27,858 --> 00:24:29,939
So Viag is actually going to go and open an agent

719
00:24:29,939 --> 00:24:30,650
dashboard.

720
00:24:32,479 --> 00:24:34,799
Before he does that, he's going to upload a receipt.

721
00:24:35,328 --> 00:24:36,519
So this is just a receipt.

722
00:24:37,239 --> 00:24:39,420
And you will see an agent dashboard.

723
00:24:42,209 --> 00:24:44,430
It'll probably refresh that and as you refresh

724
00:24:44,430 --> 00:24:46,449
you can see that the receipt got processed

725
00:24:46,449 --> 00:24:48,608
with a 90% confidence. You can

726
00:24:48,608 --> 00:24:50,640
see that it looked for fraud. It

727
00:24:50,640 --> 00:24:52,930
found that this receipt is good, no

728
00:24:52,930 --> 00:24:55,088
issues, and then basically it looks for,

729
00:24:55,189 --> 00:24:57,368
you know, and it processes that for budget

730
00:24:57,368 --> 00:24:59,410
queries and things like that, and all these

731
00:24:59,410 --> 00:25:01,430
agents are kind of working together as you can

732
00:25:01,430 --> 00:25:03,529
see. And now this is not

733
00:25:03,529 --> 00:25:05,689
just one agent or one agenttic

734
00:25:05,689 --> 00:25:06,250
use case.

735
00:25:06,519 --> 00:25:08,689
Think about a user running multiple different agents

736
00:25:08,689 --> 00:25:10,789
like that. You have to start thinking

737
00:25:10,789 --> 00:25:12,910
about if my users start to do a lot more different

738
00:25:12,910 --> 00:25:15,029
things, I have to start considering the scale

739
00:25:15,029 --> 00:25:17,239
and resilience with which these agents are going to work.

740
00:25:17,469 --> 00:25:19,618
So we're not just solving a small problem, we

741
00:25:19,618 --> 00:25:21,660
have to solve 3 agents firstly a

742
00:25:21,660 --> 00:25:22,489
million users.

743
00:25:22,989 --> 00:25:25,328
So we're talking about 3 million agents running,

744
00:25:25,969 --> 00:25:28,348
right? And then at any given point in time

745
00:25:28,509 --> 00:25:30,949
these different things are going on. So you have to think about infrastructure

746
00:25:30,949 --> 00:25:32,368
associated with that and the scale.

747
00:25:32,709 --> 00:25:34,868
So as you can see we got the response when he uploaded

748
00:25:34,868 --> 00:25:35,598
the receipt

749
00:25:35,910 --> 00:25:36,459
that hey,

750
00:25:36,868 --> 00:25:39,269
that receipt was $96.82.

751
00:25:39,618 --> 00:25:40,858
It was related to food.

752
00:25:41,170 --> 00:25:42,500
It stored all of that information.

753
00:25:42,779 --> 00:25:44,539
No issues, etc. It's within budget.

754
00:25:44,838 --> 00:25:45,430
All good,

755
00:25:45,858 --> 00:25:48,059
right now. Let's do another thing. Maybe let's just

756
00:25:48,059 --> 00:25:49,449
upload the same receipt again.

757
00:25:49,818 --> 00:25:51,858
Let's see if we and see what really

758
00:25:51,858 --> 00:25:52,400
happens.

759
00:25:53,328 --> 00:25:55,699
So in this case it will do the same flow.

760
00:25:56,170 --> 00:25:58,608
It'll basically hit the budget. It'll hit the fraud

761
00:25:58,809 --> 00:26:00,979
and it'll try to figure out what's going on.

762
00:26:01,209 --> 00:26:03,209
And in this case it's starting to see that there is

763
00:26:03,209 --> 00:26:05,449
a suspicious transaction because it's already

764
00:26:05,449 --> 00:26:07,509
seen through the memory or through the data

765
00:26:07,890 --> 00:26:09,930
that this transactions have already come

766
00:26:09,930 --> 00:26:12,098
before, right? So it's able to understand

767
00:26:12,098 --> 00:26:14,368
some some anomaly in this data and

768
00:26:14,368 --> 00:26:16,463
then it's starting. To produce and say that OK, there

769
00:26:16,463 --> 00:26:18,164
is some sort of a suspicion

770
00:26:18,463 --> 00:26:20,223
that there is fraud associated with this.

771
00:26:20,594 --> 00:26:22,785
This is just one use case. There are multiple different

772
00:26:22,785 --> 00:26:24,983
use cases that you can unlock, but the pattern

773
00:26:24,983 --> 00:26:27,404
that we are observing in conversations with enterprises

774
00:26:27,404 --> 00:26:29,424
is that the system that you just saw,

775
00:26:29,545 --> 00:26:30,295
the architecture,

776
00:26:30,664 --> 00:26:32,703
that's how it's actually going. So if we can go

777
00:26:32,703 --> 00:26:33,743
back to the architecture.

778
00:26:34,130 --> 00:26:36,209
You will see like these are the things that is happening

779
00:26:36,209 --> 00:26:38,250
so it basically has to plan and

780
00:26:38,250 --> 00:26:40,529
it has to think about different aspects, different

781
00:26:40,529 --> 00:26:42,828
concepts related to that particular,

782
00:26:42,848 --> 00:26:44,969
you know, agent's responsibility and then it

783
00:26:44,969 --> 00:26:47,088
has to have access to different tools so

784
00:26:47,088 --> 00:26:48,309
it can take actions.

785
00:26:48,729 --> 00:26:49,900
All right, how are we doing good?

786
00:26:50,559 --> 00:26:52,650
We're good. So there is this blue box over

787
00:26:52,650 --> 00:26:53,630
there that I put together,

788
00:26:54,338 --> 00:26:56,828
right, that we put together it's called accessing memories.

789
00:26:57,400 --> 00:26:59,559
Right, how cool would it be if we can remember all

790
00:26:59,559 --> 00:27:01,559
the things that we have done? It's always our

791
00:27:01,559 --> 00:27:03,279
brains like RAM, right? It's always leaking out.

792
00:27:03,650 --> 00:27:05,719
We don't we forget everything, but we can

793
00:27:05,719 --> 00:27:07,880
do differently with these systems if we have

794
00:27:07,880 --> 00:27:10,549
enough storage and enough transaction capabilities.

795
00:27:10,880 --> 00:27:13,039
So what we can do is we can zoom in a little bit

796
00:27:13,039 --> 00:27:14,818
into how to access memories.

797
00:27:15,229 --> 00:27:17,309
And when we do memories, we're talking

798
00:27:17,309 --> 00:27:19,328
about a user's action, user's behavior,

799
00:27:19,789 --> 00:27:21,989
everything a user does, every choice a user does,

800
00:27:22,189 --> 00:27:24,189
you can actually store that on the database

801
00:27:24,358 --> 00:27:26,430
and then use that to actually give

802
00:27:26,430 --> 00:27:28,469
a user much more preferred customized

803
00:27:28,469 --> 00:27:30,670
results. So if you can just zoom into that Viraga

804
00:27:30,670 --> 00:27:32,328
a little bit, I'm going to do that.

805
00:27:32,588 --> 00:27:34,509
We're going to see, we're going to talk about memory,

806
00:27:34,828 --> 00:27:37,049
right? And this is something that cockroach already

807
00:27:37,049 --> 00:27:39,229
does. So the zooming into that blue

808
00:27:39,229 --> 00:27:41,650
bit is where we've actually added

809
00:27:42,019 --> 00:27:43,269
every agent

810
00:27:43,549 --> 00:27:44,809
basically does 3 things.

811
00:27:45,189 --> 00:27:46,650
It basically thinks,

812
00:27:47,118 --> 00:27:47,939
it acts,

813
00:27:48,229 --> 00:27:49,160
and it remembers.

814
00:27:49,559 --> 00:27:50,309
So think, act, remember,

815
00:27:50,818 --> 00:27:52,858
OK, that's the three things it's doing. So first,

816
00:27:52,868 --> 00:27:54,380
it thinks what it needs to do.

817
00:27:54,709 --> 00:27:57,059
It actually then also does a vector

818
00:27:57,059 --> 00:27:59,108
search related to the data where we are storing

819
00:27:59,108 --> 00:28:01,229
the embeddings, right? So agent memory

820
00:28:01,229 --> 00:28:03,449
is basically storing every aspect

821
00:28:03,630 --> 00:28:05,229
of what we have done so far.

822
00:28:05,509 --> 00:28:07,660
So whatever we did so far, the workflows, it

823
00:28:07,660 --> 00:28:09,868
is all getting stored in the database as users'

824
00:28:09,868 --> 00:28:10,469
actions,

825
00:28:10,789 --> 00:28:11,890
and then it's basically

826
00:28:12,150 --> 00:28:13,509
searching those semantically.

827
00:28:13,799 --> 00:28:15,868
And then basically making a decision

828
00:28:16,118 --> 00:28:18,289
associated with this memory as to what

829
00:28:18,289 --> 00:28:19,539
the user's preference should be.

830
00:28:19,890 --> 00:28:21,890
So when you build these systems, you will have to

831
00:28:21,890 --> 00:28:24,289
start to think about how can we

832
00:28:24,289 --> 00:28:26,489
add these capabilities and these memory

833
00:28:26,489 --> 00:28:27,880
points into the database

834
00:28:28,250 --> 00:28:30,680
and how can we consider that into the overall.

835
00:28:31,064 --> 00:28:31,864
Of the application.

836
00:28:32,184 --> 00:28:34,233
Now this is not the only way memory gets used. There

837
00:28:34,233 --> 00:28:35,795
are multiple different options,

838
00:28:36,074 --> 00:28:38,314
but this is one way we use it in this example

839
00:28:38,314 --> 00:28:40,394
just to convey the idea of why

840
00:28:40,394 --> 00:28:42,674
it's important to use memory with

841
00:28:42,674 --> 00:28:44,674
GI applications. So if Vira can

842
00:28:44,674 --> 00:28:46,795
actually go into the database, he's going to show

843
00:28:46,795 --> 00:28:47,973
you the exact table.

844
00:28:48,338 --> 00:28:49,358
And we'll show you

845
00:28:49,759 --> 00:28:51,818
some of the things. So we have agent decisions. We are

846
00:28:51,818 --> 00:28:53,699
storing the decisions that the agent took,

847
00:28:54,059 --> 00:28:56,338
right? We are looking at the agent

848
00:28:56,338 --> 00:28:58,799
memory and you can see it's stored

849
00:28:59,059 --> 00:28:59,949
the budget check.

850
00:29:00,250 --> 00:29:02,338
It's stored at the embedding related

851
00:29:02,338 --> 00:29:04,380
to that. Every action that a user

852
00:29:04,380 --> 00:29:06,459
is doing, we're actually storing it in real

853
00:29:06,459 --> 00:29:08,779
time so that as users do more,

854
00:29:09,500 --> 00:29:11,769
the model and the AI system can actually

855
00:29:11,769 --> 00:29:14,098
get trained on that and be a much more

856
00:29:14,098 --> 00:29:16,259
defined, much more accurate loop

857
00:29:16,259 --> 00:29:18,118
for the user's actual use cases.

858
00:29:19,029 --> 00:29:21,130
And as you can see, the decision, every decision

859
00:29:21,130 --> 00:29:23,430
that has been taken, every preference that the user

860
00:29:23,430 --> 00:29:25,430
had, I don't know if you've noticed sometimes when you

861
00:29:25,430 --> 00:29:27,509
use these large language models they

862
00:29:27,509 --> 00:29:28,910
give you two different results

863
00:29:29,309 --> 00:29:31,420
and they ask you to choose what you like. It's

864
00:29:31,420 --> 00:29:33,789
basically choosing your preference, actually storing

865
00:29:33,789 --> 00:29:34,750
it into a database,

866
00:29:35,068 --> 00:29:37,068
and then it's accessing that to give you a

867
00:29:37,068 --> 00:29:38,459
preferred response every time.

868
00:29:38,789 --> 00:29:40,949
So you can do things like that as you build

869
00:29:40,949 --> 00:29:41,699
your systems.

870
00:29:41,989 --> 00:29:44,108
Now this is, this is just one example

871
00:29:44,108 --> 00:29:46,469
of agentic systems coming together

872
00:29:46,469 --> 00:29:46,989
beautifully.

873
00:29:47,680 --> 00:29:49,199
Right, so hopefully,

874
00:29:49,519 --> 00:29:51,000
so far we are great, right?

875
00:29:52,009 --> 00:29:54,078
But let's take it to one more level. Let's take

876
00:29:54,078 --> 00:29:55,229
it one more level up.

877
00:29:55,640 --> 00:29:57,838
Let's do all of this in real time and

878
00:29:57,838 --> 00:29:58,660
actually kill

879
00:29:59,309 --> 00:30:00,039
US East 1.

880
00:30:01,068 --> 00:30:03,088
OK, so it recently happened, so

881
00:30:03,088 --> 00:30:05,140
we'll just do that and let's, let's maybe what

882
00:30:05,140 --> 00:30:07,650
we can do is we can use a data generator

883
00:30:07,650 --> 00:30:09,670
to basically generate some data in real

884
00:30:09,670 --> 00:30:11,769
time. Basically, we're hitting the database,

885
00:30:12,269 --> 00:30:14,469
we are, you know, we're creating transactions. We added

886
00:30:14,469 --> 00:30:15,449
a generator here.

887
00:30:15,818 --> 00:30:18,049
And what Vira is going to do is going to generate,

888
00:30:19,068 --> 00:30:20,269
say 10,000 transactions.

889
00:30:20,559 --> 00:30:22,719
It's going to prepare these logs and it's going to start

890
00:30:22,719 --> 00:30:23,578
hitting the database.

891
00:30:24,000 --> 00:30:26,019
So what we'll do is we'll go to the console

892
00:30:26,229 --> 00:30:28,539
and we'll go and see these transactions

893
00:30:28,539 --> 00:30:30,640
kind of pop into the database. So we are seeing this

894
00:30:30,640 --> 00:30:31,680
database of working,

895
00:30:32,029 --> 00:30:34,439
transactions happening. You can see one of our monitoring

896
00:30:34,439 --> 00:30:35,459
nodes went down

897
00:30:35,868 --> 00:30:38,039
because what Virag did was actually

898
00:30:38,039 --> 00:30:39,299
he has actually killed

899
00:30:39,640 --> 00:30:41,709
two of our nodes in real time. So two of

900
00:30:41,709 --> 00:30:43,809
our nodes are actually down. And it's going to start

901
00:30:43,809 --> 00:30:46,009
popping up saying that hey, two of Cockroach

902
00:30:46,009 --> 00:30:47,299
DB nodes are not available,

903
00:30:47,608 --> 00:30:49,640
but the transactions are still going on.

904
00:30:49,910 --> 00:30:51,910
No issues. If we can go to the logs,

905
00:30:51,920 --> 00:30:54,209
Vira, we can see that it's processing

906
00:30:54,209 --> 00:30:56,759
all these logs, all these transactions

907
00:30:56,759 --> 00:30:59,130
without any error. You can see there is a spike here.

908
00:30:59,209 --> 00:31:00,809
That means transactions are going on.

909
00:31:01,088 --> 00:31:03,289
So Cockroach basically will allow you to

910
00:31:03,289 --> 00:31:05,449
essentially run systems that never go down,

911
00:31:05,689 --> 00:31:06,989
even when a region is down.

912
00:31:07,380 --> 00:31:09,380
So now the benefit of this is you

913
00:31:09,380 --> 00:31:11,500
can apply that when you apply it

914
00:31:11,500 --> 00:31:13,559
to any use case related to OLTP

915
00:31:13,818 --> 00:31:16,098
or and generative AI or using vector.

916
00:31:16,259 --> 00:31:18,259
So you have the same paradigm that

917
00:31:18,259 --> 00:31:20,420
can be used to build these systems.

918
00:31:21,269 --> 00:31:23,469
So you can see that all these systems, even

919
00:31:23,469 --> 00:31:24,430
though the nodes are down,

920
00:31:24,828 --> 00:31:26,828
everything is working fine. There's no outage on

921
00:31:26,828 --> 00:31:28,848
the application layer. Wouldn't that be great?

922
00:31:29,229 --> 00:31:30,568
How many of you want to have,

923
00:31:30,910 --> 00:31:33,180
uh, that kind of a life where systems go down,

924
00:31:33,390 --> 00:31:35,500
but you, you're like, OK, let me finish my lunch and I'll

925
00:31:35,500 --> 00:31:36,410
go back fix it?

926
00:31:36,868 --> 00:31:38,868
How many of you? Raise your hands. OK, great, great to know

927
00:31:38,868 --> 00:31:40,920
that. So, so that's the idea. So

928
00:31:40,920 --> 00:31:43,519
now we actually have also recovered

929
00:31:43,519 --> 00:31:45,640
it, right? Vira? Did you recover that? Great. So

930
00:31:45,640 --> 00:31:47,719
that's, that's the, that's the benefit of cockroach

931
00:31:47,719 --> 00:31:50,118
TB. You have a resilient system that

932
00:31:50,118 --> 00:31:52,160
allows for an always on experience that

933
00:31:52,160 --> 00:31:54,348
can now be applied to generative AI use cases

934
00:31:54,348 --> 00:31:55,618
with agents and memory.

935
00:31:56,000 --> 00:31:58,029
So that's, that's, that's another thing. But

936
00:31:58,029 --> 00:32:00,318
you must be wondering if you can go back to the deck rack.

937
00:32:01,549 --> 00:32:02,920
Like this is cool, David. Yeah,

938
00:32:03,189 --> 00:32:05,469
this makes sense. I've heard a similar message from multiple

939
00:32:05,469 --> 00:32:07,989
places. Have you heard something similar from different places?

940
00:32:08,588 --> 00:32:09,170
Maybe,

941
00:32:09,789 --> 00:32:11,910
maybe, yeah, or if I'm, I'm glad if

942
00:32:11,910 --> 00:32:13,430
this is the first time you're hearing this,

943
00:32:13,828 --> 00:32:15,219
but this is cool.

944
00:32:15,549 --> 00:32:17,650
Yeah, cockroach can store OLTP data.

945
00:32:17,868 --> 00:32:19,949
It can also store vector. Oh, and it,

946
00:32:19,989 --> 00:32:21,479
it can also store JSON.

947
00:32:21,789 --> 00:32:23,828
OK, cool. I can avoid database sprawl. I

948
00:32:23,828 --> 00:32:25,328
can maybe use one database

949
00:32:25,588 --> 00:32:27,309
to actually get everything to work. Cool.

950
00:32:27,630 --> 00:32:28,529
OK, that's fine.

951
00:32:29,068 --> 00:32:29,689
So what?

952
00:32:30,250 --> 00:32:31,358
What makes it special?

953
00:32:32,108 --> 00:32:34,180
All these different things are good to know,

954
00:32:34,390 --> 00:32:35,880
but what really makes special,

955
00:32:36,309 --> 00:32:38,828
right? I mean, maybe there are other options available. What

956
00:32:38,828 --> 00:32:40,608
makes Cockroach DB special for vector?

957
00:32:40,989 --> 00:32:43,068
Now that is an answer that I was just

958
00:32:43,068 --> 00:32:45,150
trying to search and I went really deep

959
00:32:45,150 --> 00:32:47,309
talking to our product team. I started to ask them

960
00:32:47,309 --> 00:32:49,390
really what happens with vectors, right? And

961
00:32:49,390 --> 00:32:50,680
this is just the last bit,

962
00:32:51,189 --> 00:32:54,229
right? One of the challenges with vectorization

963
00:32:54,390 --> 00:32:55,769
is that if you take

964
00:32:56,430 --> 00:32:57,250
a text

965
00:32:57,818 --> 00:33:00,150
which a text says boy is walking, girl

966
00:33:00,150 --> 00:33:00,709
is walking.

967
00:33:01,108 --> 00:33:03,400
I am studying, you'd run it through an embedding,

968
00:33:03,519 --> 00:33:05,920
it actually turns it into a vector dimension.

969
00:33:06,118 --> 00:33:08,539
A vector is a high dimensional array of numbers,

970
00:33:08,670 --> 00:33:09,880
you know, that we don't understand.

971
00:33:10,279 --> 00:33:12,029
But the unique thing about this is

972
00:33:12,358 --> 00:33:14,479
that you should all know is a text is

973
00:33:14,479 --> 00:33:15,578
just 14 bytes,

974
00:33:16,180 --> 00:33:18,519
right? It's very small sometimes. So these things are

975
00:33:18,519 --> 00:33:20,799
generally like 1416 bytes, really

976
00:33:20,799 --> 00:33:23,078
small on a database, totally fine,

977
00:33:23,358 --> 00:33:24,660
but when you vectorize it.

978
00:33:25,170 --> 00:33:27,489
Through like some sort of a standard embedding

979
00:33:27,489 --> 00:33:29,689
model like OpenAI or Sentence bird

980
00:33:29,689 --> 00:33:31,150
or which is what we use,

981
00:33:31,689 --> 00:33:33,709
or the vision embedding model or basically

982
00:33:33,930 --> 00:33:36,009
what happens is every array is

983
00:33:36,009 --> 00:33:36,750
4 bytes.

984
00:33:37,789 --> 00:33:39,959
So when you can take a 14

985
00:33:39,959 --> 00:33:42,098
byte text and run it through

986
00:33:42,098 --> 00:33:44,598
a 1536 dimension embedding

987
00:33:44,598 --> 00:33:45,118
model,

988
00:33:46,269 --> 00:33:48,439
you basically turn that vector into a 3 to 4

989
00:33:48,439 --> 00:33:49,439
kilobyte size.

990
00:33:52,410 --> 00:33:53,838
OK, so that's what happens.

991
00:33:54,219 --> 00:33:56,098
So you basically make the size way bigger,

992
00:33:56,500 --> 00:33:58,539
which makes sense. I mean you can maybe start

993
00:33:58,539 --> 00:34:00,618
to use it in on S3. There are certain use

994
00:34:00,618 --> 00:34:02,660
cases where you can use an object store to store

995
00:34:02,660 --> 00:34:04,769
all of this, and you have infinite storage, no

996
00:34:04,769 --> 00:34:07,009
problem. But when you want to do it with a database

997
00:34:07,009 --> 00:34:09,010
where you want to do real time and you want to

998
00:34:09,010 --> 00:34:11,059
do much more resilience and add those

999
00:34:11,059 --> 00:34:13,119
kind of capabilities that exist

1000
00:34:13,219 --> 00:34:14,438
with your actual data,

1001
00:34:14,780 --> 00:34:16,619
you have to start thinking that this is a problem.

1002
00:34:17,320 --> 00:34:19,760
And this is where we are noticing a lot of different

1003
00:34:19,760 --> 00:34:21,938
people who are trying to build these systems on vector

1004
00:34:21,938 --> 00:34:24,159
databases are struggling because sometimes there's

1005
00:34:24,159 --> 00:34:25,110
performance issues,

1006
00:34:25,438 --> 00:34:27,438
right? So what is happening is when

1007
00:34:27,438 --> 00:34:29,599
you do text to vectors, you can actually increase

1008
00:34:29,599 --> 00:34:31,639
the size by 20,000% to like if

1009
00:34:31,639 --> 00:34:33,070
you, if you do the calculation.

1010
00:34:33,398 --> 00:34:35,619
That was just an exponential number that I want to get to.

1011
00:34:36,500 --> 00:34:38,539
So we need to reduce the size. We want

1012
00:34:38,539 --> 00:34:39,958
to avoid database bloat.

1013
00:34:40,717 --> 00:34:42,768
Right, that's one challenge with vectors.

1014
00:34:43,157 --> 00:34:44,217
But at the same time,

1015
00:34:44,858 --> 00:34:46,998
when I'm, I've been talking about it from the very beginning

1016
00:34:46,998 --> 00:34:49,387
is you don't have to store 10,000 vectors.

1017
00:34:49,509 --> 00:34:50,498
We have to store

1018
00:34:50,838 --> 00:34:52,188
maybe a million vectors,

1019
00:34:52,637 --> 00:34:54,759
maybe 10 billion vectors, 20 million

1020
00:34:54,759 --> 00:34:55,498
vectors,

1021
00:34:55,878 --> 00:34:57,197
maybe a billion vectors,

1022
00:34:57,518 --> 00:34:59,099
and then you need to also search them.

1023
00:34:59,559 --> 00:35:01,588
So you have to search all these vectors in,

1024
00:35:01,637 --> 00:35:02,518
in the database.

1025
00:35:02,798 --> 00:35:03,858
You have to do a scan,

1026
00:35:04,228 --> 00:35:06,268
and these scans are going to be expensive on the

1027
00:35:06,268 --> 00:35:06,798
database.

1028
00:35:07,458 --> 00:35:09,820
Right? So you need to make sure that it can scale

1029
00:35:09,820 --> 00:35:10,599
without limits.

1030
00:35:12,159 --> 00:35:13,500
And then the third piece is,

1031
00:35:13,918 --> 00:35:16,110
say, so you're over here, you're user

1032
00:35:16,110 --> 00:35:18,188
A, you went and had a coffee at Starbucks,

1033
00:35:18,199 --> 00:35:19,099
you paid $15.

1034
00:35:19,760 --> 00:35:20,429
My friend here,

1035
00:35:20,958 --> 00:35:21,500
Hirsh,

1036
00:35:22,079 --> 00:35:24,898
uh, went and had coffee and spent, say, $18

1037
00:35:25,438 --> 00:35:27,559
right? So you both are doing a similar

1038
00:35:27,559 --> 00:35:29,668
transaction, went and had coffee, but you're two

1039
00:35:29,668 --> 00:35:30,539
different users

1040
00:35:30,958 --> 00:35:33,360
and maybe some one of you went in, they

1041
00:35:33,559 --> 00:35:35,418
bought an iPhone from the App Store

1042
00:35:36,159 --> 00:35:38,478
from Apple Store for $1000 and

1043
00:35:38,478 --> 00:35:40,619
somebody bought it from T-Mobile for $350

1044
00:35:40,619 --> 00:35:41,519
because they got a discount.

1045
00:35:42,179 --> 00:35:44,300
So at the database level in the vector

1046
00:35:44,300 --> 00:35:46,079
world, when you look at it in a high dimension,

1047
00:35:46,500 --> 00:35:47,719
it kind of, it's the same.

1048
00:35:48,378 --> 00:35:50,530
Right, it doesn't know it's user A or user B.

1049
00:35:50,769 --> 00:35:52,550
It looks, so there is a possibility

1050
00:35:52,849 --> 00:35:54,769
that you can in the vectorization,

1051
00:35:56,119 --> 00:35:58,090
you can bring user A's data close to user B.

1052
00:35:59,070 --> 00:36:01,550
And when you do a vector search now you can actually

1053
00:36:01,550 --> 00:36:03,789
kind of add a problem where

1054
00:36:03,789 --> 00:36:06,019
you start to produce a different user's data

1055
00:36:06,019 --> 00:36:06,949
to another user

1056
00:36:07,269 --> 00:36:09,610
and thereby basically skewing the response

1057
00:36:09,750 --> 00:36:10,769
in the vector search.

1058
00:36:11,030 --> 00:36:13,378
So we have to, when we build databases with vectors,

1059
00:36:13,550 --> 00:36:15,250
we have to think about optimizing this.

1060
00:36:15,708 --> 00:36:17,510
So we really want this behavior.

1061
00:36:18,159 --> 00:36:20,320
We want to search specifically user

1062
00:36:20,320 --> 00:36:20,978
A's data

1063
00:36:21,599 --> 00:36:23,840
for their vectors. We want to specifically search user

1064
00:36:23,840 --> 00:36:24,978
B's data for

1065
00:36:25,239 --> 00:36:27,398
their data and then produce the result

1066
00:36:27,398 --> 00:36:29,719
because that's the actual true performative

1067
00:36:29,719 --> 00:36:30,300
experience.

1068
00:36:30,840 --> 00:36:32,599
So what did we do to solve this problem?

1069
00:36:32,878 --> 00:36:33,918
We actually built.

1070
00:36:34,619 --> 00:36:37,099
The world's first distributed vector index.

1071
00:36:37,469 --> 00:36:39,500
So already Cockroach is a distributed database.

1072
00:36:39,780 --> 00:36:42,269
It has all these goodness of resilience,

1073
00:36:42,780 --> 00:36:43,458
scale,

1074
00:36:43,918 --> 00:36:45,938
you know, performance, all these things that are built into it.

1075
00:36:46,489 --> 00:36:47,489
On top of that,

1076
00:36:47,780 --> 00:36:49,820
on top of what already makes it good, we added

1077
00:36:49,820 --> 00:36:52,208
the world's first distributed index, and it's inspired

1078
00:36:52,208 --> 00:36:54,478
by some really influential papers that have come out

1079
00:36:54,668 --> 00:36:56,684
called. scan and as fresh

1080
00:36:57,144 --> 00:36:59,264
and then we've also added quantization model. So all

1081
00:36:59,264 --> 00:37:01,704
of these things kind of work together. So the quantization

1082
00:37:01,704 --> 00:37:03,945
model actually allows reducing database

1083
00:37:03,945 --> 00:37:06,603
load. We're able to reduce load by about 94%

1084
00:37:07,094 --> 00:37:08,905
on the actual data stored.

1085
00:37:09,224 --> 00:37:11,304
So when you store the data now in the vector form,

1086
00:37:11,344 --> 00:37:12,704
it's about 200 kilobytes,

1087
00:37:13,103 --> 00:37:13,664
give or take.

1088
00:37:14,429 --> 00:37:16,719
So reducing database load and also

1089
00:37:16,719 --> 00:37:19,079
we can now do these kind of things because

1090
00:37:19,079 --> 00:37:20,300
we are a distributed system

1091
00:37:20,559 --> 00:37:22,969
because we have the ability to do data locality,

1092
00:37:23,199 --> 00:37:24,099
we can actually

1093
00:37:24,840 --> 00:37:27,090
create a vector index per user

1094
00:37:27,090 --> 00:37:27,820
so you can do

1095
00:37:28,119 --> 00:37:30,148
vector index, user ID, and embedding.

1096
00:37:30,360 --> 00:37:31,458
So when you create the table.

1097
00:37:32,478 --> 00:37:34,478
Or when you create the index, and the same thing you can

1098
00:37:34,478 --> 00:37:36,099
do, you can create an index

1099
00:37:36,398 --> 00:37:38,679
per user per region because you also

1100
00:37:38,679 --> 00:37:39,539
have the regional

1101
00:37:40,119 --> 00:37:42,559
awareness in the database. So thereby

1102
00:37:42,559 --> 00:37:44,590
now when you query some information for a user,

1103
00:37:44,800 --> 00:37:46,958
we'll go exactly to that user's

1104
00:37:46,958 --> 00:37:49,159
information and search exactly a vector search

1105
00:37:49,159 --> 00:37:51,579
within that, thereby making it scalable

1106
00:37:51,719 --> 00:37:52,260
for the limit

1107
00:37:52,599 --> 00:37:54,668
that you might have with your users. Those are some

1108
00:37:54,668 --> 00:37:55,760
cool things that you can do,

1109
00:37:56,039 --> 00:37:57,320
some things that you can consider.

1110
00:37:58,059 --> 00:38:00,059
So obviously this is an evolving space. We're

1111
00:38:00,059 --> 00:38:00,780
also learning.

1112
00:38:01,300 --> 00:38:03,378
We love to get feedback from people on different use

1113
00:38:03,378 --> 00:38:05,610
cases. These are some of the things that we have explored

1114
00:38:05,610 --> 00:38:06,809
and learned as a process.

1115
00:38:07,228 --> 00:38:09,418
We are here, all the demo that you saw here

1116
00:38:09,418 --> 00:38:11,659
actually worked behind and got

1117
00:38:11,659 --> 00:38:13,739
everything to come together. That's, that's how we kind

1118
00:38:13,739 --> 00:38:15,449
of discovered this whole process as we talked to the.

1119
00:38:16,543 --> 00:38:18,735
Courses who are kind of exploring this with us,

1120
00:38:19,155 --> 00:38:21,284
uh, so as I've asked to, as we

1121
00:38:21,284 --> 00:38:23,454
conclude, just want to tell you like Cockroach DB basically

1122
00:38:23,454 --> 00:38:25,764
is the foundation for Data layer, right, for modern

1123
00:38:25,764 --> 00:38:26,324
enterprise.

1124
00:38:26,773 --> 00:38:28,813
Some of our largest customers use cockroach for

1125
00:38:28,813 --> 00:38:29,523
resilience,

1126
00:38:29,853 --> 00:38:32,114
multi-active, elastic horizontal scale,

1127
00:38:32,364 --> 00:38:34,534
geolocation awareness, and the ability to run

1128
00:38:34,974 --> 00:38:36,594
anywhere. And what we have done today

1129
00:38:36,934 --> 00:38:39,293
is added G AI capabilities and

1130
00:38:39,293 --> 00:38:41,333
allowing for these kind of new use cases to come

1131
00:38:41,333 --> 00:38:42,293
on top of cockroach.

1132
00:38:42,574 --> 00:38:44,534
So if you're looking to explore, looking to learn.

1133
00:38:44,878 --> 00:38:46,969
Check out some of the things that we have done. Obviously,

1134
00:38:47,239 --> 00:38:49,519
uh, you know, feel free to use these architectures

1135
00:38:49,519 --> 00:38:51,398
and, you know, broaden them, expand them,

1136
00:38:51,750 --> 00:38:53,750
play around with them, and we would love to get your feedback

1137
00:38:53,750 --> 00:38:54,590
on those as well.

1138
00:38:55,059 --> 00:38:56,800
Uh, if you want to get started with Cockroach DB.

1139
00:38:57,530 --> 00:38:58,918
We have different offerings available

1140
00:38:59,300 --> 00:39:01,530
if you're somebody who likes to use SAS.

1141
00:39:01,780 --> 00:39:04,050
We have a SAS product. It's called Cockroach Cloud.

1142
00:39:04,289 --> 00:39:05,610
It has 3 different versions.

1143
00:39:05,898 --> 00:39:06,918
We have

1144
00:39:08,039 --> 00:39:09,769
a service option where you can just come in,

1145
00:39:10,030 --> 00:39:10,820
you know, read and write,

1146
00:39:11,179 --> 00:39:13,500
play around with the product. You have all these capabilities

1147
00:39:13,500 --> 00:39:14,699
that I showed you into that.

1148
00:39:15,050 --> 00:39:17,050
We also have an advanced product in

1149
00:39:17,050 --> 00:39:19,050
the Cockroach cloud, and then if you don't want to

1150
00:39:19,050 --> 00:39:21,079
use SAS, you want to host it within your VPC,

1151
00:39:21,239 --> 00:39:22,409
say within AWS,

1152
00:39:22,688 --> 00:39:24,648
you can actually use Cockroach to be self-hosted,

1153
00:39:25,010 --> 00:39:27,090
whereas the license you can use it on

1154
00:39:27,090 --> 00:39:27,800
EC2,

1155
00:39:28,079 --> 00:39:30,429
EKS or Outpost, wherever you would like to,

1156
00:39:30,530 --> 00:39:31,300
you know, use it.

1157
00:39:31,789 --> 00:39:33,280
Uh, we would love to hear from you guys,

1158
00:39:33,728 --> 00:39:35,628
love to learn more about what you guys are doing.

1159
00:39:35,949 --> 00:39:38,050
Um, what you thought about it. So my team is

1160
00:39:38,050 --> 00:39:38,579
right here.

1161
00:39:38,860 --> 00:39:41,019
We're gonna give everyone back 20 minutes because time is

1162
00:39:41,019 --> 00:39:43,139
important and, but

1163
00:39:43,139 --> 00:39:45,179
information that is quality can be, you know,

1164
00:39:45,260 --> 00:39:47,489
put together quickly. So hopefully these 40

1165
00:39:47,489 --> 00:39:48,418
minutes have helped you.

1166
00:39:48,688 --> 00:39:50,780
Uh, if you wanna learn more about us, you want some

1167
00:39:50,780 --> 00:39:51,340
free credits,

1168
00:39:51,619 --> 00:39:53,000
please scan this QR code.

1169
00:39:53,260 --> 00:39:55,300
This is gonna take you to some really good information

1170
00:39:55,300 --> 00:39:56,159
that we have,

1171
00:39:56,639 --> 00:39:58,769
uh, and obviously hopefully we can give you

1172
00:39:58,769 --> 00:39:59,760
all the information,

1173
00:40:00,110 --> 00:40:01,820
uh, as you connect with us and with our team.

1174
00:40:02,559 --> 00:40:04,760
So thank you so much. Uh thank you, Viag, for

1175
00:40:04,760 --> 00:40:06,659
all the work. Really appreciate your time.

1176
00:40:07,000 --> 00:40:07,398
Thank you.

